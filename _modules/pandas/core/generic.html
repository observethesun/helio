

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>pandas.core.generic &mdash; helio  documentation</title>
  

  
  
  
  

  
  <script type="text/javascript" src="../../../_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../../../" src="../../../_static/documentation_options.js"></script>
        <script src="../../../_static/jquery.js"></script>
        <script src="../../../_static/underscore.js"></script>
        <script src="../../../_static/doctools.js"></script>
        <script src="../../../_static/language_data.js"></script>
    
    <script type="text/javascript" src="../../../_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="../../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../../../index.html" class="icon icon-home"> helio
          

          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../../api/helio.html">API</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">helio</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../../index.html">Docs</a> &raquo;</li>
        
          <li><a href="../../index.html">Module code</a> &raquo;</li>
        
      <li>pandas.core.generic</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for pandas.core.generic</h1><div class="highlight"><pre>
<span></span><span class="kn">import</span> <span class="nn">collections</span>
<span class="kn">from</span> <span class="nn">datetime</span> <span class="k">import</span> <span class="n">timedelta</span>
<span class="kn">import</span> <span class="nn">functools</span>
<span class="kn">import</span> <span class="nn">gc</span>
<span class="kn">import</span> <span class="nn">json</span>
<span class="kn">import</span> <span class="nn">operator</span>
<span class="kn">import</span> <span class="nn">pickle</span>
<span class="kn">from</span> <span class="nn">textwrap</span> <span class="k">import</span> <span class="n">dedent</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="k">import</span> <span class="n">Callable</span><span class="p">,</span> <span class="n">FrozenSet</span><span class="p">,</span> <span class="n">List</span><span class="p">,</span> <span class="n">Optional</span><span class="p">,</span> <span class="n">Set</span>
<span class="kn">import</span> <span class="nn">warnings</span>
<span class="kn">import</span> <span class="nn">weakref</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>

<span class="kn">from</span> <span class="nn">pandas._config</span> <span class="k">import</span> <span class="n">config</span>

<span class="kn">from</span> <span class="nn">pandas._libs</span> <span class="k">import</span> <span class="n">Timestamp</span><span class="p">,</span> <span class="n">iNaT</span><span class="p">,</span> <span class="n">properties</span>
<span class="kn">from</span> <span class="nn">pandas.compat</span> <span class="k">import</span> <span class="n">set_function_name</span>
<span class="kn">from</span> <span class="nn">pandas.compat._optional</span> <span class="k">import</span> <span class="n">import_optional_dependency</span>
<span class="kn">from</span> <span class="nn">pandas.compat.numpy</span> <span class="k">import</span> <span class="n">function</span> <span class="k">as</span> <span class="n">nv</span>
<span class="kn">from</span> <span class="nn">pandas.errors</span> <span class="k">import</span> <span class="n">AbstractMethodError</span>
<span class="kn">from</span> <span class="nn">pandas.util._decorators</span> <span class="k">import</span> <span class="n">Appender</span><span class="p">,</span> <span class="n">Substitution</span><span class="p">,</span> <span class="n">rewrite_axis_style_signature</span>
<span class="kn">from</span> <span class="nn">pandas.util._validators</span> <span class="k">import</span> <span class="n">validate_bool_kwarg</span><span class="p">,</span> <span class="n">validate_fillna_kwargs</span>

<span class="kn">from</span> <span class="nn">pandas.core.dtypes.cast</span> <span class="k">import</span> <span class="n">maybe_promote</span><span class="p">,</span> <span class="n">maybe_upcast_putmask</span>
<span class="kn">from</span> <span class="nn">pandas.core.dtypes.common</span> <span class="k">import</span> <span class="p">(</span>
    <span class="n">ensure_int64</span><span class="p">,</span>
    <span class="n">ensure_object</span><span class="p">,</span>
    <span class="n">ensure_str</span><span class="p">,</span>
    <span class="n">is_bool</span><span class="p">,</span>
    <span class="n">is_bool_dtype</span><span class="p">,</span>
    <span class="n">is_datetime64_any_dtype</span><span class="p">,</span>
    <span class="n">is_datetime64tz_dtype</span><span class="p">,</span>
    <span class="n">is_dict_like</span><span class="p">,</span>
    <span class="n">is_extension_array_dtype</span><span class="p">,</span>
    <span class="n">is_integer</span><span class="p">,</span>
    <span class="n">is_list_like</span><span class="p">,</span>
    <span class="n">is_number</span><span class="p">,</span>
    <span class="n">is_numeric_dtype</span><span class="p">,</span>
    <span class="n">is_object_dtype</span><span class="p">,</span>
    <span class="n">is_period_arraylike</span><span class="p">,</span>
    <span class="n">is_re_compilable</span><span class="p">,</span>
    <span class="n">is_scalar</span><span class="p">,</span>
    <span class="n">is_timedelta64_dtype</span><span class="p">,</span>
    <span class="n">pandas_dtype</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">from</span> <span class="nn">pandas.core.dtypes.generic</span> <span class="k">import</span> <span class="n">ABCDataFrame</span><span class="p">,</span> <span class="n">ABCSeries</span>
<span class="kn">from</span> <span class="nn">pandas.core.dtypes.inference</span> <span class="k">import</span> <span class="n">is_hashable</span>
<span class="kn">from</span> <span class="nn">pandas.core.dtypes.missing</span> <span class="k">import</span> <span class="n">isna</span><span class="p">,</span> <span class="n">notna</span>

<span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>
<span class="kn">from</span> <span class="nn">pandas._typing</span> <span class="k">import</span> <span class="n">Dtype</span>
<span class="kn">from</span> <span class="nn">pandas.core</span> <span class="k">import</span> <span class="n">missing</span><span class="p">,</span> <span class="n">nanops</span>
<span class="kn">import</span> <span class="nn">pandas.core.algorithms</span> <span class="k">as</span> <span class="nn">algos</span>
<span class="kn">from</span> <span class="nn">pandas.core.base</span> <span class="k">import</span> <span class="n">PandasObject</span><span class="p">,</span> <span class="n">SelectionMixin</span>
<span class="kn">import</span> <span class="nn">pandas.core.common</span> <span class="k">as</span> <span class="nn">com</span>
<span class="kn">from</span> <span class="nn">pandas.core.index</span> <span class="k">import</span> <span class="p">(</span>
    <span class="n">Index</span><span class="p">,</span>
    <span class="n">InvalidIndexError</span><span class="p">,</span>
    <span class="n">MultiIndex</span><span class="p">,</span>
    <span class="n">RangeIndex</span><span class="p">,</span>
    <span class="n">ensure_index</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">from</span> <span class="nn">pandas.core.indexes.datetimes</span> <span class="k">import</span> <span class="n">DatetimeIndex</span>
<span class="kn">from</span> <span class="nn">pandas.core.indexes.period</span> <span class="k">import</span> <span class="n">Period</span><span class="p">,</span> <span class="n">PeriodIndex</span>
<span class="kn">import</span> <span class="nn">pandas.core.indexing</span> <span class="k">as</span> <span class="nn">indexing</span>
<span class="kn">from</span> <span class="nn">pandas.core.internals</span> <span class="k">import</span> <span class="n">BlockManager</span>
<span class="kn">from</span> <span class="nn">pandas.core.ops</span> <span class="k">import</span> <span class="n">_align_method_FRAME</span>

<span class="kn">from</span> <span class="nn">pandas.io.formats.format</span> <span class="k">import</span> <span class="n">DataFrameFormatter</span><span class="p">,</span> <span class="n">format_percentiles</span>
<span class="kn">from</span> <span class="nn">pandas.io.formats.printing</span> <span class="k">import</span> <span class="n">pprint_thing</span>
<span class="kn">from</span> <span class="nn">pandas.tseries.frequencies</span> <span class="k">import</span> <span class="n">to_offset</span>

<span class="c1"># goal is to be able to define the docs close to function, while still being</span>
<span class="c1"># able to share</span>
<span class="n">_shared_docs</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
<span class="n">_shared_doc_kwargs</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span>
    <span class="n">axes</span><span class="o">=</span><span class="s2">&quot;keywords for axes&quot;</span><span class="p">,</span>
    <span class="n">klass</span><span class="o">=</span><span class="s2">&quot;Series/DataFrame&quot;</span><span class="p">,</span>
    <span class="n">axes_single_arg</span><span class="o">=</span><span class="s2">&quot;int or labels for object&quot;</span><span class="p">,</span>
    <span class="n">args_transpose</span><span class="o">=</span><span class="s2">&quot;axes to permute (int or label for object)&quot;</span><span class="p">,</span>
    <span class="n">optional_by</span><span class="o">=</span><span class="s2">&quot;&quot;&quot;</span>
<span class="s2">        by : str or list of str</span>
<span class="s2">            Name or list of names to sort by&quot;&quot;&quot;</span><span class="p">,</span>
<span class="p">)</span>

<span class="c1"># sentinel value to use as kwarg in place of None when None has special meaning</span>
<span class="c1"># and needs to be distinguished from a user explicitly passing None.</span>
<span class="n">sentinel</span> <span class="o">=</span> <span class="nb">object</span><span class="p">()</span>


<span class="k">def</span> <span class="nf">_single_replace</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">to_replace</span><span class="p">,</span> <span class="n">method</span><span class="p">,</span> <span class="n">inplace</span><span class="p">,</span> <span class="n">limit</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Replaces values in a Series using the fill method specified when no</span>
<span class="sd">    replacement value is given in the replace method</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
            <span class="s2">&quot;cannot replace </span><span class="si">{0}</span><span class="s2"> with method </span><span class="si">{1}</span><span class="s2"> on a </span><span class="si">{2}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                <span class="n">to_replace</span><span class="p">,</span> <span class="n">method</span><span class="p">,</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span>
            <span class="p">)</span>
        <span class="p">)</span>

    <span class="n">orig_dtype</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dtype</span>
    <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span> <span class="k">if</span> <span class="n">inplace</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="n">fill_f</span> <span class="o">=</span> <span class="n">missing</span><span class="o">.</span><span class="n">get_fill_func</span><span class="p">(</span><span class="n">method</span><span class="p">)</span>

    <span class="n">mask</span> <span class="o">=</span> <span class="n">missing</span><span class="o">.</span><span class="n">mask_missing</span><span class="p">(</span><span class="n">result</span><span class="o">.</span><span class="n">values</span><span class="p">,</span> <span class="n">to_replace</span><span class="p">)</span>
    <span class="n">values</span> <span class="o">=</span> <span class="n">fill_f</span><span class="p">(</span><span class="n">result</span><span class="o">.</span><span class="n">values</span><span class="p">,</span> <span class="n">limit</span><span class="o">=</span><span class="n">limit</span><span class="p">,</span> <span class="n">mask</span><span class="o">=</span><span class="n">mask</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">values</span><span class="o">.</span><span class="n">dtype</span> <span class="o">==</span> <span class="n">orig_dtype</span> <span class="ow">and</span> <span class="n">inplace</span><span class="p">:</span>
        <span class="k">return</span>

    <span class="n">result</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">values</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span><span class="o">.</span><span class="n">__finalize__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">inplace</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_update_inplace</span><span class="p">(</span><span class="n">result</span><span class="o">.</span><span class="n">_data</span><span class="p">)</span>
        <span class="k">return</span>

    <span class="k">return</span> <span class="n">result</span>


<span class="k">class</span> <span class="nc">NDFrame</span><span class="p">(</span><span class="n">PandasObject</span><span class="p">,</span> <span class="n">SelectionMixin</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    N-dimensional analogue of DataFrame. Store multi-dimensional in a</span>
<span class="sd">    size-mutable, labeled data structure</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    data : BlockManager</span>
<span class="sd">    axes : list</span>
<span class="sd">    copy : boolean, default False</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">_internal_names</span> <span class="o">=</span> <span class="p">[</span>
        <span class="s2">&quot;_data&quot;</span><span class="p">,</span>
        <span class="s2">&quot;_cacher&quot;</span><span class="p">,</span>
        <span class="s2">&quot;_item_cache&quot;</span><span class="p">,</span>
        <span class="s2">&quot;_cache&quot;</span><span class="p">,</span>
        <span class="s2">&quot;_is_copy&quot;</span><span class="p">,</span>
        <span class="s2">&quot;_subtyp&quot;</span><span class="p">,</span>
        <span class="s2">&quot;_name&quot;</span><span class="p">,</span>
        <span class="s2">&quot;_index&quot;</span><span class="p">,</span>
        <span class="s2">&quot;_default_kind&quot;</span><span class="p">,</span>
        <span class="s2">&quot;_default_fill_value&quot;</span><span class="p">,</span>
        <span class="s2">&quot;_metadata&quot;</span><span class="p">,</span>
        <span class="s2">&quot;__array_struct__&quot;</span><span class="p">,</span>
        <span class="s2">&quot;__array_interface__&quot;</span><span class="p">,</span>
    <span class="p">]</span>  <span class="c1"># type: List[str]</span>
    <span class="n">_internal_names_set</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">_internal_names</span><span class="p">)</span>  <span class="c1"># type: Set[str]</span>
    <span class="n">_accessors</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>  <span class="c1"># type: Set[str]</span>
    <span class="n">_deprecations</span> <span class="o">=</span> <span class="nb">frozenset</span><span class="p">(</span>
        <span class="p">[</span><span class="s2">&quot;as_blocks&quot;</span><span class="p">,</span> <span class="s2">&quot;blocks&quot;</span><span class="p">,</span> <span class="s2">&quot;is_copy&quot;</span><span class="p">,</span> <span class="s2">&quot;ftypes&quot;</span><span class="p">,</span> <span class="s2">&quot;ix&quot;</span><span class="p">]</span>
    <span class="p">)</span>  <span class="c1"># type: FrozenSet[str]</span>
    <span class="n">_metadata</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># type: List[str]</span>
    <span class="n">_is_copy</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">_data</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># type: BlockManager</span>

    <span class="c1"># ----------------------------------------------------------------------</span>
    <span class="c1"># Constructors</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">data</span><span class="p">:</span> <span class="n">BlockManager</span><span class="p">,</span>
        <span class="n">axes</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="n">Index</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">copy</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">dtype</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Dtype</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">fastpath</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">):</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">fastpath</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">dtype</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">dtype</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">copy</span><span class="p">:</span>
                <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

            <span class="k">if</span> <span class="n">axes</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">ax</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">axes</span><span class="p">):</span>
                    <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">reindex_axis</span><span class="p">(</span><span class="n">ax</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">i</span><span class="p">)</span>

        <span class="nb">object</span><span class="o">.</span><span class="fm">__setattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;_is_copy&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="nb">object</span><span class="o">.</span><span class="fm">__setattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;_data&quot;</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span>
        <span class="nb">object</span><span class="o">.</span><span class="fm">__setattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;_item_cache&quot;</span><span class="p">,</span> <span class="p">{})</span>

    <span class="k">def</span> <span class="nf">_init_mgr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mgr</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; passed a manager and a axes dict &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">a</span><span class="p">,</span> <span class="n">axe</span> <span class="ow">in</span> <span class="n">axes</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">axe</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">mgr</span> <span class="o">=</span> <span class="n">mgr</span><span class="o">.</span><span class="n">reindex_axis</span><span class="p">(</span>
                    <span class="n">axe</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_get_block_manager_axis</span><span class="p">(</span><span class="n">a</span><span class="p">),</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span>
                <span class="p">)</span>

        <span class="c1"># make a copy if explicitly requested</span>
        <span class="k">if</span> <span class="n">copy</span><span class="p">:</span>
            <span class="n">mgr</span> <span class="o">=</span> <span class="n">mgr</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">dtype</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># avoid further copies if we can</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">mgr</span><span class="o">.</span><span class="n">blocks</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="ow">or</span> <span class="n">mgr</span><span class="o">.</span><span class="n">blocks</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">dtype</span> <span class="o">!=</span> <span class="n">dtype</span><span class="p">:</span>
                <span class="n">mgr</span> <span class="o">=</span> <span class="n">mgr</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">mgr</span>

    <span class="c1"># ----------------------------------------------------------------------</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">is_copy</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the copy.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
            <span class="s2">&quot;Attribute &#39;is_copy&#39; is deprecated and will be removed &quot;</span>
            <span class="s2">&quot;in a future version.&quot;</span><span class="p">,</span>
            <span class="ne">FutureWarning</span><span class="p">,</span>
            <span class="n">stacklevel</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_copy</span>

    <span class="nd">@is_copy</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">is_copy</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">msg</span><span class="p">):</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
            <span class="s2">&quot;Attribute &#39;is_copy&#39; is deprecated and will be removed &quot;</span>
            <span class="s2">&quot;in a future version.&quot;</span><span class="p">,</span>
            <span class="ne">FutureWarning</span><span class="p">,</span>
            <span class="n">stacklevel</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_is_copy</span> <span class="o">=</span> <span class="n">msg</span>

    <span class="k">def</span> <span class="nf">_validate_dtype</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dtype</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; validate the passed dtype &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">dtype</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">dtype</span> <span class="o">=</span> <span class="n">pandas_dtype</span><span class="p">(</span><span class="n">dtype</span><span class="p">)</span>

            <span class="c1"># a compound dtype</span>
            <span class="k">if</span> <span class="n">dtype</span><span class="o">.</span><span class="n">kind</span> <span class="o">==</span> <span class="s2">&quot;V&quot;</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span>
                    <span class="s2">&quot;compound dtypes are not implemented&quot;</span>
                    <span class="s2">&quot; in the </span><span class="si">{0}</span><span class="s2"> constructor&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">)</span>
                <span class="p">)</span>

        <span class="k">return</span> <span class="n">dtype</span>

    <span class="c1"># ----------------------------------------------------------------------</span>
    <span class="c1"># Construction</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_constructor</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Used when a manipulation result has the same dimensions as the</span>
<span class="sd">        original.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="n">AbstractMethodError</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_constructor_sliced</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Used when a manipulation result has one lower dimension(s) as the</span>
<span class="sd">        original, such as DataFrame single columns slicing.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="n">AbstractMethodError</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_constructor_expanddim</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Used when a manipulation result has one higher dimension as the</span>
<span class="sd">        original, such as Series.to_frame()</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span>

    <span class="c1"># ----------------------------------------------------------------------</span>
    <span class="c1"># Axis</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">_setup_axes</span><span class="p">(</span>
        <span class="bp">cls</span><span class="p">,</span>
        <span class="n">axes</span><span class="p">,</span>
        <span class="n">info_axis</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">stat_axis</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">aliases</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">axes_are_reversed</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">build_axes</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">ns</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">docs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Provide axes setup for the major PandasObjects.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        axes : the names of the axes in order (lowest to highest)</span>
<span class="sd">        info_axis_num : the axis of the selector dimension (int)</span>
<span class="sd">        stat_axis_num : the number of axis for the default stats (int)</span>
<span class="sd">        aliases : other names for a single axis (dict)</span>
<span class="sd">        axes_are_reversed : boolean whether to treat passed axes as</span>
<span class="sd">            reversed (DataFrame)</span>
<span class="sd">        build_axes : setup the axis properties (default True)</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">cls</span><span class="o">.</span><span class="n">_AXIS_ORDERS</span> <span class="o">=</span> <span class="n">axes</span>
        <span class="bp">cls</span><span class="o">.</span><span class="n">_AXIS_NUMBERS</span> <span class="o">=</span> <span class="p">{</span><span class="n">a</span><span class="p">:</span> <span class="n">i</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">a</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">axes</span><span class="p">)}</span>
        <span class="bp">cls</span><span class="o">.</span><span class="n">_AXIS_LEN</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">axes</span><span class="p">)</span>
        <span class="bp">cls</span><span class="o">.</span><span class="n">_AXIS_ALIASES</span> <span class="o">=</span> <span class="n">aliases</span> <span class="ow">or</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="bp">cls</span><span class="o">.</span><span class="n">_AXIS_IALIASES</span> <span class="o">=</span> <span class="p">{</span><span class="n">v</span><span class="p">:</span> <span class="n">k</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">cls</span><span class="o">.</span><span class="n">_AXIS_ALIASES</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>
        <span class="bp">cls</span><span class="o">.</span><span class="n">_AXIS_NAMES</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="nb">enumerate</span><span class="p">(</span><span class="n">axes</span><span class="p">))</span>
        <span class="bp">cls</span><span class="o">.</span><span class="n">_AXIS_REVERSED</span> <span class="o">=</span> <span class="n">axes_are_reversed</span>

        <span class="c1"># typ</span>
        <span class="nb">setattr</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="s2">&quot;_typ&quot;</span><span class="p">,</span> <span class="bp">cls</span><span class="o">.</span><span class="vm">__name__</span><span class="o">.</span><span class="n">lower</span><span class="p">())</span>

        <span class="c1"># indexing support</span>
        <span class="bp">cls</span><span class="o">.</span><span class="n">_ix</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="k">if</span> <span class="n">info_axis</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">cls</span><span class="o">.</span><span class="n">_info_axis_number</span> <span class="o">=</span> <span class="n">info_axis</span>
            <span class="bp">cls</span><span class="o">.</span><span class="n">_info_axis_name</span> <span class="o">=</span> <span class="n">axes</span><span class="p">[</span><span class="n">info_axis</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">stat_axis</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">cls</span><span class="o">.</span><span class="n">_stat_axis_number</span> <span class="o">=</span> <span class="n">stat_axis</span>
            <span class="bp">cls</span><span class="o">.</span><span class="n">_stat_axis_name</span> <span class="o">=</span> <span class="n">axes</span><span class="p">[</span><span class="n">stat_axis</span><span class="p">]</span>

        <span class="c1"># setup the actual axis</span>
        <span class="k">if</span> <span class="n">build_axes</span><span class="p">:</span>

            <span class="k">def</span> <span class="nf">set_axis</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">i</span><span class="p">):</span>
                <span class="nb">setattr</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">properties</span><span class="o">.</span><span class="n">AxisProperty</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">docs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">a</span><span class="p">)))</span>
                <span class="bp">cls</span><span class="o">.</span><span class="n">_internal_names_set</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">axes_are_reversed</span><span class="p">:</span>
                <span class="n">m</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="n">_AXIS_LEN</span> <span class="o">-</span> <span class="mi">1</span>
                <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">a</span> <span class="ow">in</span> <span class="bp">cls</span><span class="o">.</span><span class="n">_AXIS_NAMES</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                    <span class="n">set_axis</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">m</span> <span class="o">-</span> <span class="n">i</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">a</span> <span class="ow">in</span> <span class="bp">cls</span><span class="o">.</span><span class="n">_AXIS_NAMES</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                    <span class="n">set_axis</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span>

        <span class="k">assert</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ns</span><span class="p">,</span> <span class="nb">dict</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_construct_axes_dict</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return an axes dictionary for myself.&quot;&quot;&quot;</span>
        <span class="n">d</span> <span class="o">=</span> <span class="p">{</span><span class="n">a</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_axis</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="p">(</span><span class="n">axes</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">_AXIS_ORDERS</span><span class="p">)}</span>
        <span class="n">d</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">d</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_construct_axes_dict_from</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axes</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return an axes dictionary for the passed axes.&quot;&quot;&quot;</span>
        <span class="n">d</span> <span class="o">=</span> <span class="p">{</span><span class="n">a</span><span class="p">:</span> <span class="n">ax</span> <span class="k">for</span> <span class="n">a</span><span class="p">,</span> <span class="n">ax</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_AXIS_ORDERS</span><span class="p">,</span> <span class="n">axes</span><span class="p">)}</span>
        <span class="n">d</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">d</span>

    <span class="k">def</span> <span class="nf">_construct_axes_from_arguments</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">args</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">,</span> <span class="n">require_all</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">sentinel</span><span class="o">=</span><span class="kc">None</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Construct and returns axes if supplied in args/kwargs.</span>

<span class="sd">        If require_all, raise if all axis arguments are not supplied</span>
<span class="sd">        return a tuple of (axes, kwargs).</span>

<span class="sd">        sentinel specifies the default parameter when an axis is not</span>
<span class="sd">        supplied; useful to distinguish when a user explicitly passes None</span>
<span class="sd">        in scenarios where None has special meaning.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># construct the args</span>
        <span class="n">args</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">args</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_AXIS_ORDERS</span><span class="p">:</span>

            <span class="c1"># if we have an alias for this axis</span>
            <span class="n">alias</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_AXIS_IALIASES</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">alias</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">alias</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
                        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                            <span class="s2">&quot;arguments are mutually exclusive &quot;</span>
                            <span class="s2">&quot;for [</span><span class="si">%s</span><span class="s2">,</span><span class="si">%s</span><span class="s2">]&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">alias</span><span class="p">)</span>
                        <span class="p">)</span>
                    <span class="k">continue</span>
                <span class="k">if</span> <span class="n">alias</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
                    <span class="n">kwargs</span><span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">alias</span><span class="p">)</span>
                    <span class="k">continue</span>

            <span class="c1"># look for a argument by position</span>
            <span class="k">if</span> <span class="n">a</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">kwargs</span><span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="o">=</span> <span class="n">args</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
                <span class="k">except</span> <span class="ne">IndexError</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">require_all</span><span class="p">:</span>
                        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;not enough/duplicate arguments &quot;</span> <span class="s2">&quot;specified!&quot;</span><span class="p">)</span>

        <span class="n">axes</span> <span class="o">=</span> <span class="p">{</span><span class="n">a</span><span class="p">:</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">sentinel</span><span class="p">)</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_AXIS_ORDERS</span><span class="p">}</span>
        <span class="k">return</span> <span class="n">axes</span><span class="p">,</span> <span class="n">kwargs</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">_from_axes</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">axes</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="c1"># for construction from BlockManager</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">BlockManager</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">cls</span><span class="o">.</span><span class="n">_AXIS_REVERSED</span><span class="p">:</span>
                <span class="n">axes</span> <span class="o">=</span> <span class="n">axes</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">d</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="n">_construct_axes_dict_from</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">axes</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="n">d</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">kwargs</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="o">**</span><span class="n">d</span><span class="p">)</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">_get_axis_number</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">axis</span><span class="p">):</span>
        <span class="n">axis</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="n">_AXIS_ALIASES</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">axis</span><span class="p">,</span> <span class="n">axis</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">is_integer</span><span class="p">(</span><span class="n">axis</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">axis</span> <span class="ow">in</span> <span class="bp">cls</span><span class="o">.</span><span class="n">_AXIS_NAMES</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">axis</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">cls</span><span class="o">.</span><span class="n">_AXIS_NUMBERS</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span>
            <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                <span class="k">pass</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;No axis named </span><span class="si">{0}</span><span class="s2"> for object type </span><span class="si">{1}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">axis</span><span class="p">,</span> <span class="bp">cls</span><span class="p">))</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">_get_axis_name</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">axis</span><span class="p">):</span>
        <span class="n">axis</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="n">_AXIS_ALIASES</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">axis</span><span class="p">,</span> <span class="n">axis</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">axis</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">axis</span> <span class="ow">in</span> <span class="bp">cls</span><span class="o">.</span><span class="n">_AXIS_NUMBERS</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">axis</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">cls</span><span class="o">.</span><span class="n">_AXIS_NAMES</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span>
            <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                <span class="k">pass</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;No axis named </span><span class="si">{0}</span><span class="s2"> for object type </span><span class="si">{1}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">axis</span><span class="p">,</span> <span class="bp">cls</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">_get_axis</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axis</span><span class="p">):</span>
        <span class="n">name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_axis_name</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">_get_block_manager_axis</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">axis</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Map the axis to the block_manager axis.&quot;&quot;&quot;</span>
        <span class="n">axis</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="n">_get_axis_number</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">cls</span><span class="o">.</span><span class="n">_AXIS_REVERSED</span><span class="p">:</span>
            <span class="n">m</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="n">_AXIS_LEN</span> <span class="o">-</span> <span class="mi">1</span>
            <span class="k">return</span> <span class="n">m</span> <span class="o">-</span> <span class="n">axis</span>
        <span class="k">return</span> <span class="n">axis</span>

    <span class="k">def</span> <span class="nf">_get_axis_resolvers</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axis</span><span class="p">):</span>
        <span class="c1"># index or columns</span>
        <span class="n">axis_index</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axis</span><span class="p">)</span>
        <span class="n">d</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="n">prefix</span> <span class="o">=</span> <span class="n">axis</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">name</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">axis_index</span><span class="o">.</span><span class="n">names</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">name</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">key</span> <span class="o">=</span> <span class="n">level</span> <span class="o">=</span> <span class="n">name</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># prefix with &#39;i&#39; or &#39;c&#39; depending on the input axis</span>
                <span class="c1"># e.g., you must do ilevel_0 for the 0th level of an unnamed</span>
                <span class="c1"># multiiindex</span>
                <span class="n">key</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="si">{prefix}</span><span class="s2">level_</span><span class="si">{i}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">prefix</span><span class="o">=</span><span class="n">prefix</span><span class="p">,</span> <span class="n">i</span><span class="o">=</span><span class="n">i</span><span class="p">)</span>
                <span class="n">level</span> <span class="o">=</span> <span class="n">i</span>

            <span class="n">level_values</span> <span class="o">=</span> <span class="n">axis_index</span><span class="o">.</span><span class="n">get_level_values</span><span class="p">(</span><span class="n">level</span><span class="p">)</span>
            <span class="n">s</span> <span class="o">=</span> <span class="n">level_values</span><span class="o">.</span><span class="n">to_series</span><span class="p">()</span>
            <span class="n">s</span><span class="o">.</span><span class="n">index</span> <span class="o">=</span> <span class="n">axis_index</span>
            <span class="n">d</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">s</span>

        <span class="c1"># put the index/columns itself in the dict</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">axis_index</span><span class="p">,</span> <span class="n">MultiIndex</span><span class="p">):</span>
            <span class="n">dindex</span> <span class="o">=</span> <span class="n">axis_index</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">dindex</span> <span class="o">=</span> <span class="n">axis_index</span><span class="o">.</span><span class="n">to_series</span><span class="p">()</span>

        <span class="n">d</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="n">dindex</span>
        <span class="k">return</span> <span class="n">d</span>

    <span class="k">def</span> <span class="nf">_get_index_resolvers</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">d</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">axis_name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_AXIS_ORDERS</span><span class="p">:</span>
            <span class="n">d</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_get_axis_resolvers</span><span class="p">(</span><span class="n">axis_name</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">d</span>

    <span class="k">def</span> <span class="nf">_get_space_character_free_column_resolvers</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the space character free column resolvers of a dataframe.</span>

<span class="sd">        Column names with spaces are &#39;cleaned up&#39; so that they can be referred</span>
<span class="sd">        to by backtick quoting.</span>
<span class="sd">        Used in :meth:`DataFrame.eval`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">pandas.core.computation.common</span> <span class="k">import</span> <span class="n">_remove_spaces_column_name</span>

        <span class="k">return</span> <span class="p">{</span><span class="n">_remove_spaces_column_name</span><span class="p">(</span><span class="n">k</span><span class="p">):</span> <span class="n">v</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_info_axis</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_info_axis_name</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_stat_axis</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_stat_axis_name</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">shape</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a tuple of axis dimensions</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_get_axis</span><span class="p">(</span><span class="n">a</span><span class="p">))</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_AXIS_ORDERS</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">axes</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return index label(s) of the internal NDFrame</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># we do it this way because if we have reversed axes, then</span>
        <span class="c1"># the block manager shows then reversed</span>
        <span class="k">return</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_get_axis</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_AXIS_ORDERS</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">ndim</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return an int representing the number of axes / array dimensions.</span>

<span class="sd">        Return 1 if Series. Otherwise return 2 if DataFrame.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        ndarray.ndim : Number of array dimensions.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; s = pd.Series({&#39;a&#39;: 1, &#39;b&#39;: 2, &#39;c&#39;: 3})</span>
<span class="sd">        &gt;&gt;&gt; s.ndim</span>
<span class="sd">        1</span>

<span class="sd">        &gt;&gt;&gt; df = pd.DataFrame({&#39;col1&#39;: [1, 2], &#39;col2&#39;: [3, 4]})</span>
<span class="sd">        &gt;&gt;&gt; df.ndim</span>
<span class="sd">        2</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">ndim</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">size</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return an int representing the number of elements in this object.</span>

<span class="sd">        Return the number of rows if Series. Otherwise return the number of</span>
<span class="sd">        rows times number of columns if DataFrame.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        ndarray.size : Number of elements in the array.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; s = pd.Series({&#39;a&#39;: 1, &#39;b&#39;: 2, &#39;c&#39;: 3})</span>
<span class="sd">        &gt;&gt;&gt; s.size</span>
<span class="sd">        3</span>

<span class="sd">        &gt;&gt;&gt; df = pd.DataFrame({&#39;col1&#39;: [1, 2], &#39;col2&#39;: [3, 4]})</span>
<span class="sd">        &gt;&gt;&gt; df.size</span>
<span class="sd">        4</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_selected_obj</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; internal compat with SelectionMixin &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_obj_with_exclusions</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; internal compat with SelectionMixin &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">set_axis</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">labels</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Assign desired index to given axis.</span>

<span class="sd">        Indexes for column or row labels can be changed by assigning</span>
<span class="sd">        a list-like or Index.</span>

<span class="sd">        .. versionchanged:: 0.21.0</span>

<span class="sd">           The signature is now `labels` and `axis`, consistent with</span>
<span class="sd">           the rest of pandas API. Previously, the `axis` and `labels`</span>
<span class="sd">           arguments were respectively the first and second positional</span>
<span class="sd">           arguments.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        labels : list-like, Index</span>
<span class="sd">            The values for the new index.</span>

<span class="sd">        axis : {0 or &#39;index&#39;, 1 or &#39;columns&#39;}, default 0</span>
<span class="sd">            The axis to update. The value 0 identifies the rows, and 1</span>
<span class="sd">            identifies the columns.</span>

<span class="sd">        inplace : bool, default None</span>
<span class="sd">            Whether to return a new %(klass)s instance.</span>

<span class="sd">            .. warning::</span>

<span class="sd">               ``inplace=None`` currently falls back to to True, but in a</span>
<span class="sd">               future version, will default to False. Use inplace=True</span>
<span class="sd">               explicitly rather than relying on the default.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        renamed : %(klass)s or None</span>
<span class="sd">            An object of same type as caller if inplace=False, None otherwise.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        DataFrame.rename_axis : Alter the name of the index or columns.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        **Series**</span>

<span class="sd">        &gt;&gt;&gt; s = pd.Series([1, 2, 3])</span>
<span class="sd">        &gt;&gt;&gt; s</span>
<span class="sd">        0    1</span>
<span class="sd">        1    2</span>
<span class="sd">        2    3</span>
<span class="sd">        dtype: int64</span>

<span class="sd">        &gt;&gt;&gt; s.set_axis([&#39;a&#39;, &#39;b&#39;, &#39;c&#39;], axis=0, inplace=False)</span>
<span class="sd">        a    1</span>
<span class="sd">        b    2</span>
<span class="sd">        c    3</span>
<span class="sd">        dtype: int64</span>

<span class="sd">        The original object is not modified.</span>

<span class="sd">        &gt;&gt;&gt; s</span>
<span class="sd">        0    1</span>
<span class="sd">        1    2</span>
<span class="sd">        2    3</span>
<span class="sd">        dtype: int64</span>

<span class="sd">        **DataFrame**</span>

<span class="sd">        &gt;&gt;&gt; df = pd.DataFrame({&quot;A&quot;: [1, 2, 3], &quot;B&quot;: [4, 5, 6]})</span>

<span class="sd">        Change the row labels.</span>

<span class="sd">        &gt;&gt;&gt; df.set_axis([&#39;a&#39;, &#39;b&#39;, &#39;c&#39;], axis=&#39;index&#39;, inplace=False)</span>
<span class="sd">           A  B</span>
<span class="sd">        a  1  4</span>
<span class="sd">        b  2  5</span>
<span class="sd">        c  3  6</span>

<span class="sd">        Change the column labels.</span>

<span class="sd">        &gt;&gt;&gt; df.set_axis([&#39;I&#39;, &#39;II&#39;], axis=&#39;columns&#39;, inplace=False)</span>
<span class="sd">           I  II</span>
<span class="sd">        0  1   4</span>
<span class="sd">        1  2   5</span>
<span class="sd">        2  3   6</span>

<span class="sd">        Now, update the labels inplace.</span>

<span class="sd">        &gt;&gt;&gt; df.set_axis([&#39;i&#39;, &#39;ii&#39;], axis=&#39;columns&#39;, inplace=True)</span>
<span class="sd">        &gt;&gt;&gt; df</span>
<span class="sd">           i  ii</span>
<span class="sd">        0  1   4</span>
<span class="sd">        1  2   5</span>
<span class="sd">        2  3   6</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">is_scalar</span><span class="p">(</span><span class="n">labels</span><span class="p">):</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                <span class="s1">&#39;set_axis now takes &quot;labels&quot; as first argument, and &#39;</span>
                <span class="s1">&#39;&quot;axis&quot; as named parameter. The old form, with &quot;axis&quot; as &#39;</span>
                <span class="s1">&#39;first parameter and &quot;labels&quot; as second, is still supported &#39;</span>
                <span class="s2">&quot;but will be deprecated in a future version of pandas.&quot;</span><span class="p">,</span>
                <span class="ne">FutureWarning</span><span class="p">,</span>
                <span class="n">stacklevel</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="n">labels</span><span class="p">,</span> <span class="n">axis</span> <span class="o">=</span> <span class="n">axis</span><span class="p">,</span> <span class="n">labels</span>

        <span class="k">if</span> <span class="n">inplace</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                <span class="s2">&quot;set_axis currently defaults to operating inplace.</span><span class="se">\n</span><span class="s2">This &quot;</span>
                <span class="s2">&quot;will change in a future version of pandas, use &quot;</span>
                <span class="s2">&quot;inplace=True to avoid this warning.&quot;</span><span class="p">,</span>
                <span class="ne">FutureWarning</span><span class="p">,</span>
                <span class="n">stacklevel</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="n">inplace</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">if</span> <span class="n">inplace</span><span class="p">:</span>
            <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_axis_name</span><span class="p">(</span><span class="n">axis</span><span class="p">),</span> <span class="n">labels</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">obj</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">obj</span><span class="o">.</span><span class="n">set_axis</span><span class="p">(</span><span class="n">labels</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">obj</span>

    <span class="k">def</span> <span class="nf">_set_axis</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axis</span><span class="p">,</span> <span class="n">labels</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">set_axis</span><span class="p">(</span><span class="n">axis</span><span class="p">,</span> <span class="n">labels</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_clear_item_cache</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">transpose</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Permute the dimensions of the %(klass)s</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        args : %(args_transpose)s</span>
<span class="sd">        copy : boolean, default False</span>
<span class="sd">            Make a copy of the underlying data. Mixed-dtype data will</span>
<span class="sd">            always result in a copy</span>
<span class="sd">        **kwargs</span>
<span class="sd">            Additional keyword arguments will be passed to the function.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        y : same as input</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; p.transpose(2, 0, 1)</span>
<span class="sd">        &gt;&gt;&gt; p.transpose(2, 0, 1, copy=True)</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># construct the args</span>
        <span class="n">axes</span><span class="p">,</span> <span class="n">kwargs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_construct_axes_from_arguments</span><span class="p">(</span>
            <span class="n">args</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">,</span> <span class="n">require_all</span><span class="o">=</span><span class="kc">True</span>
        <span class="p">)</span>
        <span class="n">axes_names</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_get_axis_name</span><span class="p">(</span><span class="n">axes</span><span class="p">[</span><span class="n">a</span><span class="p">])</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_AXIS_ORDERS</span><span class="p">)</span>
        <span class="n">axes_numbers</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_get_axis_number</span><span class="p">(</span><span class="n">axes</span><span class="p">[</span><span class="n">a</span><span class="p">])</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_AXIS_ORDERS</span><span class="p">)</span>

        <span class="c1"># we must have unique axes</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">axes</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">axes</span><span class="p">)):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Must specify </span><span class="si">%s</span><span class="s2"> unique axes&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">_AXIS_LEN</span><span class="p">)</span>

        <span class="n">new_axes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_construct_axes_dict_from</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_get_axis</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">axes_names</span><span class="p">]</span>
        <span class="p">)</span>
        <span class="n">new_values</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">axes_numbers</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;copy&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="ow">and</span> <span class="n">args</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]):</span>
            <span class="n">new_values</span> <span class="o">=</span> <span class="n">new_values</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

        <span class="n">nv</span><span class="o">.</span><span class="n">validate_transpose</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(),</span> <span class="n">kwargs</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_constructor</span><span class="p">(</span><span class="n">new_values</span><span class="p">,</span> <span class="o">**</span><span class="n">new_axes</span><span class="p">)</span><span class="o">.</span><span class="n">__finalize__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">swapaxes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axis1</span><span class="p">,</span> <span class="n">axis2</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Interchange axes and swap values axes appropriately.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        y : same as input</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">i</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_axis_number</span><span class="p">(</span><span class="n">axis1</span><span class="p">)</span>
        <span class="n">j</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_axis_number</span><span class="p">(</span><span class="n">axis2</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="n">j</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">copy</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="k">return</span> <span class="bp">self</span>

        <span class="n">mapping</span> <span class="o">=</span> <span class="p">{</span><span class="n">i</span><span class="p">:</span> <span class="n">j</span><span class="p">,</span> <span class="n">j</span><span class="p">:</span> <span class="n">i</span><span class="p">}</span>

        <span class="n">new_axes</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_get_axis</span><span class="p">(</span><span class="n">mapping</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">k</span><span class="p">))</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_AXIS_LEN</span><span class="p">))</span>
        <span class="n">new_values</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">swapaxes</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">copy</span><span class="p">:</span>
            <span class="n">new_values</span> <span class="o">=</span> <span class="n">new_values</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_constructor</span><span class="p">(</span><span class="n">new_values</span><span class="p">,</span> <span class="o">*</span><span class="n">new_axes</span><span class="p">)</span><span class="o">.</span><span class="n">__finalize__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">droplevel</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">level</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return DataFrame with requested index / column level(s) removed.</span>

<span class="sd">        .. versionadded:: 0.24.0</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        level : int, str, or list-like</span>
<span class="sd">            If a string is given, must be the name of a level</span>
<span class="sd">            If list-like, elements must be names or positional indexes</span>
<span class="sd">            of levels.</span>

<span class="sd">        axis : {0 or &#39;index&#39;, 1 or &#39;columns&#39;}, default 0</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        DataFrame.droplevel()</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; df = pd.DataFrame([</span>
<span class="sd">        ...     [1, 2, 3, 4],</span>
<span class="sd">        ...     [5, 6, 7, 8],</span>
<span class="sd">        ...     [9, 10, 11, 12]</span>
<span class="sd">        ... ]).set_index([0, 1]).rename_axis([&#39;a&#39;, &#39;b&#39;])</span>

<span class="sd">        &gt;&gt;&gt; df.columns = pd.MultiIndex.from_tuples([</span>
<span class="sd">        ...    (&#39;c&#39;, &#39;e&#39;), (&#39;d&#39;, &#39;f&#39;)</span>
<span class="sd">        ... ], names=[&#39;level_1&#39;, &#39;level_2&#39;])</span>

<span class="sd">        &gt;&gt;&gt; df</span>
<span class="sd">        level_1   c   d</span>
<span class="sd">        level_2   e   f</span>
<span class="sd">        a b</span>
<span class="sd">        1 2      3   4</span>
<span class="sd">        5 6      7   8</span>
<span class="sd">        9 10    11  12</span>

<span class="sd">        &gt;&gt;&gt; df.droplevel(&#39;a&#39;)</span>
<span class="sd">        level_1   c   d</span>
<span class="sd">        level_2   e   f</span>
<span class="sd">        b</span>
<span class="sd">        2        3   4</span>
<span class="sd">        6        7   8</span>
<span class="sd">        10      11  12</span>

<span class="sd">        &gt;&gt;&gt; df.droplevel(&#39;level2&#39;, axis=1)</span>
<span class="sd">        level_1   c   d</span>
<span class="sd">        a b</span>
<span class="sd">        1 2      3   4</span>
<span class="sd">        5 6      7   8</span>
<span class="sd">        9 10    11  12</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">labels</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_axis</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span>
        <span class="n">new_labels</span> <span class="o">=</span> <span class="n">labels</span><span class="o">.</span><span class="n">droplevel</span><span class="p">(</span><span class="n">level</span><span class="p">)</span>
        <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">set_axis</span><span class="p">(</span><span class="n">new_labels</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">result</span>

    <span class="k">def</span> <span class="nf">pop</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">item</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return item and drop from frame. Raise KeyError if not found.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        item : str</span>
<span class="sd">            Label of column to be popped.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Series</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; df = pd.DataFrame([(&#39;falcon&#39;, &#39;bird&#39;, 389.0),</span>
<span class="sd">        ...                    (&#39;parrot&#39;, &#39;bird&#39;, 24.0),</span>
<span class="sd">        ...                    (&#39;lion&#39;, &#39;mammal&#39;, 80.5),</span>
<span class="sd">        ...                    (&#39;monkey&#39;,&#39;mammal&#39;, np.nan)],</span>
<span class="sd">        ...                   columns=(&#39;name&#39;, &#39;class&#39;, &#39;max_speed&#39;))</span>
<span class="sd">        &gt;&gt;&gt; df</span>
<span class="sd">             name   class  max_speed</span>
<span class="sd">        0  falcon    bird      389.0</span>
<span class="sd">        1  parrot    bird       24.0</span>
<span class="sd">        2    lion  mammal       80.5</span>
<span class="sd">        3  monkey  mammal        NaN</span>

<span class="sd">        &gt;&gt;&gt; df.pop(&#39;class&#39;)</span>
<span class="sd">        0      bird</span>
<span class="sd">        1      bird</span>
<span class="sd">        2    mammal</span>
<span class="sd">        3    mammal</span>
<span class="sd">        Name: class, dtype: object</span>

<span class="sd">        &gt;&gt;&gt; df</span>
<span class="sd">             name  max_speed</span>
<span class="sd">        0  falcon      389.0</span>
<span class="sd">        1  parrot       24.0</span>
<span class="sd">        2    lion       80.5</span>
<span class="sd">        3  monkey        NaN</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="n">item</span><span class="p">]</span>
        <span class="k">del</span> <span class="bp">self</span><span class="p">[</span><span class="n">item</span><span class="p">]</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">result</span><span class="o">.</span><span class="n">_reset_cacher</span><span class="p">()</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="k">pass</span>

        <span class="k">return</span> <span class="n">result</span>

    <span class="k">def</span> <span class="nf">squeeze</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Squeeze 1 dimensional axis objects into scalars.</span>

<span class="sd">        Series or DataFrames with a single element are squeezed to a scalar.</span>
<span class="sd">        DataFrames with a single column or a single row are squeezed to a</span>
<span class="sd">        Series. Otherwise the object is unchanged.</span>

<span class="sd">        This method is most useful when you don&#39;t know if your</span>
<span class="sd">        object is a Series or DataFrame, but you do know it has just a single</span>
<span class="sd">        column. In that case you can safely call `squeeze` to ensure you have a</span>
<span class="sd">        Series.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        axis : {0 or &#39;index&#39;, 1 or &#39;columns&#39;, None}, default None</span>
<span class="sd">            A specific axis to squeeze. By default, all length-1 axes are</span>
<span class="sd">            squeezed.</span>

<span class="sd">            .. versionadded:: 0.20.0</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        DataFrame, Series, or scalar</span>
<span class="sd">            The projection after squeezing `axis` or all the axes.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        Series.iloc : Integer-location based indexing for selecting scalars.</span>
<span class="sd">        DataFrame.iloc : Integer-location based indexing for selecting Series.</span>
<span class="sd">        Series.to_frame : Inverse of DataFrame.squeeze for a</span>
<span class="sd">            single-column DataFrame.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; primes = pd.Series([2, 3, 5, 7])</span>

<span class="sd">        Slicing might produce a Series with a single value:</span>

<span class="sd">        &gt;&gt;&gt; even_primes = primes[primes % 2 == 0]</span>
<span class="sd">        &gt;&gt;&gt; even_primes</span>
<span class="sd">        0    2</span>
<span class="sd">        dtype: int64</span>

<span class="sd">        &gt;&gt;&gt; even_primes.squeeze()</span>
<span class="sd">        2</span>

<span class="sd">        Squeezing objects with more than one value in every axis does nothing:</span>

<span class="sd">        &gt;&gt;&gt; odd_primes = primes[primes % 2 == 1]</span>
<span class="sd">        &gt;&gt;&gt; odd_primes</span>
<span class="sd">        1    3</span>
<span class="sd">        2    5</span>
<span class="sd">        3    7</span>
<span class="sd">        dtype: int64</span>

<span class="sd">        &gt;&gt;&gt; odd_primes.squeeze()</span>
<span class="sd">        1    3</span>
<span class="sd">        2    5</span>
<span class="sd">        3    7</span>
<span class="sd">        dtype: int64</span>

<span class="sd">        Squeezing is even more effective when used with DataFrames.</span>

<span class="sd">        &gt;&gt;&gt; df = pd.DataFrame([[1, 2], [3, 4]], columns=[&#39;a&#39;, &#39;b&#39;])</span>
<span class="sd">        &gt;&gt;&gt; df</span>
<span class="sd">           a  b</span>
<span class="sd">        0  1  2</span>
<span class="sd">        1  3  4</span>

<span class="sd">        Slicing a single column will produce a DataFrame with the columns</span>
<span class="sd">        having only one value:</span>

<span class="sd">        &gt;&gt;&gt; df_a = df[[&#39;a&#39;]]</span>
<span class="sd">        &gt;&gt;&gt; df_a</span>
<span class="sd">           a</span>
<span class="sd">        0  1</span>
<span class="sd">        1  3</span>

<span class="sd">        So the columns can be squeezed down, resulting in a Series:</span>

<span class="sd">        &gt;&gt;&gt; df_a.squeeze(&#39;columns&#39;)</span>
<span class="sd">        0    1</span>
<span class="sd">        1    3</span>
<span class="sd">        Name: a, dtype: int64</span>

<span class="sd">        Slicing a single row from a single column will produce a single</span>
<span class="sd">        scalar DataFrame:</span>

<span class="sd">        &gt;&gt;&gt; df_0a = df.loc[df.index &lt; 1, [&#39;a&#39;]]</span>
<span class="sd">        &gt;&gt;&gt; df_0a</span>
<span class="sd">           a</span>
<span class="sd">        0  1</span>

<span class="sd">        Squeezing the rows produces a single scalar Series:</span>

<span class="sd">        &gt;&gt;&gt; df_0a.squeeze(&#39;rows&#39;)</span>
<span class="sd">        a    1</span>
<span class="sd">        Name: 0, dtype: int64</span>

<span class="sd">        Squeezing all axes will project directly into a scalar:</span>

<span class="sd">        &gt;&gt;&gt; df_0a.squeeze()</span>
<span class="sd">        1</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">axis</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_AXIS_NAMES</span> <span class="k">if</span> <span class="n">axis</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_get_axis_number</span><span class="p">(</span><span class="n">axis</span><span class="p">),)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span>
                <span class="nb">tuple</span><span class="p">(</span>
                    <span class="mi">0</span> <span class="k">if</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">axis</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="k">else</span> <span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
                    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">a</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">axes</span><span class="p">)</span>
                <span class="p">)</span>
            <span class="p">]</span>
        <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">swaplevel</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">i</span><span class="o">=-</span><span class="mi">2</span><span class="p">,</span> <span class="n">j</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Swap levels i and j in a MultiIndex on a particular axis</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        i, j : int, str (can be mixed)</span>
<span class="sd">            Level of index to be swapped. Can pass level name as string.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        swapped : same type as caller (new object)</span>

<span class="sd">        .. versionchanged:: 0.18.1</span>

<span class="sd">           The indexes ``i`` and ``j`` are now optional, and default to</span>
<span class="sd">           the two innermost levels of the index.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">axis</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_axis_number</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span>
        <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">labels</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">axes</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span>
        <span class="n">result</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">set_axis</span><span class="p">(</span><span class="n">axis</span><span class="p">,</span> <span class="n">labels</span><span class="o">.</span><span class="n">swaplevel</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">result</span>

    <span class="c1"># ----------------------------------------------------------------------</span>
    <span class="c1"># Rename</span>

    <span class="k">def</span> <span class="nf">rename</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Alter axes input function or functions. Function / dict values must be</span>
<span class="sd">        unique (1-to-1). Labels not contained in a dict / Series will be left</span>
<span class="sd">        as-is. Extra labels listed don&#39;t throw an error. Alternatively, change</span>
<span class="sd">        ``Series.name`` with a scalar value (Series only).</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        %(axes)s : scalar, list-like, dict-like or function, optional</span>
<span class="sd">            Scalar or list-like will alter the ``Series.name`` attribute,</span>
<span class="sd">            and raise on DataFrame.</span>
<span class="sd">            dict-like or functions are transformations to apply to</span>
<span class="sd">            that axis&#39; values</span>
<span class="sd">        copy : bool, default True</span>
<span class="sd">            Also copy underlying data.</span>
<span class="sd">        inplace : bool, default False</span>
<span class="sd">            Whether to return a new %(klass)s. If True then value of copy is</span>
<span class="sd">            ignored.</span>
<span class="sd">        level : int or level name, default None</span>
<span class="sd">            In case of a MultiIndex, only rename labels in the specified</span>
<span class="sd">            level.</span>
<span class="sd">        errors : {&#39;ignore&#39;, &#39;raise&#39;}, default &#39;ignore&#39;</span>
<span class="sd">            If &#39;raise&#39;, raise a `KeyError` when a dict-like `mapper`, `index`,</span>
<span class="sd">            or `columns` contains labels that are not present in the Index</span>
<span class="sd">            being transformed.</span>
<span class="sd">            If &#39;ignore&#39;, existing keys will be renamed and extra keys will be</span>
<span class="sd">            ignored.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        renamed : %(klass)s (new object)</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        KeyError</span>
<span class="sd">            If any of the labels is not found in the selected axis and</span>
<span class="sd">            &quot;errors=&#39;raise&#39;&quot;.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        NDFrame.rename_axis</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>

<span class="sd">        &gt;&gt;&gt; s = pd.Series([1, 2, 3])</span>
<span class="sd">        &gt;&gt;&gt; s</span>
<span class="sd">        0    1</span>
<span class="sd">        1    2</span>
<span class="sd">        2    3</span>
<span class="sd">        dtype: int64</span>
<span class="sd">        &gt;&gt;&gt; s.rename(&quot;my_name&quot;) # scalar, changes Series.name</span>
<span class="sd">        0    1</span>
<span class="sd">        1    2</span>
<span class="sd">        2    3</span>
<span class="sd">        Name: my_name, dtype: int64</span>
<span class="sd">        &gt;&gt;&gt; s.rename(lambda x: x ** 2)  # function, changes labels</span>
<span class="sd">        0    1</span>
<span class="sd">        1    2</span>
<span class="sd">        4    3</span>
<span class="sd">        dtype: int64</span>
<span class="sd">        &gt;&gt;&gt; s.rename({1: 3, 2: 5})  # mapping, changes labels</span>
<span class="sd">        0    1</span>
<span class="sd">        3    2</span>
<span class="sd">        5    3</span>
<span class="sd">        dtype: int64</span>

<span class="sd">        Since ``DataFrame`` doesn&#39;t have a ``.name`` attribute,</span>
<span class="sd">        only mapping-type arguments are allowed.</span>

<span class="sd">        &gt;&gt;&gt; df = pd.DataFrame({&quot;A&quot;: [1, 2, 3], &quot;B&quot;: [4, 5, 6]})</span>
<span class="sd">        &gt;&gt;&gt; df.rename(2)</span>
<span class="sd">        Traceback (most recent call last):</span>
<span class="sd">        ...</span>
<span class="sd">        TypeError: &#39;int&#39; object is not callable</span>

<span class="sd">        ``DataFrame.rename`` supports two calling conventions</span>

<span class="sd">        * ``(index=index_mapper, columns=columns_mapper, ...)``</span>
<span class="sd">        * ``(mapper, axis={&#39;index&#39;, &#39;columns&#39;}, ...)``</span>

<span class="sd">        We *highly* recommend using keyword arguments to clarify your</span>
<span class="sd">        intent.</span>

<span class="sd">        &gt;&gt;&gt; df.rename(index=str, columns={&quot;A&quot;: &quot;a&quot;, &quot;B&quot;: &quot;c&quot;})</span>
<span class="sd">           a  c</span>
<span class="sd">        0  1  4</span>
<span class="sd">        1  2  5</span>
<span class="sd">        2  3  6</span>

<span class="sd">        &gt;&gt;&gt; df.rename(index=str, columns={&quot;A&quot;: &quot;a&quot;, &quot;C&quot;: &quot;c&quot;})</span>
<span class="sd">           a  B</span>
<span class="sd">        0  1  4</span>
<span class="sd">        1  2  5</span>
<span class="sd">        2  3  6</span>

<span class="sd">        Using axis-style parameters</span>

<span class="sd">        &gt;&gt;&gt; df.rename(str.lower, axis=&#39;columns&#39;)</span>
<span class="sd">           a  b</span>
<span class="sd">        0  1  4</span>
<span class="sd">        1  2  5</span>
<span class="sd">        2  3  6</span>

<span class="sd">        &gt;&gt;&gt; df.rename({1: 2, 2: 4}, axis=&#39;index&#39;)</span>
<span class="sd">           A  B</span>
<span class="sd">        0  1  4</span>
<span class="sd">        2  2  5</span>
<span class="sd">        4  3  6</span>

<span class="sd">        See the :ref:`user guide &lt;basics.rename&gt;` for more.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">axes</span><span class="p">,</span> <span class="n">kwargs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_construct_axes_from_arguments</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">)</span>
        <span class="n">copy</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;copy&quot;</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
        <span class="n">inplace</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;inplace&quot;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
        <span class="n">level</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;level&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="n">axis</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;axis&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="n">errors</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;errors&quot;</span><span class="p">,</span> <span class="s2">&quot;ignore&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">axis</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># Validate the axis</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_get_axis_number</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">kwargs</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                <span class="s2">&quot;rename() got an unexpected keyword &quot;</span>
                <span class="s1">&#39;argument &quot;</span><span class="si">{0}</span><span class="s1">&quot;&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">kwargs</span><span class="o">.</span><span class="n">keys</span><span class="p">())[</span><span class="mi">0</span><span class="p">])</span>
            <span class="p">)</span>

        <span class="k">if</span> <span class="n">com</span><span class="o">.</span><span class="n">count_not_none</span><span class="p">(</span><span class="o">*</span><span class="n">axes</span><span class="o">.</span><span class="n">values</span><span class="p">())</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;must pass an index to rename&quot;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_consolidate_inplace</span><span class="p">()</span>
        <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span> <span class="k">if</span> <span class="n">inplace</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">deep</span><span class="o">=</span><span class="n">copy</span><span class="p">)</span>

        <span class="c1"># start in the axis order to eliminate too many copies</span>
        <span class="k">for</span> <span class="n">axis</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_AXIS_LEN</span><span class="p">):</span>
            <span class="n">v</span> <span class="o">=</span> <span class="n">axes</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_AXIS_NAMES</span><span class="p">[</span><span class="n">axis</span><span class="p">])</span>
            <span class="k">if</span> <span class="n">v</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="n">f</span> <span class="o">=</span> <span class="n">com</span><span class="o">.</span><span class="n">_get_rename_function</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
            <span class="n">baxis</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_block_manager_axis</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">level</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">level</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">axes</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span><span class="o">.</span><span class="n">_get_level_number</span><span class="p">(</span><span class="n">level</span><span class="p">)</span>

            <span class="c1"># GH 13473</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">callable</span><span class="p">(</span><span class="n">v</span><span class="p">):</span>
                <span class="n">indexer</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">axes</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span><span class="o">.</span><span class="n">get_indexer_for</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">errors</span> <span class="o">==</span> <span class="s2">&quot;raise&quot;</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">indexer</span><span class="p">[</span><span class="n">indexer</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">]):</span>
                    <span class="n">missing_labels</span> <span class="o">=</span> <span class="p">[</span>
                        <span class="n">label</span> <span class="k">for</span> <span class="n">index</span><span class="p">,</span> <span class="n">label</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="k">if</span> <span class="n">indexer</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span>
                    <span class="p">]</span>
                    <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">{}</span><span class="s2"> not found in axis&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">missing_labels</span><span class="p">))</span>

            <span class="n">result</span><span class="o">.</span><span class="n">_data</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">rename_axis</span><span class="p">(</span>
                <span class="n">f</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">baxis</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="n">copy</span><span class="p">,</span> <span class="n">level</span><span class="o">=</span><span class="n">level</span>
            <span class="p">)</span>
            <span class="n">result</span><span class="o">.</span><span class="n">_clear_item_cache</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">inplace</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_update_inplace</span><span class="p">(</span><span class="n">result</span><span class="o">.</span><span class="n">_data</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">result</span><span class="o">.</span><span class="n">__finalize__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="nd">@rewrite_axis_style_signature</span><span class="p">(</span><span class="s2">&quot;mapper&quot;</span><span class="p">,</span> <span class="p">[(</span><span class="s2">&quot;copy&quot;</span><span class="p">,</span> <span class="kc">True</span><span class="p">),</span> <span class="p">(</span><span class="s2">&quot;inplace&quot;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)])</span>
    <span class="k">def</span> <span class="nf">rename_axis</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mapper</span><span class="o">=</span><span class="n">sentinel</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set the name of the axis for the index or columns.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        mapper : scalar, list-like, optional</span>
<span class="sd">            Value to set the axis name attribute.</span>
<span class="sd">        index, columns : scalar, list-like, dict-like or function, optional</span>
<span class="sd">            A scalar, list-like, dict-like or functions transformations to</span>
<span class="sd">            apply to that axis&#39; values.</span>

<span class="sd">            Use either ``mapper`` and ``axis`` to</span>
<span class="sd">            specify the axis to target with ``mapper``, or ``index``</span>
<span class="sd">            and/or ``columns``.</span>

<span class="sd">            .. versionchanged:: 0.24.0</span>

<span class="sd">        axis : {0 or &#39;index&#39;, 1 or &#39;columns&#39;}, default 0</span>
<span class="sd">            The axis to rename.</span>
<span class="sd">        copy : bool, default True</span>
<span class="sd">            Also copy underlying data.</span>
<span class="sd">        inplace : bool, default False</span>
<span class="sd">            Modifies the object directly, instead of creating a new Series</span>
<span class="sd">            or DataFrame.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Series, DataFrame, or None</span>
<span class="sd">            The same type as the caller or None if `inplace` is True.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        Series.rename : Alter Series index labels or name.</span>
<span class="sd">        DataFrame.rename : Alter DataFrame index labels or name.</span>
<span class="sd">        Index.rename : Set new names on index.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        ``DataFrame.rename_axis`` supports two calling conventions</span>

<span class="sd">        * ``(index=index_mapper, columns=columns_mapper, ...)``</span>
<span class="sd">        * ``(mapper, axis={&#39;index&#39;, &#39;columns&#39;}, ...)``</span>

<span class="sd">        The first calling convention will only modify the names of</span>
<span class="sd">        the index and/or the names of the Index object that is the columns.</span>
<span class="sd">        In this case, the parameter ``copy`` is ignored.</span>

<span class="sd">        The second calling convention will modify the names of the</span>
<span class="sd">        the corresponding index if mapper is a list or a scalar.</span>
<span class="sd">        However, if mapper is dict-like or a function, it will use the</span>
<span class="sd">        deprecated behavior of modifying the axis *labels*.</span>

<span class="sd">        We *highly* recommend using keyword arguments to clarify your</span>
<span class="sd">        intent.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        **Series**</span>

<span class="sd">        &gt;&gt;&gt; s = pd.Series([&quot;dog&quot;, &quot;cat&quot;, &quot;monkey&quot;])</span>
<span class="sd">        &gt;&gt;&gt; s</span>
<span class="sd">        0       dog</span>
<span class="sd">        1       cat</span>
<span class="sd">        2    monkey</span>
<span class="sd">        dtype: object</span>
<span class="sd">        &gt;&gt;&gt; s.rename_axis(&quot;animal&quot;)</span>
<span class="sd">        animal</span>
<span class="sd">        0    dog</span>
<span class="sd">        1    cat</span>
<span class="sd">        2    monkey</span>
<span class="sd">        dtype: object</span>

<span class="sd">        **DataFrame**</span>

<span class="sd">        &gt;&gt;&gt; df = pd.DataFrame({&quot;num_legs&quot;: [4, 4, 2],</span>
<span class="sd">        ...                    &quot;num_arms&quot;: [0, 0, 2]},</span>
<span class="sd">        ...                   [&quot;dog&quot;, &quot;cat&quot;, &quot;monkey&quot;])</span>
<span class="sd">        &gt;&gt;&gt; df</span>
<span class="sd">                num_legs  num_arms</span>
<span class="sd">        dog            4         0</span>
<span class="sd">        cat            4         0</span>
<span class="sd">        monkey         2         2</span>
<span class="sd">        &gt;&gt;&gt; df = df.rename_axis(&quot;animal&quot;)</span>
<span class="sd">        &gt;&gt;&gt; df</span>
<span class="sd">                num_legs  num_arms</span>
<span class="sd">        animal</span>
<span class="sd">        dog            4         0</span>
<span class="sd">        cat            4         0</span>
<span class="sd">        monkey         2         2</span>
<span class="sd">        &gt;&gt;&gt; df = df.rename_axis(&quot;limbs&quot;, axis=&quot;columns&quot;)</span>
<span class="sd">        &gt;&gt;&gt; df</span>
<span class="sd">        limbs   num_legs  num_arms</span>
<span class="sd">        animal</span>
<span class="sd">        dog            4         0</span>
<span class="sd">        cat            4         0</span>
<span class="sd">        monkey         2         2</span>

<span class="sd">        **MultiIndex**</span>

<span class="sd">        &gt;&gt;&gt; df.index = pd.MultiIndex.from_product([[&#39;mammal&#39;],</span>
<span class="sd">        ...                                        [&#39;dog&#39;, &#39;cat&#39;, &#39;monkey&#39;]],</span>
<span class="sd">        ...                                       names=[&#39;type&#39;, &#39;name&#39;])</span>
<span class="sd">        &gt;&gt;&gt; df</span>
<span class="sd">        limbs          num_legs  num_arms</span>
<span class="sd">        type   name</span>
<span class="sd">        mammal dog            4         0</span>
<span class="sd">               cat            4         0</span>
<span class="sd">               monkey         2         2</span>

<span class="sd">        &gt;&gt;&gt; df.rename_axis(index={&#39;type&#39;: &#39;class&#39;})</span>
<span class="sd">        limbs          num_legs  num_arms</span>
<span class="sd">        class  name</span>
<span class="sd">        mammal dog            4         0</span>
<span class="sd">               cat            4         0</span>
<span class="sd">               monkey         2         2</span>

<span class="sd">        &gt;&gt;&gt; df.rename_axis(columns=str.upper)</span>
<span class="sd">        LIMBS          num_legs  num_arms</span>
<span class="sd">        type   name</span>
<span class="sd">        mammal dog            4         0</span>
<span class="sd">               cat            4         0</span>
<span class="sd">               monkey         2         2</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">axes</span><span class="p">,</span> <span class="n">kwargs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_construct_axes_from_arguments</span><span class="p">(</span>
            <span class="p">(),</span> <span class="n">kwargs</span><span class="p">,</span> <span class="n">sentinel</span><span class="o">=</span><span class="n">sentinel</span>
        <span class="p">)</span>
        <span class="n">copy</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;copy&quot;</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
        <span class="n">inplace</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;inplace&quot;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
        <span class="n">axis</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;axis&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">axis</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">axis</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_axis_number</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">kwargs</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                <span class="s2">&quot;rename_axis() got an unexpected keyword &quot;</span>
                <span class="s1">&#39;argument &quot;</span><span class="si">{0}</span><span class="s1">&quot;&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">kwargs</span><span class="o">.</span><span class="n">keys</span><span class="p">())[</span><span class="mi">0</span><span class="p">])</span>
            <span class="p">)</span>

        <span class="n">inplace</span> <span class="o">=</span> <span class="n">validate_bool_kwarg</span><span class="p">(</span><span class="n">inplace</span><span class="p">,</span> <span class="s2">&quot;inplace&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">mapper</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">sentinel</span><span class="p">:</span>
            <span class="c1"># Use v0.23 behavior if a scalar or list</span>
            <span class="n">non_mapper</span> <span class="o">=</span> <span class="n">is_scalar</span><span class="p">(</span><span class="n">mapper</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span>
                <span class="n">is_list_like</span><span class="p">(</span><span class="n">mapper</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">is_dict_like</span><span class="p">(</span><span class="n">mapper</span><span class="p">)</span>
            <span class="p">)</span>
            <span class="k">if</span> <span class="n">non_mapper</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_set_axis_name</span><span class="p">(</span><span class="n">mapper</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="n">inplace</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Use `.rename` to alter labels &quot;</span> <span class="s2">&quot;with a mapper.&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Use new behavior.  Means that index and/or columns</span>
            <span class="c1"># is specified</span>
            <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span> <span class="k">if</span> <span class="n">inplace</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">deep</span><span class="o">=</span><span class="n">copy</span><span class="p">)</span>

            <span class="k">for</span> <span class="n">axis</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_AXIS_LEN</span><span class="p">):</span>
                <span class="n">v</span> <span class="o">=</span> <span class="n">axes</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_AXIS_NAMES</span><span class="p">[</span><span class="n">axis</span><span class="p">])</span>
                <span class="k">if</span> <span class="n">v</span> <span class="ow">is</span> <span class="n">sentinel</span><span class="p">:</span>
                    <span class="k">continue</span>
                <span class="n">non_mapper</span> <span class="o">=</span> <span class="n">is_scalar</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">is_list_like</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">is_dict_like</span><span class="p">(</span><span class="n">v</span><span class="p">))</span>
                <span class="k">if</span> <span class="n">non_mapper</span><span class="p">:</span>
                    <span class="n">newnames</span> <span class="o">=</span> <span class="n">v</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">f</span> <span class="o">=</span> <span class="n">com</span><span class="o">.</span><span class="n">_get_rename_function</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
                    <span class="n">curnames</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_axis</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span><span class="o">.</span><span class="n">names</span>
                    <span class="n">newnames</span> <span class="o">=</span> <span class="p">[</span><span class="n">f</span><span class="p">(</span><span class="n">name</span><span class="p">)</span> <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">curnames</span><span class="p">]</span>
                <span class="n">result</span><span class="o">.</span><span class="n">_set_axis_name</span><span class="p">(</span><span class="n">newnames</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">inplace</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">result</span>

    <span class="k">def</span> <span class="nf">_set_axis_name</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set the name(s) of the axis.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        name : str or list of str</span>
<span class="sd">            Name(s) to set.</span>
<span class="sd">        axis : {0 or &#39;index&#39;, 1 or &#39;columns&#39;}, default 0</span>
<span class="sd">            The axis to set the label. The value 0 or &#39;index&#39; specifies index,</span>
<span class="sd">            and the value 1 or &#39;columns&#39; specifies columns.</span>
<span class="sd">        inplace : bool, default False</span>
<span class="sd">            If `True`, do operation inplace and return None.</span>

<span class="sd">            .. versionadded:: 0.21.0</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Series, DataFrame, or None</span>
<span class="sd">            The same type as the caller or `None` if `inplace` is `True`.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        DataFrame.rename : Alter the axis labels of :class:`DataFrame`.</span>
<span class="sd">        Series.rename : Alter the index labels or set the index name</span>
<span class="sd">            of :class:`Series`.</span>
<span class="sd">        Index.rename : Set the name of :class:`Index` or :class:`MultiIndex`.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; df = pd.DataFrame({&quot;num_legs&quot;: [4, 4, 2]},</span>
<span class="sd">        ...                   [&quot;dog&quot;, &quot;cat&quot;, &quot;monkey&quot;])</span>
<span class="sd">        &gt;&gt;&gt; df</span>
<span class="sd">                num_legs</span>
<span class="sd">        dog            4</span>
<span class="sd">        cat            4</span>
<span class="sd">        monkey         2</span>
<span class="sd">        &gt;&gt;&gt; df._set_axis_name(&quot;animal&quot;)</span>
<span class="sd">                num_legs</span>
<span class="sd">        animal</span>
<span class="sd">        dog            4</span>
<span class="sd">        cat            4</span>
<span class="sd">        monkey         2</span>
<span class="sd">        &gt;&gt;&gt; df.index = pd.MultiIndex.from_product(</span>
<span class="sd">        ...                [[&quot;mammal&quot;], [&#39;dog&#39;, &#39;cat&#39;, &#39;monkey&#39;]])</span>
<span class="sd">        &gt;&gt;&gt; df._set_axis_name([&quot;type&quot;, &quot;name&quot;])</span>
<span class="sd">                       legs</span>
<span class="sd">        type   name</span>
<span class="sd">        mammal dog        4</span>
<span class="sd">               cat        4</span>
<span class="sd">               monkey     2</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">axis</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_axis_number</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span>
        <span class="n">idx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_axis</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span><span class="o">.</span><span class="n">set_names</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>

        <span class="n">inplace</span> <span class="o">=</span> <span class="n">validate_bool_kwarg</span><span class="p">(</span><span class="n">inplace</span><span class="p">,</span> <span class="s2">&quot;inplace&quot;</span><span class="p">)</span>
        <span class="n">renamed</span> <span class="o">=</span> <span class="bp">self</span> <span class="k">if</span> <span class="n">inplace</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">renamed</span><span class="o">.</span><span class="n">set_axis</span><span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">inplace</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">renamed</span>

    <span class="c1"># ----------------------------------------------------------------------</span>
    <span class="c1"># Comparison Methods</span>

    <span class="k">def</span> <span class="nf">_indexed_same</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">all</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_get_axis</span><span class="p">(</span><span class="n">a</span><span class="p">)</span><span class="o">.</span><span class="n">equals</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">_get_axis</span><span class="p">(</span><span class="n">a</span><span class="p">))</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_AXIS_ORDERS</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">equals</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Test whether two objects contain the same elements.</span>

<span class="sd">        This function allows two Series or DataFrames to be compared against</span>
<span class="sd">        each other to see if they have the same shape and elements. NaNs in</span>
<span class="sd">        the same location are considered equal. The column headers do not</span>
<span class="sd">        need to have the same type, but the elements within the columns must</span>
<span class="sd">        be the same dtype.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        other : Series or DataFrame</span>
<span class="sd">            The other Series or DataFrame to be compared with the first.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        bool</span>
<span class="sd">            True if all elements are the same in both objects, False</span>
<span class="sd">            otherwise.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        Series.eq : Compare two Series objects of the same length</span>
<span class="sd">            and return a Series where each element is True if the element</span>
<span class="sd">            in each Series is equal, False otherwise.</span>
<span class="sd">        DataFrame.eq : Compare two DataFrame objects of the same shape and</span>
<span class="sd">            return a DataFrame where each element is True if the respective</span>
<span class="sd">            element in each DataFrame is equal, False otherwise.</span>
<span class="sd">        assert_series_equal : Return True if left and right Series are equal,</span>
<span class="sd">            False otherwise.</span>
<span class="sd">        assert_frame_equal : Return True if left and right DataFrames are</span>
<span class="sd">            equal, False otherwise.</span>
<span class="sd">        numpy.array_equal : Return True if two arrays have the same shape</span>
<span class="sd">            and elements, False otherwise.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        This function requires that the elements have the same dtype as their</span>
<span class="sd">        respective elements in the other Series or DataFrame. However, the</span>
<span class="sd">        column labels do not need to have the same type, as long as they are</span>
<span class="sd">        still considered equal.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; df = pd.DataFrame({1: [10], 2: [20]})</span>
<span class="sd">        &gt;&gt;&gt; df</span>
<span class="sd">            1   2</span>
<span class="sd">        0  10  20</span>

<span class="sd">        DataFrames df and exactly_equal have the same types and values for</span>
<span class="sd">        their elements and column labels, which will return True.</span>

<span class="sd">        &gt;&gt;&gt; exactly_equal = pd.DataFrame({1: [10], 2: [20]})</span>
<span class="sd">        &gt;&gt;&gt; exactly_equal</span>
<span class="sd">            1   2</span>
<span class="sd">        0  10  20</span>
<span class="sd">        &gt;&gt;&gt; df.equals(exactly_equal)</span>
<span class="sd">        True</span>

<span class="sd">        DataFrames df and different_column_type have the same element</span>
<span class="sd">        types and values, but have different types for the column labels,</span>
<span class="sd">        which will still return True.</span>

<span class="sd">        &gt;&gt;&gt; different_column_type = pd.DataFrame({1.0: [10], 2.0: [20]})</span>
<span class="sd">        &gt;&gt;&gt; different_column_type</span>
<span class="sd">           1.0  2.0</span>
<span class="sd">        0   10   20</span>
<span class="sd">        &gt;&gt;&gt; df.equals(different_column_type)</span>
<span class="sd">        True</span>

<span class="sd">        DataFrames df and different_data_type have different types for the</span>
<span class="sd">        same values for their elements, and will return False even though</span>
<span class="sd">        their column labels are the same values and types.</span>

<span class="sd">        &gt;&gt;&gt; different_data_type = pd.DataFrame({1: [10.0], 2: [20.0]})</span>
<span class="sd">        &gt;&gt;&gt; different_data_type</span>
<span class="sd">              1     2</span>
<span class="sd">        0  10.0  20.0</span>
<span class="sd">        &gt;&gt;&gt; df.equals(different_data_type)</span>
<span class="sd">        False</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_constructor</span><span class="p">):</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">equals</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">_data</span><span class="p">)</span>

    <span class="c1"># -------------------------------------------------------------------------</span>
    <span class="c1"># Unary Methods</span>

    <span class="k">def</span> <span class="nf">__neg__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">values</span> <span class="o">=</span> <span class="n">com</span><span class="o">.</span><span class="n">values_from_object</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">is_bool_dtype</span><span class="p">(</span><span class="n">values</span><span class="p">):</span>
            <span class="n">arr</span> <span class="o">=</span> <span class="n">operator</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="n">values</span><span class="p">)</span>
        <span class="k">elif</span> <span class="p">(</span>
            <span class="n">is_numeric_dtype</span><span class="p">(</span><span class="n">values</span><span class="p">)</span>
            <span class="ow">or</span> <span class="n">is_timedelta64_dtype</span><span class="p">(</span><span class="n">values</span><span class="p">)</span>
            <span class="ow">or</span> <span class="n">is_object_dtype</span><span class="p">(</span><span class="n">values</span><span class="p">)</span>
        <span class="p">):</span>
            <span class="n">arr</span> <span class="o">=</span> <span class="n">operator</span><span class="o">.</span><span class="n">neg</span><span class="p">(</span><span class="n">values</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                <span class="s2">&quot;Unary negative expects numeric dtype, not </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">values</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
            <span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__array_wrap__</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__pos__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">values</span> <span class="o">=</span> <span class="n">com</span><span class="o">.</span><span class="n">values_from_object</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">is_bool_dtype</span><span class="p">(</span><span class="n">values</span><span class="p">)</span> <span class="ow">or</span> <span class="n">is_period_arraylike</span><span class="p">(</span><span class="n">values</span><span class="p">):</span>
            <span class="n">arr</span> <span class="o">=</span> <span class="n">values</span>
        <span class="k">elif</span> <span class="p">(</span>
            <span class="n">is_numeric_dtype</span><span class="p">(</span><span class="n">values</span><span class="p">)</span>
            <span class="ow">or</span> <span class="n">is_timedelta64_dtype</span><span class="p">(</span><span class="n">values</span><span class="p">)</span>
            <span class="ow">or</span> <span class="n">is_object_dtype</span><span class="p">(</span><span class="n">values</span><span class="p">)</span>
        <span class="p">):</span>
            <span class="n">arr</span> <span class="o">=</span> <span class="n">operator</span><span class="o">.</span><span class="n">pos</span><span class="p">(</span><span class="n">values</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                <span class="s2">&quot;Unary plus expects numeric dtype, not </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">values</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
            <span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__array_wrap__</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__invert__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">arr</span> <span class="o">=</span> <span class="n">operator</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="n">com</span><span class="o">.</span><span class="n">values_from_object</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__array_wrap__</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>

            <span class="c1"># inv fails with 0 len</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">):</span>
                <span class="k">return</span> <span class="bp">self</span>

            <span class="k">raise</span>

    <span class="k">def</span> <span class="nf">__nonzero__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="s2">&quot;The truth value of a </span><span class="si">{0}</span><span class="s2"> is ambiguous. &quot;</span>
            <span class="s2">&quot;Use a.empty, a.bool(), a.item(), a.any() or a.all().&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span>
            <span class="p">)</span>
        <span class="p">)</span>

    <span class="fm">__bool__</span> <span class="o">=</span> <span class="n">__nonzero__</span>

    <span class="k">def</span> <span class="nf">bool</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the bool of a single element PandasObject.</span>

<span class="sd">        This must be a boolean scalar value, either True or False.  Raise a</span>
<span class="sd">        ValueError if the PandasObject does not have exactly 1 element, or that</span>
<span class="sd">        element is not boolean</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        bool</span>
<span class="sd">            Same single boolean value converted to bool type.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">v</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="p">(</span><span class="nb">bool</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">bool_</span><span class="p">)):</span>
            <span class="k">return</span> <span class="nb">bool</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">is_scalar</span><span class="p">(</span><span class="n">v</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;bool cannot act on a non-boolean single element &quot;</span>
                <span class="s2">&quot;</span><span class="si">{0}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">)</span>
            <span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">__nonzero__</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">__abs__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">abs</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">__round__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">decimals</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">decimals</span><span class="p">)</span>

    <span class="c1"># -------------------------------------------------------------------------</span>
    <span class="c1"># Label or Level Combination Helpers</span>
    <span class="c1">#</span>
    <span class="c1"># A collection of helper methods for DataFrame/Series operations that</span>
    <span class="c1"># accept a combination of column/index labels and levels.  All such</span>
    <span class="c1"># operations should utilize/extend these methods when possible so that we</span>
    <span class="c1"># have consistent precedence and validation logic throughout the library.</span>

    <span class="k">def</span> <span class="nf">_is_level_reference</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Test whether a key is a level reference for a given axis.</span>

<span class="sd">        To be considered a level reference, `key` must be a string that:</span>
<span class="sd">          - (axis=0): Matches the name of an index level and does NOT match</span>
<span class="sd">            a column label.</span>
<span class="sd">          - (axis=1): Matches the name of a column level and does NOT match</span>
<span class="sd">            an index label.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        key : str</span>
<span class="sd">            Potential level name for the given axis</span>
<span class="sd">        axis : int, default 0</span>
<span class="sd">            Axis that levels are associated with (0 for index, 1 for columns)</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        is_level : bool</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">axis</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_axis_number</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span>

        <span class="k">return</span> <span class="p">(</span>
            <span class="n">key</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
            <span class="ow">and</span> <span class="n">is_hashable</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
            <span class="ow">and</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">axes</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span><span class="o">.</span><span class="n">names</span>
            <span class="ow">and</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_label_reference</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">_is_label_reference</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Test whether a key is a label reference for a given axis.</span>

<span class="sd">        To be considered a label reference, `key` must be a string that:</span>
<span class="sd">          - (axis=0): Matches a column label</span>
<span class="sd">          - (axis=1): Matches an index label</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        key: str</span>
<span class="sd">            Potential label name</span>
<span class="sd">        axis: int, default 0</span>
<span class="sd">            Axis perpendicular to the axis that labels are associated with</span>
<span class="sd">            (0 means search for column labels, 1 means search for index labels)</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        is_label: bool</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">axis</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_axis_number</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span>
        <span class="n">other_axes</span> <span class="o">=</span> <span class="p">(</span><span class="n">ax</span> <span class="k">for</span> <span class="n">ax</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_AXIS_LEN</span><span class="p">)</span> <span class="k">if</span> <span class="n">ax</span> <span class="o">!=</span> <span class="n">axis</span><span class="p">)</span>

        <span class="k">return</span> <span class="p">(</span>
            <span class="n">key</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
            <span class="ow">and</span> <span class="n">is_hashable</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
            <span class="ow">and</span> <span class="nb">any</span><span class="p">(</span><span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">axes</span><span class="p">[</span><span class="n">ax</span><span class="p">]</span> <span class="k">for</span> <span class="n">ax</span> <span class="ow">in</span> <span class="n">other_axes</span><span class="p">)</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">_is_label_or_level_reference</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Test whether a key is a label or level reference for a given axis.</span>

<span class="sd">        To be considered either a label or a level reference, `key` must be a</span>
<span class="sd">        string that:</span>
<span class="sd">          - (axis=0): Matches a column label or an index level</span>
<span class="sd">          - (axis=1): Matches an index label or a column level</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        key: str</span>
<span class="sd">            Potential label or level name</span>
<span class="sd">        axis: int, default 0</span>
<span class="sd">            Axis that levels are associated with (0 for index, 1 for columns)</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        is_label_or_level: bool</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_level_reference</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_label_reference</span><span class="p">(</span>
            <span class="n">key</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">_check_label_or_level_ambiguity</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Check whether `key` is ambiguous.</span>

<span class="sd">        By ambiguous, we mean that it matches both a level of the input</span>
<span class="sd">        `axis` and a label of the other axis.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        key: str or object</span>
<span class="sd">            label or level name</span>
<span class="sd">        axis: int, default 0</span>
<span class="sd">            Axis that levels are associated with (0 for index, 1 for columns)</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        ValueError: `key` is ambiguous</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">axis</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_axis_number</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span>
        <span class="n">other_axes</span> <span class="o">=</span> <span class="p">(</span><span class="n">ax</span> <span class="k">for</span> <span class="n">ax</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_AXIS_LEN</span><span class="p">)</span> <span class="k">if</span> <span class="n">ax</span> <span class="o">!=</span> <span class="n">axis</span><span class="p">)</span>

        <span class="k">if</span> <span class="p">(</span>
            <span class="n">key</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
            <span class="ow">and</span> <span class="n">is_hashable</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
            <span class="ow">and</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">axes</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span><span class="o">.</span><span class="n">names</span>
            <span class="ow">and</span> <span class="nb">any</span><span class="p">(</span><span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">axes</span><span class="p">[</span><span class="n">ax</span><span class="p">]</span> <span class="k">for</span> <span class="n">ax</span> <span class="ow">in</span> <span class="n">other_axes</span><span class="p">)</span>
        <span class="p">):</span>

            <span class="c1"># Build an informative and grammatical warning</span>
            <span class="n">level_article</span><span class="p">,</span> <span class="n">level_type</span> <span class="o">=</span> <span class="p">(</span>
                <span class="p">(</span><span class="s2">&quot;an&quot;</span><span class="p">,</span> <span class="s2">&quot;index&quot;</span><span class="p">)</span> <span class="k">if</span> <span class="n">axis</span> <span class="o">==</span> <span class="mi">0</span> <span class="k">else</span> <span class="p">(</span><span class="s2">&quot;a&quot;</span><span class="p">,</span> <span class="s2">&quot;column&quot;</span><span class="p">)</span>
            <span class="p">)</span>

            <span class="n">label_article</span><span class="p">,</span> <span class="n">label_type</span> <span class="o">=</span> <span class="p">(</span>
                <span class="p">(</span><span class="s2">&quot;a&quot;</span><span class="p">,</span> <span class="s2">&quot;column&quot;</span><span class="p">)</span> <span class="k">if</span> <span class="n">axis</span> <span class="o">==</span> <span class="mi">0</span> <span class="k">else</span> <span class="p">(</span><span class="s2">&quot;an&quot;</span><span class="p">,</span> <span class="s2">&quot;index&quot;</span><span class="p">)</span>
            <span class="p">)</span>

            <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span>
                <span class="s2">&quot;&#39;</span><span class="si">{key}</span><span class="s2">&#39; is both </span><span class="si">{level_article}</span><span class="s2"> </span><span class="si">{level_type}</span><span class="s2"> level and &quot;</span>
                <span class="s2">&quot;</span><span class="si">{label_article}</span><span class="s2"> </span><span class="si">{label_type}</span><span class="s2"> label, which is ambiguous.&quot;</span>
            <span class="p">)</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                <span class="n">key</span><span class="o">=</span><span class="n">key</span><span class="p">,</span>
                <span class="n">level_article</span><span class="o">=</span><span class="n">level_article</span><span class="p">,</span>
                <span class="n">level_type</span><span class="o">=</span><span class="n">level_type</span><span class="p">,</span>
                <span class="n">label_article</span><span class="o">=</span><span class="n">label_article</span><span class="p">,</span>
                <span class="n">label_type</span><span class="o">=</span><span class="n">label_type</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_get_label_or_level_values</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a 1-D array of values associated with `key`, a label or level</span>
<span class="sd">        from the given `axis`.</span>

<span class="sd">        Retrieval logic:</span>
<span class="sd">          - (axis=0): Return column values if `key` matches a column label.</span>
<span class="sd">            Otherwise return index level values if `key` matches an index</span>
<span class="sd">            level.</span>
<span class="sd">          - (axis=1): Return row values if `key` matches an index label.</span>
<span class="sd">            Otherwise return column level values if &#39;key&#39; matches a column</span>
<span class="sd">            level</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        key: str</span>
<span class="sd">            Label or level name.</span>
<span class="sd">        axis: int, default 0</span>
<span class="sd">            Axis that levels are associated with (0 for index, 1 for columns)</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        values: np.ndarray</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        KeyError</span>
<span class="sd">            if `key` matches neither a label nor a level</span>
<span class="sd">        ValueError</span>
<span class="sd">            if `key` matches multiple labels</span>
<span class="sd">        FutureWarning</span>
<span class="sd">            if `key` is ambiguous. This will become an ambiguity error in a</span>
<span class="sd">            future version</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">axis</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_axis_number</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span>
        <span class="n">other_axes</span> <span class="o">=</span> <span class="p">[</span><span class="n">ax</span> <span class="k">for</span> <span class="n">ax</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_AXIS_LEN</span><span class="p">)</span> <span class="k">if</span> <span class="n">ax</span> <span class="o">!=</span> <span class="n">axis</span><span class="p">]</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_label_reference</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_check_label_or_level_ambiguity</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span>
            <span class="n">values</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">xs</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">other_axes</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">.</span><span class="n">_values</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_level_reference</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">):</span>
            <span class="n">values</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">axes</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span><span class="o">.</span><span class="n">get_level_values</span><span class="p">(</span><span class="n">key</span><span class="p">)</span><span class="o">.</span><span class="n">_values</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>

        <span class="c1"># Check for duplicates</span>
        <span class="k">if</span> <span class="n">values</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>

            <span class="k">if</span> <span class="n">other_axes</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_get_axis</span><span class="p">(</span><span class="n">other_axes</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="n">MultiIndex</span><span class="p">):</span>
                <span class="n">multi_message</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span>
                    <span class="s2">&quot;For a multi-index, the label must be a &quot;</span>
                    <span class="s2">&quot;tuple with elements corresponding to &quot;</span>
                    <span class="s2">&quot;each level.&quot;</span>
                <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">multi_message</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>

            <span class="n">label_axis_name</span> <span class="o">=</span> <span class="s2">&quot;column&quot;</span> <span class="k">if</span> <span class="n">axis</span> <span class="o">==</span> <span class="mi">0</span> <span class="k">else</span> <span class="s2">&quot;index&quot;</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="p">(</span>
                    <span class="s2">&quot;The </span><span class="si">{label_axis_name}</span><span class="s2"> label &#39;</span><span class="si">{key}</span><span class="s2">&#39; &quot;</span>
                    <span class="s2">&quot;is not unique.</span><span class="si">{multi_message}</span><span class="s2">&quot;</span>
                <span class="p">)</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                    <span class="n">key</span><span class="o">=</span><span class="n">key</span><span class="p">,</span>
                    <span class="n">label_axis_name</span><span class="o">=</span><span class="n">label_axis_name</span><span class="p">,</span>
                    <span class="n">multi_message</span><span class="o">=</span><span class="n">multi_message</span><span class="p">,</span>
                <span class="p">)</span>
            <span class="p">)</span>

        <span class="k">return</span> <span class="n">values</span>

    <span class="k">def</span> <span class="nf">_drop_labels_or_levels</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">keys</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Drop labels and/or levels for the given `axis`.</span>

<span class="sd">        For each key in `keys`:</span>
<span class="sd">          - (axis=0): If key matches a column label then drop the column.</span>
<span class="sd">            Otherwise if key matches an index level then drop the level.</span>
<span class="sd">          - (axis=1): If key matches an index label then drop the row.</span>
<span class="sd">            Otherwise if key matches a column level then drop the level.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        keys: str or list of str</span>
<span class="sd">            labels or levels to drop</span>
<span class="sd">        axis: int, default 0</span>
<span class="sd">            Axis that levels are associated with (0 for index, 1 for columns)</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        dropped: DataFrame</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        ValueError</span>
<span class="sd">            if any `keys` match neither a label nor a level</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">axis</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_axis_number</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span>

        <span class="c1"># Validate keys</span>
        <span class="n">keys</span> <span class="o">=</span> <span class="n">com</span><span class="o">.</span><span class="n">maybe_make_list</span><span class="p">(</span><span class="n">keys</span><span class="p">)</span>
        <span class="n">invalid_keys</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">k</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">keys</span> <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_label_or_level_reference</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span>
        <span class="p">]</span>

        <span class="k">if</span> <span class="n">invalid_keys</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="p">(</span>
                    <span class="s2">&quot;The following keys are not valid labels or &quot;</span>
                    <span class="s2">&quot;levels for axis </span><span class="si">{axis}</span><span class="s2">: </span><span class="si">{invalid_keys}</span><span class="s2">&quot;</span>
                <span class="p">)</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">invalid_keys</span><span class="o">=</span><span class="n">invalid_keys</span><span class="p">)</span>
            <span class="p">)</span>

        <span class="c1"># Compute levels and labels to drop</span>
        <span class="n">levels_to_drop</span> <span class="o">=</span> <span class="p">[</span><span class="n">k</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">keys</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_level_reference</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)]</span>

        <span class="n">labels_to_drop</span> <span class="o">=</span> <span class="p">[</span><span class="n">k</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">keys</span> <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_level_reference</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)]</span>

        <span class="c1"># Perform copy upfront and then use inplace operations below.</span>
        <span class="c1"># This ensures that we always perform exactly one copy.</span>
        <span class="c1"># ``copy`` and/or ``inplace`` options could be added in the future.</span>
        <span class="n">dropped</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">axis</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1"># Handle dropping index levels</span>
            <span class="k">if</span> <span class="n">levels_to_drop</span><span class="p">:</span>
                <span class="n">dropped</span><span class="o">.</span><span class="n">reset_index</span><span class="p">(</span><span class="n">levels_to_drop</span><span class="p">,</span> <span class="n">drop</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

            <span class="c1"># Handle dropping columns labels</span>
            <span class="k">if</span> <span class="n">labels_to_drop</span><span class="p">:</span>
                <span class="n">dropped</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="n">labels_to_drop</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Handle dropping column levels</span>
            <span class="k">if</span> <span class="n">levels_to_drop</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dropped</span><span class="o">.</span><span class="n">columns</span><span class="p">,</span> <span class="n">MultiIndex</span><span class="p">):</span>
                    <span class="c1"># Drop the specified levels from the MultiIndex</span>
                    <span class="n">dropped</span><span class="o">.</span><span class="n">columns</span> <span class="o">=</span> <span class="n">dropped</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">droplevel</span><span class="p">(</span><span class="n">levels_to_drop</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># Drop the last level of Index by replacing with</span>
                    <span class="c1"># a RangeIndex</span>
                    <span class="n">dropped</span><span class="o">.</span><span class="n">columns</span> <span class="o">=</span> <span class="n">RangeIndex</span><span class="p">(</span><span class="n">dropped</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">size</span><span class="p">)</span>

            <span class="c1"># Handle dropping index labels</span>
            <span class="k">if</span> <span class="n">labels_to_drop</span><span class="p">:</span>
                <span class="n">dropped</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="n">labels_to_drop</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">dropped</span>

    <span class="c1"># ----------------------------------------------------------------------</span>
    <span class="c1"># Iteration</span>

    <span class="k">def</span> <span class="nf">__hash__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
            <span class="s2">&quot;</span><span class="si">{0!r}</span><span class="s2"> objects are mutable, thus they cannot be&quot;</span>
            <span class="s2">&quot; hashed&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">)</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Iterate over info axis.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        iterator</span>
<span class="sd">            Info axis as iterator.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">iter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_info_axis</span><span class="p">)</span>

    <span class="c1"># can we get a better explanation of this?</span>
    <span class="k">def</span> <span class="nf">keys</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the &#39;info axis&#39; (see Indexing for more)</span>

<span class="sd">        This is index for Series, columns for DataFrame.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Index</span>
<span class="sd">            Info axis.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_info_axis</span>

    <span class="k">def</span> <span class="nf">items</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Iterate over (label, values) on info axis</span>

<span class="sd">        This is index for Series and columns for DataFrame.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Generator</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">h</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_info_axis</span><span class="p">:</span>
            <span class="k">yield</span> <span class="n">h</span><span class="p">,</span> <span class="bp">self</span><span class="p">[</span><span class="n">h</span><span class="p">]</span>

    <span class="nd">@Appender</span><span class="p">(</span><span class="n">items</span><span class="o">.</span><span class="vm">__doc__</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">iteritems</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns length of info axis&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_info_axis</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__contains__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;True if the key is in the info axis&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_info_axis</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">empty</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Indicator whether DataFrame is empty.</span>

<span class="sd">        True if DataFrame is entirely empty (no items), meaning any of the</span>
<span class="sd">        axes are of length 0.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        bool</span>
<span class="sd">            If DataFrame is empty, return True, if not return False.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        Series.dropna</span>
<span class="sd">        DataFrame.dropna</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        If DataFrame contains only NaNs, it is still not considered empty. See</span>
<span class="sd">        the example below.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        An example of an actual empty DataFrame. Notice the index is empty:</span>

<span class="sd">        &gt;&gt;&gt; df_empty = pd.DataFrame({&#39;A&#39; : []})</span>
<span class="sd">        &gt;&gt;&gt; df_empty</span>
<span class="sd">        Empty DataFrame</span>
<span class="sd">        Columns: [A]</span>
<span class="sd">        Index: []</span>
<span class="sd">        &gt;&gt;&gt; df_empty.empty</span>
<span class="sd">        True</span>

<span class="sd">        If we only have NaNs in our DataFrame, it is not considered empty! We</span>
<span class="sd">        will need to drop the NaNs to make the DataFrame empty:</span>

<span class="sd">        &gt;&gt;&gt; df = pd.DataFrame({&#39;A&#39; : [np.nan]})</span>
<span class="sd">        &gt;&gt;&gt; df</span>
<span class="sd">            A</span>
<span class="sd">        0 NaN</span>
<span class="sd">        &gt;&gt;&gt; df.empty</span>
<span class="sd">        False</span>
<span class="sd">        &gt;&gt;&gt; df.dropna().empty</span>
<span class="sd">        True</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">any</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_get_axis</span><span class="p">(</span><span class="n">a</span><span class="p">))</span> <span class="o">==</span> <span class="mi">0</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_AXIS_ORDERS</span><span class="p">)</span>

    <span class="c1"># ----------------------------------------------------------------------</span>
    <span class="c1"># Array Interface</span>

    <span class="c1"># This is also set in IndexOpsMixin</span>
    <span class="c1"># GH#23114 Ensure ndarray.__op__(DataFrame) returns NotImplemented</span>
    <span class="n">__array_priority__</span> <span class="o">=</span> <span class="mi">1000</span>

    <span class="k">def</span> <span class="nf">__array__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">com</span><span class="o">.</span><span class="n">values_from_object</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__array_wrap__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">result</span><span class="p">,</span> <span class="n">context</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="n">d</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_construct_axes_dict</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_AXIS_ORDERS</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_constructor</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="o">**</span><span class="n">d</span><span class="p">)</span><span class="o">.</span><span class="n">__finalize__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="c1"># ideally we would define this to avoid the getattr checks, but</span>
    <span class="c1"># is slower</span>
    <span class="c1"># @property</span>
    <span class="c1"># def __array_interface__(self):</span>
    <span class="c1">#    &quot;&quot;&quot; provide numpy array interface method &quot;&quot;&quot;</span>
    <span class="c1">#    values = self.values</span>
    <span class="c1">#    return dict(typestr=values.dtype.str,shape=values.shape,data=values)</span>

    <span class="k">def</span> <span class="nf">to_dense</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return dense representation of Series/DataFrame (as opposed to sparse).</span>

<span class="sd">        .. deprecated:: 0.25.0</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        %(klass)s</span>
<span class="sd">            Dense %(klass)s.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
            <span class="s2">&quot;DataFrame/Series.to_dense is deprecated &quot;</span>
            <span class="s2">&quot;and will be removed in a future version&quot;</span><span class="p">,</span>
            <span class="ne">FutureWarning</span><span class="p">,</span>
            <span class="n">stacklevel</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="c1"># compat</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="c1"># ----------------------------------------------------------------------</span>
    <span class="c1"># Picklability</span>

    <span class="k">def</span> <span class="nf">__getstate__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">meta</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_metadata</span><span class="p">}</span>
        <span class="k">return</span> <span class="nb">dict</span><span class="p">(</span><span class="n">_data</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">,</span> <span class="n">_typ</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_typ</span><span class="p">,</span> <span class="n">_metadata</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_metadata</span><span class="p">,</span> <span class="o">**</span><span class="n">meta</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__setstate__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">state</span><span class="p">):</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="n">BlockManager</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_data</span> <span class="o">=</span> <span class="n">state</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
            <span class="n">typ</span> <span class="o">=</span> <span class="n">state</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;_typ&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">typ</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>

                <span class="c1"># set in the order of internal names</span>
                <span class="c1"># to avoid definitional recursion</span>
                <span class="c1"># e.g. say fill_value needing _data to be</span>
                <span class="c1"># defined</span>
                <span class="n">meta</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_internal_names</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">_metadata</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="n">meta</span><span class="p">):</span>
                    <span class="k">if</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">state</span><span class="p">:</span>
                        <span class="n">v</span> <span class="o">=</span> <span class="n">state</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>
                        <span class="nb">object</span><span class="o">.</span><span class="fm">__setattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>

                <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">state</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                    <span class="k">if</span> <span class="n">k</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">meta</span><span class="p">:</span>
                        <span class="nb">object</span><span class="o">.</span><span class="fm">__setattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>

            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_unpickle_series_compat</span><span class="p">(</span><span class="n">state</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">state</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">dict</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">state</span><span class="p">)</span> <span class="o">==</span> <span class="mi">5</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_unpickle_sparse_frame_compat</span><span class="p">(</span><span class="n">state</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_unpickle_frame_compat</span><span class="p">(</span><span class="n">state</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">state</span><span class="p">)</span> <span class="o">==</span> <span class="mi">4</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_unpickle_panel_compat</span><span class="p">(</span><span class="n">state</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">state</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_unpickle_series_compat</span><span class="p">(</span><span class="n">state</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>  <span class="c1"># pragma: no cover</span>
            <span class="c1"># old pickling format, for compatibility</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_unpickle_matrix_compat</span><span class="p">(</span><span class="n">state</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_item_cache</span> <span class="o">=</span> <span class="p">{}</span>

    <span class="c1"># ----------------------------------------------------------------------</span>
    <span class="c1"># Rendering Methods</span>

    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># string representation based upon iterating over self</span>
        <span class="c1"># (since, by definition, `PandasContainers` are iterable)</span>
        <span class="n">prepr</span> <span class="o">=</span> <span class="s2">&quot;[</span><span class="si">%s</span><span class="s2">]&quot;</span> <span class="o">%</span> <span class="s2">&quot;,&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="n">pprint_thing</span><span class="p">,</span> <span class="bp">self</span><span class="p">))</span>
        <span class="k">return</span> <span class="s2">&quot;</span><span class="si">%s</span><span class="s2">(</span><span class="si">%s</span><span class="s2">)&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="n">prepr</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_repr_latex_</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a LaTeX representation for a particular object.</span>
<span class="sd">        Mainly for use with nbconvert (jupyter notebook conversion to pdf).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">config</span><span class="o">.</span><span class="n">get_option</span><span class="p">(</span><span class="s2">&quot;display.latex.repr&quot;</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">to_latex</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="nf">_repr_data_resource_</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Not a real Jupyter special repr method, but we use the same</span>
<span class="sd">        naming convention.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">config</span><span class="o">.</span><span class="n">get_option</span><span class="p">(</span><span class="s2">&quot;display.html.table_schema&quot;</span><span class="p">):</span>
            <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">head</span><span class="p">(</span><span class="n">config</span><span class="o">.</span><span class="n">get_option</span><span class="p">(</span><span class="s2">&quot;display.max_rows&quot;</span><span class="p">))</span>
            <span class="n">payload</span> <span class="o">=</span> <span class="n">json</span><span class="o">.</span><span class="n">loads</span><span class="p">(</span>
                <span class="n">data</span><span class="o">.</span><span class="n">to_json</span><span class="p">(</span><span class="n">orient</span><span class="o">=</span><span class="s2">&quot;table&quot;</span><span class="p">),</span> <span class="n">object_pairs_hook</span><span class="o">=</span><span class="n">collections</span><span class="o">.</span><span class="n">OrderedDict</span>
            <span class="p">)</span>
            <span class="k">return</span> <span class="n">payload</span>

    <span class="c1"># ----------------------------------------------------------------------</span>
    <span class="c1"># I/O Methods</span>

    <span class="n">_shared_docs</span><span class="p">[</span>
        <span class="s2">&quot;to_excel&quot;</span>
    <span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;</span>
<span class="s2">    Write </span><span class="si">%(klass)s</span><span class="s2"> to an Excel sheet.</span>

<span class="s2">    To write a single </span><span class="si">%(klass)s</span><span class="s2"> to an Excel .xlsx file it is only necessary to</span>
<span class="s2">    specify a target file name. To write to multiple sheets it is necessary to</span>
<span class="s2">    create an `ExcelWriter` object with a target file name, and specify a sheet</span>
<span class="s2">    in the file to write to.</span>

<span class="s2">    Multiple sheets may be written to by specifying unique `sheet_name`.</span>
<span class="s2">    With all data written to the file it is necessary to save the changes.</span>
<span class="s2">    Note that creating an `ExcelWriter` object with a file name that already</span>
<span class="s2">    exists will result in the contents of the existing file being erased.</span>

<span class="s2">    Parameters</span>
<span class="s2">    ----------</span>
<span class="s2">    excel_writer : str or ExcelWriter object</span>
<span class="s2">        File path or existing ExcelWriter.</span>
<span class="s2">    sheet_name : str, default &#39;Sheet1&#39;</span>
<span class="s2">        Name of sheet which will contain DataFrame.</span>
<span class="s2">    na_rep : str, default &#39;&#39;</span>
<span class="s2">        Missing data representation.</span>
<span class="s2">    float_format : str, optional</span>
<span class="s2">        Format string for floating point numbers. For example</span>
<span class="s2">        ``float_format=&quot;</span><span class="si">%%</span><span class="s2">.2f&quot;`` will format 0.1234 to 0.12.</span>
<span class="s2">    columns : sequence or list of str, optional</span>
<span class="s2">        Columns to write.</span>
<span class="s2">    header : bool or list of str, default True</span>
<span class="s2">        Write out the column names. If a list of string is given it is</span>
<span class="s2">        assumed to be aliases for the column names.</span>
<span class="s2">    index : bool, default True</span>
<span class="s2">        Write row names (index).</span>
<span class="s2">    index_label : str or sequence, optional</span>
<span class="s2">        Column label for index column(s) if desired. If not specified, and</span>
<span class="s2">        `header` and `index` are True, then the index names are used. A</span>
<span class="s2">        sequence should be given if the DataFrame uses MultiIndex.</span>
<span class="s2">    startrow : int, default 0</span>
<span class="s2">        Upper left cell row to dump data frame.</span>
<span class="s2">    startcol : int, default 0</span>
<span class="s2">        Upper left cell column to dump data frame.</span>
<span class="s2">    engine : str, optional</span>
<span class="s2">        Write engine to use, &#39;openpyxl&#39; or &#39;xlsxwriter&#39;. You can also set this</span>
<span class="s2">        via the options ``io.excel.xlsx.writer``, ``io.excel.xls.writer``, and</span>
<span class="s2">        ``io.excel.xlsm.writer``.</span>
<span class="s2">    merge_cells : bool, default True</span>
<span class="s2">        Write MultiIndex and Hierarchical Rows as merged cells.</span>
<span class="s2">    encoding : str, optional</span>
<span class="s2">        Encoding of the resulting excel file. Only necessary for xlwt,</span>
<span class="s2">        other writers support unicode natively.</span>
<span class="s2">    inf_rep : str, default &#39;inf&#39;</span>
<span class="s2">        Representation for infinity (there is no native representation for</span>
<span class="s2">        infinity in Excel).</span>
<span class="s2">    verbose : bool, default True</span>
<span class="s2">        Display more information in the error logs.</span>
<span class="s2">    freeze_panes : tuple of int (length 2), optional</span>
<span class="s2">        Specifies the one-based bottommost row and rightmost column that</span>
<span class="s2">        is to be frozen.</span>

<span class="s2">        .. versionadded:: 0.20.0.</span>

<span class="s2">    See Also</span>
<span class="s2">    --------</span>
<span class="s2">    to_csv : Write DataFrame to a comma-separated values (csv) file.</span>
<span class="s2">    ExcelWriter : Class for writing DataFrame objects into excel sheets.</span>
<span class="s2">    read_excel : Read an Excel file into a pandas DataFrame.</span>
<span class="s2">    read_csv : Read a comma-separated values (csv) file into DataFrame.</span>

<span class="s2">    Notes</span>
<span class="s2">    -----</span>
<span class="s2">    For compatibility with :meth:`~DataFrame.to_csv`,</span>
<span class="s2">    to_excel serializes lists and dicts to strings before writing.</span>

<span class="s2">    Once a workbook has been saved it is not possible write further data</span>
<span class="s2">    without rewriting the whole workbook.</span>

<span class="s2">    Examples</span>
<span class="s2">    --------</span>

<span class="s2">    Create, write to and save a workbook:</span>

<span class="s2">    &gt;&gt;&gt; df1 = pd.DataFrame([[&#39;a&#39;, &#39;b&#39;], [&#39;c&#39;, &#39;d&#39;]],</span>
<span class="s2">    ...                    index=[&#39;row 1&#39;, &#39;row 2&#39;],</span>
<span class="s2">    ...                    columns=[&#39;col 1&#39;, &#39;col 2&#39;])</span>
<span class="s2">    &gt;&gt;&gt; df1.to_excel(&quot;output.xlsx&quot;)  # doctest: +SKIP</span>

<span class="s2">    To specify the sheet name:</span>

<span class="s2">    &gt;&gt;&gt; df1.to_excel(&quot;output.xlsx&quot;,</span>
<span class="s2">    ...              sheet_name=&#39;Sheet_name_1&#39;)  # doctest: +SKIP</span>

<span class="s2">    If you wish to write to more than one sheet in the workbook, it is</span>
<span class="s2">    necessary to specify an ExcelWriter object:</span>

<span class="s2">    &gt;&gt;&gt; df2 = df1.copy()</span>
<span class="s2">    &gt;&gt;&gt; with pd.ExcelWriter(&#39;output.xlsx&#39;) as writer:  # doctest: +SKIP</span>
<span class="s2">    ...     df1.to_excel(writer, sheet_name=&#39;Sheet_name_1&#39;)</span>
<span class="s2">    ...     df2.to_excel(writer, sheet_name=&#39;Sheet_name_2&#39;)</span>

<span class="s2">    To set the library that is used to write the Excel file,</span>
<span class="s2">    you can pass the `engine` keyword (the default engine is</span>
<span class="s2">    automatically chosen depending on the file extension):</span>

<span class="s2">    &gt;&gt;&gt; df1.to_excel(&#39;output1.xlsx&#39;, engine=&#39;xlsxwriter&#39;)  # doctest: +SKIP</span>
<span class="s2">    &quot;&quot;&quot;</span>

    <span class="nd">@Appender</span><span class="p">(</span><span class="n">_shared_docs</span><span class="p">[</span><span class="s2">&quot;to_excel&quot;</span><span class="p">]</span> <span class="o">%</span> <span class="nb">dict</span><span class="p">(</span><span class="n">klass</span><span class="o">=</span><span class="s2">&quot;object&quot;</span><span class="p">))</span>
    <span class="k">def</span> <span class="nf">to_excel</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">excel_writer</span><span class="p">,</span>
        <span class="n">sheet_name</span><span class="o">=</span><span class="s2">&quot;Sheet1&quot;</span><span class="p">,</span>
        <span class="n">na_rep</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">,</span>
        <span class="n">float_format</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">columns</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">header</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">index</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">index_label</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">startrow</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
        <span class="n">startcol</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
        <span class="n">engine</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">merge_cells</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">encoding</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">inf_rep</span><span class="o">=</span><span class="s2">&quot;inf&quot;</span><span class="p">,</span>
        <span class="n">verbose</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">freeze_panes</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="n">df</span> <span class="o">=</span> <span class="bp">self</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ABCDataFrame</span><span class="p">)</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">to_frame</span><span class="p">()</span>

        <span class="kn">from</span> <span class="nn">pandas.io.formats.excel</span> <span class="k">import</span> <span class="n">ExcelFormatter</span>

        <span class="n">formatter</span> <span class="o">=</span> <span class="n">ExcelFormatter</span><span class="p">(</span>
            <span class="n">df</span><span class="p">,</span>
            <span class="n">na_rep</span><span class="o">=</span><span class="n">na_rep</span><span class="p">,</span>
            <span class="n">cols</span><span class="o">=</span><span class="n">columns</span><span class="p">,</span>
            <span class="n">header</span><span class="o">=</span><span class="n">header</span><span class="p">,</span>
            <span class="n">float_format</span><span class="o">=</span><span class="n">float_format</span><span class="p">,</span>
            <span class="n">index</span><span class="o">=</span><span class="n">index</span><span class="p">,</span>
            <span class="n">index_label</span><span class="o">=</span><span class="n">index_label</span><span class="p">,</span>
            <span class="n">merge_cells</span><span class="o">=</span><span class="n">merge_cells</span><span class="p">,</span>
            <span class="n">inf_rep</span><span class="o">=</span><span class="n">inf_rep</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">formatter</span><span class="o">.</span><span class="n">write</span><span class="p">(</span>
            <span class="n">excel_writer</span><span class="p">,</span>
            <span class="n">sheet_name</span><span class="o">=</span><span class="n">sheet_name</span><span class="p">,</span>
            <span class="n">startrow</span><span class="o">=</span><span class="n">startrow</span><span class="p">,</span>
            <span class="n">startcol</span><span class="o">=</span><span class="n">startcol</span><span class="p">,</span>
            <span class="n">freeze_panes</span><span class="o">=</span><span class="n">freeze_panes</span><span class="p">,</span>
            <span class="n">engine</span><span class="o">=</span><span class="n">engine</span><span class="p">,</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">to_json</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">path_or_buf</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">orient</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">date_format</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">double_precision</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span>
        <span class="n">force_ascii</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">date_unit</span><span class="o">=</span><span class="s2">&quot;ms&quot;</span><span class="p">,</span>
        <span class="n">default_handler</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">lines</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">compression</span><span class="o">=</span><span class="s2">&quot;infer&quot;</span><span class="p">,</span>
        <span class="n">index</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Convert the object to a JSON string.</span>

<span class="sd">        Note NaN&#39;s and None will be converted to null and datetime objects</span>
<span class="sd">        will be converted to UNIX timestamps.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        path_or_buf : string or file handle, optional</span>
<span class="sd">            File path or object. If not specified, the result is returned as</span>
<span class="sd">            a string.</span>
<span class="sd">        orient : string</span>
<span class="sd">            Indication of expected JSON string format.</span>

<span class="sd">            * Series</span>

<span class="sd">              - default is &#39;index&#39;</span>
<span class="sd">              - allowed values are: {&#39;split&#39;,&#39;records&#39;,&#39;index&#39;,&#39;table&#39;}</span>

<span class="sd">            * DataFrame</span>

<span class="sd">              - default is &#39;columns&#39;</span>
<span class="sd">              - allowed values are:</span>
<span class="sd">                {&#39;split&#39;,&#39;records&#39;,&#39;index&#39;,&#39;columns&#39;,&#39;values&#39;,&#39;table&#39;}</span>

<span class="sd">            * The format of the JSON string</span>

<span class="sd">              - &#39;split&#39; : dict like {&#39;index&#39; -&gt; [index],</span>
<span class="sd">                &#39;columns&#39; -&gt; [columns], &#39;data&#39; -&gt; [values]}</span>
<span class="sd">              - &#39;records&#39; : list like</span>
<span class="sd">                [{column -&gt; value}, ... , {column -&gt; value}]</span>
<span class="sd">              - &#39;index&#39; : dict like {index -&gt; {column -&gt; value}}</span>
<span class="sd">              - &#39;columns&#39; : dict like {column -&gt; {index -&gt; value}}</span>
<span class="sd">              - &#39;values&#39; : just the values array</span>
<span class="sd">              - &#39;table&#39; : dict like {&#39;schema&#39;: {schema}, &#39;data&#39;: {data}}</span>
<span class="sd">                describing the data, and the data component is</span>
<span class="sd">                like ``orient=&#39;records&#39;``.</span>

<span class="sd">                .. versionchanged:: 0.20.0</span>

<span class="sd">        date_format : {None, &#39;epoch&#39;, &#39;iso&#39;}</span>
<span class="sd">            Type of date conversion. &#39;epoch&#39; = epoch milliseconds,</span>
<span class="sd">            &#39;iso&#39; = ISO8601. The default depends on the `orient`. For</span>
<span class="sd">            ``orient=&#39;table&#39;``, the default is &#39;iso&#39;. For all other orients,</span>
<span class="sd">            the default is &#39;epoch&#39;.</span>
<span class="sd">        double_precision : int, default 10</span>
<span class="sd">            The number of decimal places to use when encoding</span>
<span class="sd">            floating point values.</span>
<span class="sd">        force_ascii : bool, default True</span>
<span class="sd">            Force encoded string to be ASCII.</span>
<span class="sd">        date_unit : string, default &#39;ms&#39; (milliseconds)</span>
<span class="sd">            The time unit to encode to, governs timestamp and ISO8601</span>
<span class="sd">            precision.  One of &#39;s&#39;, &#39;ms&#39;, &#39;us&#39;, &#39;ns&#39; for second, millisecond,</span>
<span class="sd">            microsecond, and nanosecond respectively.</span>
<span class="sd">        default_handler : callable, default None</span>
<span class="sd">            Handler to call if object cannot otherwise be converted to a</span>
<span class="sd">            suitable format for JSON. Should receive a single argument which is</span>
<span class="sd">            the object to convert and return a serialisable object.</span>
<span class="sd">        lines : bool, default False</span>
<span class="sd">            If &#39;orient&#39; is &#39;records&#39; write out line delimited json format. Will</span>
<span class="sd">            throw ValueError if incorrect &#39;orient&#39; since others are not list</span>
<span class="sd">            like.</span>

<span class="sd">            .. versionadded:: 0.19.0</span>

<span class="sd">        compression : {&#39;infer&#39;, &#39;gzip&#39;, &#39;bz2&#39;, &#39;zip&#39;, &#39;xz&#39;, None}</span>

<span class="sd">            A string representing the compression to use in the output file,</span>
<span class="sd">            only used when the first argument is a filename. By default, the</span>
<span class="sd">            compression is inferred from the filename.</span>

<span class="sd">            .. versionadded:: 0.21.0</span>
<span class="sd">            .. versionchanged:: 0.24.0</span>
<span class="sd">               &#39;infer&#39; option added and set to default</span>
<span class="sd">        index : bool, default True</span>
<span class="sd">            Whether to include the index values in the JSON string. Not</span>
<span class="sd">            including the index (``index=False``) is only supported when</span>
<span class="sd">            orient is &#39;split&#39; or &#39;table&#39;.</span>

<span class="sd">            .. versionadded:: 0.23.0</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        None or str</span>
<span class="sd">            If path_or_buf is None, returns the resulting json format as a</span>
<span class="sd">            string. Otherwise returns None.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        read_json</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>

<span class="sd">        &gt;&gt;&gt; df = pd.DataFrame([[&#39;a&#39;, &#39;b&#39;], [&#39;c&#39;, &#39;d&#39;]],</span>
<span class="sd">        ...                   index=[&#39;row 1&#39;, &#39;row 2&#39;],</span>
<span class="sd">        ...                   columns=[&#39;col 1&#39;, &#39;col 2&#39;])</span>
<span class="sd">        &gt;&gt;&gt; df.to_json(orient=&#39;split&#39;)</span>
<span class="sd">        &#39;{&quot;columns&quot;:[&quot;col 1&quot;,&quot;col 2&quot;],</span>
<span class="sd">          &quot;index&quot;:[&quot;row 1&quot;,&quot;row 2&quot;],</span>
<span class="sd">          &quot;data&quot;:[[&quot;a&quot;,&quot;b&quot;],[&quot;c&quot;,&quot;d&quot;]]}&#39;</span>

<span class="sd">        Encoding/decoding a Dataframe using ``&#39;records&#39;`` formatted JSON.</span>
<span class="sd">        Note that index labels are not preserved with this encoding.</span>

<span class="sd">        &gt;&gt;&gt; df.to_json(orient=&#39;records&#39;)</span>
<span class="sd">        &#39;[{&quot;col 1&quot;:&quot;a&quot;,&quot;col 2&quot;:&quot;b&quot;},{&quot;col 1&quot;:&quot;c&quot;,&quot;col 2&quot;:&quot;d&quot;}]&#39;</span>

<span class="sd">        Encoding/decoding a Dataframe using ``&#39;index&#39;`` formatted JSON:</span>

<span class="sd">        &gt;&gt;&gt; df.to_json(orient=&#39;index&#39;)</span>
<span class="sd">        &#39;{&quot;row 1&quot;:{&quot;col 1&quot;:&quot;a&quot;,&quot;col 2&quot;:&quot;b&quot;},&quot;row 2&quot;:{&quot;col 1&quot;:&quot;c&quot;,&quot;col 2&quot;:&quot;d&quot;}}&#39;</span>

<span class="sd">        Encoding/decoding a Dataframe using ``&#39;columns&#39;`` formatted JSON:</span>

<span class="sd">        &gt;&gt;&gt; df.to_json(orient=&#39;columns&#39;)</span>
<span class="sd">        &#39;{&quot;col 1&quot;:{&quot;row 1&quot;:&quot;a&quot;,&quot;row 2&quot;:&quot;c&quot;},&quot;col 2&quot;:{&quot;row 1&quot;:&quot;b&quot;,&quot;row 2&quot;:&quot;d&quot;}}&#39;</span>

<span class="sd">        Encoding/decoding a Dataframe using ``&#39;values&#39;`` formatted JSON:</span>

<span class="sd">        &gt;&gt;&gt; df.to_json(orient=&#39;values&#39;)</span>
<span class="sd">        &#39;[[&quot;a&quot;,&quot;b&quot;],[&quot;c&quot;,&quot;d&quot;]]&#39;</span>

<span class="sd">        Encoding with Table Schema</span>

<span class="sd">        &gt;&gt;&gt; df.to_json(orient=&#39;table&#39;)</span>
<span class="sd">        &#39;{&quot;schema&quot;: {&quot;fields&quot;: [{&quot;name&quot;: &quot;index&quot;, &quot;type&quot;: &quot;string&quot;},</span>
<span class="sd">                                {&quot;name&quot;: &quot;col 1&quot;, &quot;type&quot;: &quot;string&quot;},</span>
<span class="sd">                                {&quot;name&quot;: &quot;col 2&quot;, &quot;type&quot;: &quot;string&quot;}],</span>
<span class="sd">                     &quot;primaryKey&quot;: &quot;index&quot;,</span>
<span class="sd">                     &quot;pandas_version&quot;: &quot;0.20.0&quot;},</span>
<span class="sd">          &quot;data&quot;: [{&quot;index&quot;: &quot;row 1&quot;, &quot;col 1&quot;: &quot;a&quot;, &quot;col 2&quot;: &quot;b&quot;},</span>
<span class="sd">                   {&quot;index&quot;: &quot;row 2&quot;, &quot;col 1&quot;: &quot;c&quot;, &quot;col 2&quot;: &quot;d&quot;}]}&#39;</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="kn">from</span> <span class="nn">pandas.io</span> <span class="k">import</span> <span class="n">json</span>

        <span class="k">if</span> <span class="n">date_format</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">orient</span> <span class="o">==</span> <span class="s2">&quot;table&quot;</span><span class="p">:</span>
            <span class="n">date_format</span> <span class="o">=</span> <span class="s2">&quot;iso&quot;</span>
        <span class="k">elif</span> <span class="n">date_format</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">date_format</span> <span class="o">=</span> <span class="s2">&quot;epoch&quot;</span>
        <span class="k">return</span> <span class="n">json</span><span class="o">.</span><span class="n">to_json</span><span class="p">(</span>
            <span class="n">path_or_buf</span><span class="o">=</span><span class="n">path_or_buf</span><span class="p">,</span>
            <span class="n">obj</span><span class="o">=</span><span class="bp">self</span><span class="p">,</span>
            <span class="n">orient</span><span class="o">=</span><span class="n">orient</span><span class="p">,</span>
            <span class="n">date_format</span><span class="o">=</span><span class="n">date_format</span><span class="p">,</span>
            <span class="n">double_precision</span><span class="o">=</span><span class="n">double_precision</span><span class="p">,</span>
            <span class="n">force_ascii</span><span class="o">=</span><span class="n">force_ascii</span><span class="p">,</span>
            <span class="n">date_unit</span><span class="o">=</span><span class="n">date_unit</span><span class="p">,</span>
            <span class="n">default_handler</span><span class="o">=</span><span class="n">default_handler</span><span class="p">,</span>
            <span class="n">lines</span><span class="o">=</span><span class="n">lines</span><span class="p">,</span>
            <span class="n">compression</span><span class="o">=</span><span class="n">compression</span><span class="p">,</span>
            <span class="n">index</span><span class="o">=</span><span class="n">index</span><span class="p">,</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">to_hdf</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">path_or_buf</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Write the contained data to an HDF5 file using HDFStore.</span>

<span class="sd">        Hierarchical Data Format (HDF) is self-describing, allowing an</span>
<span class="sd">        application to interpret the structure and contents of a file with</span>
<span class="sd">        no outside information. One HDF file can hold a mix of related objects</span>
<span class="sd">        which can be accessed as a group or as individual objects.</span>

<span class="sd">        In order to add another DataFrame or Series to an existing HDF file</span>
<span class="sd">        please use append mode and a different a key.</span>

<span class="sd">        For more information see the :ref:`user guide &lt;io.hdf5&gt;`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        path_or_buf : str or pandas.HDFStore</span>
<span class="sd">            File path or HDFStore object.</span>
<span class="sd">        key : str</span>
<span class="sd">            Identifier for the group in the store.</span>
<span class="sd">        mode : {&#39;a&#39;, &#39;w&#39;, &#39;r+&#39;}, default &#39;a&#39;</span>
<span class="sd">            Mode to open file:</span>

<span class="sd">            - &#39;w&#39;: write, a new file is created (an existing file with</span>
<span class="sd">              the same name would be deleted).</span>
<span class="sd">            - &#39;a&#39;: append, an existing file is opened for reading and</span>
<span class="sd">              writing, and if the file does not exist it is created.</span>
<span class="sd">            - &#39;r+&#39;: similar to &#39;a&#39;, but the file must already exist.</span>
<span class="sd">        format : {&#39;fixed&#39;, &#39;table&#39;}, default &#39;fixed&#39;</span>
<span class="sd">            Possible values:</span>

<span class="sd">            - &#39;fixed&#39;: Fixed format. Fast writing/reading. Not-appendable,</span>
<span class="sd">              nor searchable.</span>
<span class="sd">            - &#39;table&#39;: Table format. Write as a PyTables Table structure</span>
<span class="sd">              which may perform worse but allow more flexible operations</span>
<span class="sd">              like searching / selecting subsets of the data.</span>
<span class="sd">        append : bool, default False</span>
<span class="sd">            For Table formats, append the input data to the existing.</span>
<span class="sd">        data_columns :  list of columns or True, optional</span>
<span class="sd">            List of columns to create as indexed data columns for on-disk</span>
<span class="sd">            queries, or True to use all columns. By default only the axes</span>
<span class="sd">            of the object are indexed. See :ref:`io.hdf5-query-data-columns`.</span>
<span class="sd">            Applicable only to format=&#39;table&#39;.</span>
<span class="sd">        complevel : {0-9}, optional</span>
<span class="sd">            Specifies a compression level for data.</span>
<span class="sd">            A value of 0 disables compression.</span>
<span class="sd">        complib : {&#39;zlib&#39;, &#39;lzo&#39;, &#39;bzip2&#39;, &#39;blosc&#39;}, default &#39;zlib&#39;</span>
<span class="sd">            Specifies the compression library to be used.</span>
<span class="sd">            As of v0.20.2 these additional compressors for Blosc are supported</span>
<span class="sd">            (default if no compressor specified: &#39;blosc:blosclz&#39;):</span>
<span class="sd">            {&#39;blosc:blosclz&#39;, &#39;blosc:lz4&#39;, &#39;blosc:lz4hc&#39;, &#39;blosc:snappy&#39;,</span>
<span class="sd">            &#39;blosc:zlib&#39;, &#39;blosc:zstd&#39;}.</span>
<span class="sd">            Specifying a compression library which is not available issues</span>
<span class="sd">            a ValueError.</span>
<span class="sd">        fletcher32 : bool, default False</span>
<span class="sd">            If applying compression use the fletcher32 checksum.</span>
<span class="sd">        dropna : bool, default False</span>
<span class="sd">            If true, ALL nan rows will not be written to store.</span>
<span class="sd">        errors : str, default &#39;strict&#39;</span>
<span class="sd">            Specifies how encoding and decoding errors are to be handled.</span>
<span class="sd">            See the errors argument for :func:`open` for a full list</span>
<span class="sd">            of options.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        DataFrame.read_hdf : Read from HDF file.</span>
<span class="sd">        DataFrame.to_parquet : Write a DataFrame to the binary parquet format.</span>
<span class="sd">        DataFrame.to_sql : Write to a sql table.</span>
<span class="sd">        DataFrame.to_feather : Write out feather-format for DataFrames.</span>
<span class="sd">        DataFrame.to_csv : Write out to a csv file.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; df = pd.DataFrame({&#39;A&#39;: [1, 2, 3], &#39;B&#39;: [4, 5, 6]},</span>
<span class="sd">        ...                   index=[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;])</span>
<span class="sd">        &gt;&gt;&gt; df.to_hdf(&#39;data.h5&#39;, key=&#39;df&#39;, mode=&#39;w&#39;)</span>

<span class="sd">        We can add another object to the same file:</span>

<span class="sd">        &gt;&gt;&gt; s = pd.Series([1, 2, 3, 4])</span>
<span class="sd">        &gt;&gt;&gt; s.to_hdf(&#39;data.h5&#39;, key=&#39;s&#39;)</span>

<span class="sd">        Reading from HDF file:</span>

<span class="sd">        &gt;&gt;&gt; pd.read_hdf(&#39;data.h5&#39;, &#39;df&#39;)</span>
<span class="sd">        A  B</span>
<span class="sd">        a  1  4</span>
<span class="sd">        b  2  5</span>
<span class="sd">        c  3  6</span>
<span class="sd">        &gt;&gt;&gt; pd.read_hdf(&#39;data.h5&#39;, &#39;s&#39;)</span>
<span class="sd">        0    1</span>
<span class="sd">        1    2</span>
<span class="sd">        2    3</span>
<span class="sd">        3    4</span>
<span class="sd">        dtype: int64</span>

<span class="sd">        Deleting file with data:</span>

<span class="sd">        &gt;&gt;&gt; import os</span>
<span class="sd">        &gt;&gt;&gt; os.remove(&#39;data.h5&#39;)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">pandas.io</span> <span class="k">import</span> <span class="n">pytables</span>

        <span class="n">pytables</span><span class="o">.</span><span class="n">to_hdf</span><span class="p">(</span><span class="n">path_or_buf</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">to_msgpack</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">path_or_buf</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">encoding</span><span class="o">=</span><span class="s2">&quot;utf-8&quot;</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Serialize object to input file path using msgpack format.</span>

<span class="sd">        .. deprecated:: 0.25.0</span>

<span class="sd">        to_msgpack is deprecated and will be removed in a future version.</span>
<span class="sd">        It is recommended to use pyarrow for on-the-wire transmission of</span>
<span class="sd">        pandas objects.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        path : string File path, buffer-like, or None</span>
<span class="sd">            if None, return generated bytes</span>
<span class="sd">        append : bool whether to append to an existing msgpack</span>
<span class="sd">            (default is False)</span>
<span class="sd">        compress : type of compressor (zlib or blosc), default to None (no</span>
<span class="sd">            compression)</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        None or bytes</span>
<span class="sd">            If path_or_buf is None, returns the resulting msgpack format as a</span>
<span class="sd">            byte string. Otherwise returns None.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="kn">from</span> <span class="nn">pandas.io</span> <span class="k">import</span> <span class="n">packers</span>

        <span class="k">return</span> <span class="n">packers</span><span class="o">.</span><span class="n">to_msgpack</span><span class="p">(</span><span class="n">path_or_buf</span><span class="p">,</span> <span class="bp">self</span><span class="p">,</span> <span class="n">encoding</span><span class="o">=</span><span class="n">encoding</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">to_sql</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">name</span><span class="p">,</span>
        <span class="n">con</span><span class="p">,</span>
        <span class="n">schema</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">if_exists</span><span class="o">=</span><span class="s2">&quot;fail&quot;</span><span class="p">,</span>
        <span class="n">index</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">index_label</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">chunksize</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">dtype</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">method</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Write records stored in a DataFrame to a SQL database.</span>

<span class="sd">        Databases supported by SQLAlchemy [1]_ are supported. Tables can be</span>
<span class="sd">        newly created, appended to, or overwritten.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        name : string</span>
<span class="sd">            Name of SQL table.</span>
<span class="sd">        con : sqlalchemy.engine.Engine or sqlite3.Connection</span>
<span class="sd">            Using SQLAlchemy makes it possible to use any DB supported by that</span>
<span class="sd">            library. Legacy support is provided for sqlite3.Connection objects.</span>
<span class="sd">        schema : string, optional</span>
<span class="sd">            Specify the schema (if database flavor supports this). If None, use</span>
<span class="sd">            default schema.</span>
<span class="sd">        if_exists : {&#39;fail&#39;, &#39;replace&#39;, &#39;append&#39;}, default &#39;fail&#39;</span>
<span class="sd">            How to behave if the table already exists.</span>

<span class="sd">            * fail: Raise a ValueError.</span>
<span class="sd">            * replace: Drop the table before inserting new values.</span>
<span class="sd">            * append: Insert new values to the existing table.</span>

<span class="sd">        index : bool, default True</span>
<span class="sd">            Write DataFrame index as a column. Uses `index_label` as the column</span>
<span class="sd">            name in the table.</span>
<span class="sd">        index_label : string or sequence, default None</span>
<span class="sd">            Column label for index column(s). If None is given (default) and</span>
<span class="sd">            `index` is True, then the index names are used.</span>
<span class="sd">            A sequence should be given if the DataFrame uses MultiIndex.</span>
<span class="sd">        chunksize : int, optional</span>
<span class="sd">            Rows will be written in batches of this size at a time. By default,</span>
<span class="sd">            all rows will be written at once.</span>
<span class="sd">        dtype : dict, optional</span>
<span class="sd">            Specifying the datatype for columns. The keys should be the column</span>
<span class="sd">            names and the values should be the SQLAlchemy types or strings for</span>
<span class="sd">            the sqlite3 legacy mode.</span>
<span class="sd">        method : {None, &#39;multi&#39;, callable}, default None</span>
<span class="sd">            Controls the SQL insertion clause used:</span>

<span class="sd">            * None : Uses standard SQL ``INSERT`` clause (one per row).</span>
<span class="sd">            * &#39;multi&#39;: Pass multiple values in a single ``INSERT`` clause.</span>
<span class="sd">            * callable with signature ``(pd_table, conn, keys, data_iter)``.</span>

<span class="sd">            Details and a sample callable implementation can be found in the</span>
<span class="sd">            section :ref:`insert method &lt;io.sql.method&gt;`.</span>

<span class="sd">            .. versionadded:: 0.24.0</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        ValueError</span>
<span class="sd">            When the table already exists and `if_exists` is &#39;fail&#39; (the</span>
<span class="sd">            default).</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        read_sql : Read a DataFrame from a table.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        Timezone aware datetime columns will be written as</span>
<span class="sd">        ``Timestamp with timezone`` type with SQLAlchemy if supported by the</span>
<span class="sd">        database. Otherwise, the datetimes will be stored as timezone unaware</span>
<span class="sd">        timestamps local to the original timezone.</span>

<span class="sd">        .. versionadded:: 0.24.0</span>

<span class="sd">        References</span>
<span class="sd">        ----------</span>
<span class="sd">        .. [1] http://docs.sqlalchemy.org</span>
<span class="sd">        .. [2] https://www.python.org/dev/peps/pep-0249/</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>

<span class="sd">        Create an in-memory SQLite database.</span>

<span class="sd">        &gt;&gt;&gt; from sqlalchemy import create_engine</span>
<span class="sd">        &gt;&gt;&gt; engine = create_engine(&#39;sqlite://&#39;, echo=False)</span>

<span class="sd">        Create a table from scratch with 3 rows.</span>

<span class="sd">        &gt;&gt;&gt; df = pd.DataFrame({&#39;name&#39; : [&#39;User 1&#39;, &#39;User 2&#39;, &#39;User 3&#39;]})</span>
<span class="sd">        &gt;&gt;&gt; df</span>
<span class="sd">             name</span>
<span class="sd">        0  User 1</span>
<span class="sd">        1  User 2</span>
<span class="sd">        2  User 3</span>

<span class="sd">        &gt;&gt;&gt; df.to_sql(&#39;users&#39;, con=engine)</span>
<span class="sd">        &gt;&gt;&gt; engine.execute(&quot;SELECT * FROM users&quot;).fetchall()</span>
<span class="sd">        [(0, &#39;User 1&#39;), (1, &#39;User 2&#39;), (2, &#39;User 3&#39;)]</span>

<span class="sd">        &gt;&gt;&gt; df1 = pd.DataFrame({&#39;name&#39; : [&#39;User 4&#39;, &#39;User 5&#39;]})</span>
<span class="sd">        &gt;&gt;&gt; df1.to_sql(&#39;users&#39;, con=engine, if_exists=&#39;append&#39;)</span>
<span class="sd">        &gt;&gt;&gt; engine.execute(&quot;SELECT * FROM users&quot;).fetchall()</span>
<span class="sd">        [(0, &#39;User 1&#39;), (1, &#39;User 2&#39;), (2, &#39;User 3&#39;),</span>
<span class="sd">         (0, &#39;User 4&#39;), (1, &#39;User 5&#39;)]</span>

<span class="sd">        Overwrite the table with just ``df1``.</span>

<span class="sd">        &gt;&gt;&gt; df1.to_sql(&#39;users&#39;, con=engine, if_exists=&#39;replace&#39;,</span>
<span class="sd">        ...            index_label=&#39;id&#39;)</span>
<span class="sd">        &gt;&gt;&gt; engine.execute(&quot;SELECT * FROM users&quot;).fetchall()</span>
<span class="sd">        [(0, &#39;User 4&#39;), (1, &#39;User 5&#39;)]</span>

<span class="sd">        Specify the dtype (especially useful for integers with missing values).</span>
<span class="sd">        Notice that while pandas is forced to store the data as floating point,</span>
<span class="sd">        the database supports nullable integers. When fetching the data with</span>
<span class="sd">        Python, we get back integer scalars.</span>

<span class="sd">        &gt;&gt;&gt; df = pd.DataFrame({&quot;A&quot;: [1, None, 2]})</span>
<span class="sd">        &gt;&gt;&gt; df</span>
<span class="sd">             A</span>
<span class="sd">        0  1.0</span>
<span class="sd">        1  NaN</span>
<span class="sd">        2  2.0</span>

<span class="sd">        &gt;&gt;&gt; from sqlalchemy.types import Integer</span>
<span class="sd">        &gt;&gt;&gt; df.to_sql(&#39;integers&#39;, con=engine, index=False,</span>
<span class="sd">        ...           dtype={&quot;A&quot;: Integer()})</span>

<span class="sd">        &gt;&gt;&gt; engine.execute(&quot;SELECT * FROM integers&quot;).fetchall()</span>
<span class="sd">        [(1,), (None,), (2,)]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">pandas.io</span> <span class="k">import</span> <span class="n">sql</span>

        <span class="n">sql</span><span class="o">.</span><span class="n">to_sql</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">name</span><span class="p">,</span>
            <span class="n">con</span><span class="p">,</span>
            <span class="n">schema</span><span class="o">=</span><span class="n">schema</span><span class="p">,</span>
            <span class="n">if_exists</span><span class="o">=</span><span class="n">if_exists</span><span class="p">,</span>
            <span class="n">index</span><span class="o">=</span><span class="n">index</span><span class="p">,</span>
            <span class="n">index_label</span><span class="o">=</span><span class="n">index_label</span><span class="p">,</span>
            <span class="n">chunksize</span><span class="o">=</span><span class="n">chunksize</span><span class="p">,</span>
            <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span>
            <span class="n">method</span><span class="o">=</span><span class="n">method</span><span class="p">,</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">to_pickle</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="n">compression</span><span class="o">=</span><span class="s2">&quot;infer&quot;</span><span class="p">,</span> <span class="n">protocol</span><span class="o">=</span><span class="n">pickle</span><span class="o">.</span><span class="n">HIGHEST_PROTOCOL</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Pickle (serialize) object to file.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        path : str</span>
<span class="sd">            File path where the pickled object will be stored.</span>
<span class="sd">        compression : {&#39;infer&#39;, &#39;gzip&#39;, &#39;bz2&#39;, &#39;zip&#39;, &#39;xz&#39;, None}, \</span>
<span class="sd">        default &#39;infer&#39;</span>
<span class="sd">            A string representing the compression to use in the output file. By</span>
<span class="sd">            default, infers from the file extension in specified path.</span>

<span class="sd">            .. versionadded:: 0.20.0</span>
<span class="sd">        protocol : int</span>
<span class="sd">            Int which indicates which protocol should be used by the pickler,</span>
<span class="sd">            default HIGHEST_PROTOCOL (see [1]_ paragraph 12.1.2). The possible</span>
<span class="sd">            values are 0, 1, 2, 3, 4. A negative value for the protocol</span>
<span class="sd">            parameter is equivalent to setting its value to HIGHEST_PROTOCOL.</span>

<span class="sd">            .. [1] https://docs.python.org/3/library/pickle.html</span>
<span class="sd">            .. versionadded:: 0.21.0</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        read_pickle : Load pickled pandas object (or any object) from file.</span>
<span class="sd">        DataFrame.to_hdf : Write DataFrame to an HDF5 file.</span>
<span class="sd">        DataFrame.to_sql : Write DataFrame to a SQL database.</span>
<span class="sd">        DataFrame.to_parquet : Write a DataFrame to the binary parquet format.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; original_df = pd.DataFrame({&quot;foo&quot;: range(5), &quot;bar&quot;: range(5, 10)})</span>
<span class="sd">        &gt;&gt;&gt; original_df</span>
<span class="sd">           foo  bar</span>
<span class="sd">        0    0    5</span>
<span class="sd">        1    1    6</span>
<span class="sd">        2    2    7</span>
<span class="sd">        3    3    8</span>
<span class="sd">        4    4    9</span>
<span class="sd">        &gt;&gt;&gt; original_df.to_pickle(&quot;./dummy.pkl&quot;)</span>

<span class="sd">        &gt;&gt;&gt; unpickled_df = pd.read_pickle(&quot;./dummy.pkl&quot;)</span>
<span class="sd">        &gt;&gt;&gt; unpickled_df</span>
<span class="sd">           foo  bar</span>
<span class="sd">        0    0    5</span>
<span class="sd">        1    1    6</span>
<span class="sd">        2    2    7</span>
<span class="sd">        3    3    8</span>
<span class="sd">        4    4    9</span>

<span class="sd">        &gt;&gt;&gt; import os</span>
<span class="sd">        &gt;&gt;&gt; os.remove(&quot;./dummy.pkl&quot;)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">pandas.io.pickle</span> <span class="k">import</span> <span class="n">to_pickle</span>

        <span class="n">to_pickle</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="n">compression</span><span class="o">=</span><span class="n">compression</span><span class="p">,</span> <span class="n">protocol</span><span class="o">=</span><span class="n">protocol</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">to_clipboard</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">excel</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">sep</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Copy object to the system clipboard.</span>

<span class="sd">        Write a text representation of object to the system clipboard.</span>
<span class="sd">        This can be pasted into Excel, for example.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        excel : bool, default True</span>
<span class="sd">            - True, use the provided separator, writing in a csv format for</span>
<span class="sd">              allowing easy pasting into excel.</span>
<span class="sd">            - False, write a string representation of the object to the</span>
<span class="sd">              clipboard.</span>

<span class="sd">        sep : str, default ``&#39;\t&#39;``</span>
<span class="sd">            Field delimiter.</span>
<span class="sd">        **kwargs</span>
<span class="sd">            These parameters will be passed to DataFrame.to_csv.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        DataFrame.to_csv : Write a DataFrame to a comma-separated values</span>
<span class="sd">            (csv) file.</span>
<span class="sd">        read_clipboard : Read text from clipboard and pass to read_table.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        Requirements for your platform.</span>

<span class="sd">          - Linux : `xclip`, or `xsel` (with `PyQt4` modules)</span>
<span class="sd">          - Windows : none</span>
<span class="sd">          - OS X : none</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        Copy the contents of a DataFrame to the clipboard.</span>

<span class="sd">        &gt;&gt;&gt; df = pd.DataFrame([[1, 2, 3], [4, 5, 6]], columns=[&#39;A&#39;, &#39;B&#39;, &#39;C&#39;])</span>
<span class="sd">        &gt;&gt;&gt; df.to_clipboard(sep=&#39;,&#39;)</span>
<span class="sd">        ... # Wrote the following to the system clipboard:</span>
<span class="sd">        ... # ,A,B,C</span>
<span class="sd">        ... # 0,1,2,3</span>
<span class="sd">        ... # 1,4,5,6</span>

<span class="sd">        We can omit the the index by passing the keyword `index` and setting</span>
<span class="sd">        it to false.</span>

<span class="sd">        &gt;&gt;&gt; df.to_clipboard(sep=&#39;,&#39;, index=False)</span>
<span class="sd">        ... # Wrote the following to the system clipboard:</span>
<span class="sd">        ... # A,B,C</span>
<span class="sd">        ... # 1,2,3</span>
<span class="sd">        ... # 4,5,6</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">pandas.io</span> <span class="k">import</span> <span class="n">clipboards</span>

        <span class="n">clipboards</span><span class="o">.</span><span class="n">to_clipboard</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">excel</span><span class="o">=</span><span class="n">excel</span><span class="p">,</span> <span class="n">sep</span><span class="o">=</span><span class="n">sep</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">to_xarray</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return an xarray object from the pandas object.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        xarray.DataArray or xarray.Dataset</span>
<span class="sd">            Data in the pandas structure converted to Dataset if the object is</span>
<span class="sd">            a DataFrame, or a DataArray if the object is a Series.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        DataFrame.to_hdf : Write DataFrame to an HDF5 file.</span>
<span class="sd">        DataFrame.to_parquet : Write a DataFrame to the binary parquet format.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        See the `xarray docs &lt;http://xarray.pydata.org/en/stable/&gt;`__</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; df = pd.DataFrame([(&#39;falcon&#39;, &#39;bird&#39;,  389.0, 2),</span>
<span class="sd">        ...                    (&#39;parrot&#39;, &#39;bird&#39;, 24.0, 2),</span>
<span class="sd">        ...                    (&#39;lion&#39;,   &#39;mammal&#39;, 80.5, 4),</span>
<span class="sd">        ...                    (&#39;monkey&#39;, &#39;mammal&#39;, np.nan, 4)],</span>
<span class="sd">        ...                    columns=[&#39;name&#39;, &#39;class&#39;, &#39;max_speed&#39;,</span>
<span class="sd">        ...                             &#39;num_legs&#39;])</span>
<span class="sd">        &gt;&gt;&gt; df</span>
<span class="sd">             name   class  max_speed  num_legs</span>
<span class="sd">        0  falcon    bird      389.0         2</span>
<span class="sd">        1  parrot    bird       24.0         2</span>
<span class="sd">        2    lion  mammal       80.5         4</span>
<span class="sd">        3  monkey  mammal        NaN         4</span>

<span class="sd">        &gt;&gt;&gt; df.to_xarray()</span>
<span class="sd">        &lt;xarray.Dataset&gt;</span>
<span class="sd">        Dimensions:    (index: 4)</span>
<span class="sd">        Coordinates:</span>
<span class="sd">          * index      (index) int64 0 1 2 3</span>
<span class="sd">        Data variables:</span>
<span class="sd">            name       (index) object &#39;falcon&#39; &#39;parrot&#39; &#39;lion&#39; &#39;monkey&#39;</span>
<span class="sd">            class      (index) object &#39;bird&#39; &#39;bird&#39; &#39;mammal&#39; &#39;mammal&#39;</span>
<span class="sd">            max_speed  (index) float64 389.0 24.0 80.5 nan</span>
<span class="sd">            num_legs   (index) int64 2 2 4 4</span>

<span class="sd">        &gt;&gt;&gt; df[&#39;max_speed&#39;].to_xarray()</span>
<span class="sd">        &lt;xarray.DataArray &#39;max_speed&#39; (index: 4)&gt;</span>
<span class="sd">        array([389. ,  24. ,  80.5,   nan])</span>
<span class="sd">        Coordinates:</span>
<span class="sd">          * index    (index) int64 0 1 2 3</span>

<span class="sd">        &gt;&gt;&gt; dates = pd.to_datetime([&#39;2018-01-01&#39;, &#39;2018-01-01&#39;,</span>
<span class="sd">        ...                         &#39;2018-01-02&#39;, &#39;2018-01-02&#39;])</span>
<span class="sd">        &gt;&gt;&gt; df_multiindex = pd.DataFrame({&#39;date&#39;: dates,</span>
<span class="sd">        ...                    &#39;animal&#39;: [&#39;falcon&#39;, &#39;parrot&#39;, &#39;falcon&#39;,</span>
<span class="sd">        ...                               &#39;parrot&#39;],</span>
<span class="sd">        ...                    &#39;speed&#39;: [350, 18, 361, 15]}).set_index([&#39;date&#39;,</span>
<span class="sd">        ...                                                    &#39;animal&#39;])</span>
<span class="sd">        &gt;&gt;&gt; df_multiindex</span>
<span class="sd">                           speed</span>
<span class="sd">        date       animal</span>
<span class="sd">        2018-01-01 falcon    350</span>
<span class="sd">                   parrot     18</span>
<span class="sd">        2018-01-02 falcon    361</span>
<span class="sd">                   parrot     15</span>

<span class="sd">        &gt;&gt;&gt; df_multiindex.to_xarray()</span>
<span class="sd">        &lt;xarray.Dataset&gt;</span>
<span class="sd">        Dimensions:  (animal: 2, date: 2)</span>
<span class="sd">        Coordinates:</span>
<span class="sd">          * date     (date) datetime64[ns] 2018-01-01 2018-01-02</span>
<span class="sd">          * animal   (animal) object &#39;falcon&#39; &#39;parrot&#39;</span>
<span class="sd">        Data variables:</span>
<span class="sd">            speed    (date, animal) int64 350 18 361 15</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">xarray</span> <span class="o">=</span> <span class="n">import_optional_dependency</span><span class="p">(</span><span class="s2">&quot;xarray&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">xarray</span><span class="o">.</span><span class="n">DataArray</span><span class="o">.</span><span class="n">from_series</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">xarray</span><span class="o">.</span><span class="n">Dataset</span><span class="o">.</span><span class="n">from_dataframe</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">to_latex</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">buf</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">columns</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">col_space</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">header</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">index</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">na_rep</span><span class="o">=</span><span class="s2">&quot;NaN&quot;</span><span class="p">,</span>
        <span class="n">formatters</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">float_format</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">sparsify</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">index_names</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">bold_rows</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">column_format</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">longtable</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">escape</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">encoding</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">decimal</span><span class="o">=</span><span class="s2">&quot;.&quot;</span><span class="p">,</span>
        <span class="n">multicolumn</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">multicolumn_format</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">multirow</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Render an object to a LaTeX tabular environment table.</span>

<span class="sd">        Render an object to a tabular environment table. You can splice</span>
<span class="sd">        this into a LaTeX document. Requires \usepackage{booktabs}.</span>

<span class="sd">        .. versionchanged:: 0.20.2</span>
<span class="sd">           Added to Series</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        buf : file descriptor or None</span>
<span class="sd">            Buffer to write to. If None, the output is returned as a string.</span>
<span class="sd">        columns : list of label, optional</span>
<span class="sd">            The subset of columns to write. Writes all columns by default.</span>
<span class="sd">        col_space : int, optional</span>
<span class="sd">            The minimum width of each column.</span>
<span class="sd">        header : bool or list of str, default True</span>
<span class="sd">            Write out the column names. If a list of strings is given,</span>
<span class="sd">            it is assumed to be aliases for the column names.</span>
<span class="sd">        index : bool, default True</span>
<span class="sd">            Write row names (index).</span>
<span class="sd">        na_rep : str, default &#39;NaN&#39;</span>
<span class="sd">            Missing data representation.</span>
<span class="sd">        formatters : list of functions or dict of {str: function}, optional</span>
<span class="sd">            Formatter functions to apply to columns&#39; elements by position or</span>
<span class="sd">            name. The result of each function must be a unicode string.</span>
<span class="sd">            List must be of length equal to the number of columns.</span>
<span class="sd">        float_format : one-parameter function or str, optional, default None</span>
<span class="sd">            Formatter for floating point numbers. For example</span>
<span class="sd">            ``float_format=&quot;%%.2f&quot;`` and ``float_format=&quot;{:0.2f}&quot;.format`` will</span>
<span class="sd">            both result in 0.1234 being formatted as 0.12.</span>
<span class="sd">        sparsify : bool, optional</span>
<span class="sd">            Set to False for a DataFrame with a hierarchical index to print</span>
<span class="sd">            every multiindex key at each row. By default, the value will be</span>
<span class="sd">            read from the config module.</span>
<span class="sd">        index_names : bool, default True</span>
<span class="sd">            Prints the names of the indexes.</span>
<span class="sd">        bold_rows : bool, default False</span>
<span class="sd">            Make the row labels bold in the output.</span>
<span class="sd">        column_format : str, optional</span>
<span class="sd">            The columns format as specified in `LaTeX table format</span>
<span class="sd">            &lt;https://en.wikibooks.org/wiki/LaTeX/Tables&gt;`__ e.g. &#39;rcl&#39; for 3</span>
<span class="sd">            columns. By default, &#39;l&#39; will be used for all columns except</span>
<span class="sd">            columns of numbers, which default to &#39;r&#39;.</span>
<span class="sd">        longtable : bool, optional</span>
<span class="sd">            By default, the value will be read from the pandas config</span>
<span class="sd">            module. Use a longtable environment instead of tabular. Requires</span>
<span class="sd">            adding a \usepackage{longtable} to your LaTeX preamble.</span>
<span class="sd">        escape : bool, optional</span>
<span class="sd">            By default, the value will be read from the pandas config</span>
<span class="sd">            module. When set to False prevents from escaping latex special</span>
<span class="sd">            characters in column names.</span>
<span class="sd">        encoding : str, optional</span>
<span class="sd">            A string representing the encoding to use in the output file,</span>
<span class="sd">            defaults to &#39;utf-8&#39;.</span>
<span class="sd">        decimal : str, default &#39;.&#39;</span>
<span class="sd">            Character recognized as decimal separator, e.g. &#39;,&#39; in Europe.</span>

<span class="sd">            .. versionadded:: 0.18.0</span>
<span class="sd">        multicolumn : bool, default True</span>
<span class="sd">            Use \multicolumn to enhance MultiIndex columns.</span>
<span class="sd">            The default will be read from the config module.</span>

<span class="sd">            .. versionadded:: 0.20.0</span>
<span class="sd">        multicolumn_format : str, default &#39;l&#39;</span>
<span class="sd">            The alignment for multicolumns, similar to `column_format`</span>
<span class="sd">            The default will be read from the config module.</span>

<span class="sd">            .. versionadded:: 0.20.0</span>
<span class="sd">        multirow : bool, default False</span>
<span class="sd">            Use \multirow to enhance MultiIndex rows. Requires adding a</span>
<span class="sd">            \usepackage{multirow} to your LaTeX preamble. Will print</span>
<span class="sd">            centered labels (instead of top-aligned) across the contained</span>
<span class="sd">            rows, separating groups via clines. The default will be read</span>
<span class="sd">            from the pandas config module.</span>

<span class="sd">            .. versionadded:: 0.20.0</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        str or None</span>
<span class="sd">            If buf is None, returns the resulting LateX format as a</span>
<span class="sd">            string. Otherwise returns None.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        DataFrame.to_string : Render a DataFrame to a console-friendly</span>
<span class="sd">            tabular output.</span>
<span class="sd">        DataFrame.to_html : Render a DataFrame as an HTML table.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; df = pd.DataFrame({&#39;name&#39;: [&#39;Raphael&#39;, &#39;Donatello&#39;],</span>
<span class="sd">        ...                    &#39;mask&#39;: [&#39;red&#39;, &#39;purple&#39;],</span>
<span class="sd">        ...                    &#39;weapon&#39;: [&#39;sai&#39;, &#39;bo staff&#39;]})</span>
<span class="sd">        &gt;&gt;&gt; df.to_latex(index=False) # doctest: +NORMALIZE_WHITESPACE</span>
<span class="sd">        &#39;\\begin{tabular}{lll}\n\\toprule\n      name &amp;    mask &amp;    weapon</span>
<span class="sd">        \\\\\n\\midrule\n   Raphael &amp;     red &amp;       sai \\\\\n Donatello &amp;</span>
<span class="sd">         purple &amp;  bo staff \\\\\n\\bottomrule\n\\end{tabular}\n&#39;</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Get defaults from the pandas config</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="bp">self</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">to_frame</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">longtable</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">longtable</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">get_option</span><span class="p">(</span><span class="s2">&quot;display.latex.longtable&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">escape</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">escape</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">get_option</span><span class="p">(</span><span class="s2">&quot;display.latex.escape&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">multicolumn</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">multicolumn</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">get_option</span><span class="p">(</span><span class="s2">&quot;display.latex.multicolumn&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">multicolumn_format</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">multicolumn_format</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">get_option</span><span class="p">(</span><span class="s2">&quot;display.latex.multicolumn_format&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">multirow</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">multirow</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">get_option</span><span class="p">(</span><span class="s2">&quot;display.latex.multirow&quot;</span><span class="p">)</span>

        <span class="n">formatter</span> <span class="o">=</span> <span class="n">DataFrameFormatter</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">buf</span><span class="o">=</span><span class="n">buf</span><span class="p">,</span>
            <span class="n">columns</span><span class="o">=</span><span class="n">columns</span><span class="p">,</span>
            <span class="n">col_space</span><span class="o">=</span><span class="n">col_space</span><span class="p">,</span>
            <span class="n">na_rep</span><span class="o">=</span><span class="n">na_rep</span><span class="p">,</span>
            <span class="n">header</span><span class="o">=</span><span class="n">header</span><span class="p">,</span>
            <span class="n">index</span><span class="o">=</span><span class="n">index</span><span class="p">,</span>
            <span class="n">formatters</span><span class="o">=</span><span class="n">formatters</span><span class="p">,</span>
            <span class="n">float_format</span><span class="o">=</span><span class="n">float_format</span><span class="p">,</span>
            <span class="n">bold_rows</span><span class="o">=</span><span class="n">bold_rows</span><span class="p">,</span>
            <span class="n">sparsify</span><span class="o">=</span><span class="n">sparsify</span><span class="p">,</span>
            <span class="n">index_names</span><span class="o">=</span><span class="n">index_names</span><span class="p">,</span>
            <span class="n">escape</span><span class="o">=</span><span class="n">escape</span><span class="p">,</span>
            <span class="n">decimal</span><span class="o">=</span><span class="n">decimal</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">formatter</span><span class="o">.</span><span class="n">to_latex</span><span class="p">(</span>
            <span class="n">column_format</span><span class="o">=</span><span class="n">column_format</span><span class="p">,</span>
            <span class="n">longtable</span><span class="o">=</span><span class="n">longtable</span><span class="p">,</span>
            <span class="n">encoding</span><span class="o">=</span><span class="n">encoding</span><span class="p">,</span>
            <span class="n">multicolumn</span><span class="o">=</span><span class="n">multicolumn</span><span class="p">,</span>
            <span class="n">multicolumn_format</span><span class="o">=</span><span class="n">multicolumn_format</span><span class="p">,</span>
            <span class="n">multirow</span><span class="o">=</span><span class="n">multirow</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="k">if</span> <span class="n">buf</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">formatter</span><span class="o">.</span><span class="n">buf</span><span class="o">.</span><span class="n">getvalue</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">to_csv</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">path_or_buf</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">sep</span><span class="o">=</span><span class="s2">&quot;,&quot;</span><span class="p">,</span>
        <span class="n">na_rep</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">,</span>
        <span class="n">float_format</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">columns</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">header</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">index</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">index_label</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;w&quot;</span><span class="p">,</span>
        <span class="n">encoding</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">compression</span><span class="o">=</span><span class="s2">&quot;infer&quot;</span><span class="p">,</span>
        <span class="n">quoting</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">quotechar</span><span class="o">=</span><span class="s1">&#39;&quot;&#39;</span><span class="p">,</span>
        <span class="n">line_terminator</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">chunksize</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">date_format</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">doublequote</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">escapechar</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">decimal</span><span class="o">=</span><span class="s2">&quot;.&quot;</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Write object to a comma-separated values (csv) file.</span>

<span class="sd">        .. versionchanged:: 0.24.0</span>
<span class="sd">            The order of arguments for Series was changed.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        path_or_buf : str or file handle, default None</span>
<span class="sd">            File path or object, if None is provided the result is returned as</span>
<span class="sd">            a string.  If a file object is passed it should be opened with</span>
<span class="sd">            `newline=&#39;&#39;`, disabling universal newlines.</span>

<span class="sd">            .. versionchanged:: 0.24.0</span>

<span class="sd">               Was previously named &quot;path&quot; for Series.</span>

<span class="sd">        sep : str, default &#39;,&#39;</span>
<span class="sd">            String of length 1. Field delimiter for the output file.</span>
<span class="sd">        na_rep : str, default &#39;&#39;</span>
<span class="sd">            Missing data representation.</span>
<span class="sd">        float_format : str, default None</span>
<span class="sd">            Format string for floating point numbers.</span>
<span class="sd">        columns : sequence, optional</span>
<span class="sd">            Columns to write.</span>
<span class="sd">        header : bool or list of str, default True</span>
<span class="sd">            Write out the column names. If a list of strings is given it is</span>
<span class="sd">            assumed to be aliases for the column names.</span>

<span class="sd">            .. versionchanged:: 0.24.0</span>

<span class="sd">               Previously defaulted to False for Series.</span>

<span class="sd">        index : bool, default True</span>
<span class="sd">            Write row names (index).</span>
<span class="sd">        index_label : str or sequence, or False, default None</span>
<span class="sd">            Column label for index column(s) if desired. If None is given, and</span>
<span class="sd">            `header` and `index` are True, then the index names are used. A</span>
<span class="sd">            sequence should be given if the object uses MultiIndex. If</span>
<span class="sd">            False do not print fields for index names. Use index_label=False</span>
<span class="sd">            for easier importing in R.</span>
<span class="sd">        mode : str</span>
<span class="sd">            Python write mode, default &#39;w&#39;.</span>
<span class="sd">        encoding : str, optional</span>
<span class="sd">            A string representing the encoding to use in the output file,</span>
<span class="sd">            defaults to &#39;utf-8&#39;.</span>
<span class="sd">        compression : str, default &#39;infer&#39;</span>
<span class="sd">            Compression mode among the following possible values: {&#39;infer&#39;,</span>
<span class="sd">            &#39;gzip&#39;, &#39;bz2&#39;, &#39;zip&#39;, &#39;xz&#39;, None}. If &#39;infer&#39; and `path_or_buf`</span>
<span class="sd">            is path-like, then detect compression from the following</span>
<span class="sd">            extensions: &#39;.gz&#39;, &#39;.bz2&#39;, &#39;.zip&#39; or &#39;.xz&#39;. (otherwise no</span>
<span class="sd">            compression).</span>

<span class="sd">            .. versionchanged:: 0.24.0</span>

<span class="sd">               &#39;infer&#39; option added and set to default.</span>

<span class="sd">        quoting : optional constant from csv module</span>
<span class="sd">            Defaults to csv.QUOTE_MINIMAL. If you have set a `float_format`</span>
<span class="sd">            then floats are converted to strings and thus csv.QUOTE_NONNUMERIC</span>
<span class="sd">            will treat them as non-numeric.</span>
<span class="sd">        quotechar : str, default &#39;\&quot;&#39;</span>
<span class="sd">            String of length 1. Character used to quote fields.</span>
<span class="sd">        line_terminator : str, optional</span>
<span class="sd">            The newline character or character sequence to use in the output</span>
<span class="sd">            file. Defaults to `os.linesep`, which depends on the OS in which</span>
<span class="sd">            this method is called (&#39;\n&#39; for linux, &#39;\r\n&#39; for Windows, i.e.).</span>

<span class="sd">            .. versionchanged:: 0.24.0</span>
<span class="sd">        chunksize : int or None</span>
<span class="sd">            Rows to write at a time.</span>
<span class="sd">        date_format : str, default None</span>
<span class="sd">            Format string for datetime objects.</span>
<span class="sd">        doublequote : bool, default True</span>
<span class="sd">            Control quoting of `quotechar` inside a field.</span>
<span class="sd">        escapechar : str, default None</span>
<span class="sd">            String of length 1. Character used to escape `sep` and `quotechar`</span>
<span class="sd">            when appropriate.</span>
<span class="sd">        decimal : str, default &#39;.&#39;</span>
<span class="sd">            Character recognized as decimal separator. E.g. use &#39;,&#39; for</span>
<span class="sd">            European data.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        None or str</span>
<span class="sd">            If path_or_buf is None, returns the resulting csv format as a</span>
<span class="sd">            string. Otherwise returns None.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        read_csv : Load a CSV file into a DataFrame.</span>
<span class="sd">        to_excel : Write DataFrame to an Excel file.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; df = pd.DataFrame({&#39;name&#39;: [&#39;Raphael&#39;, &#39;Donatello&#39;],</span>
<span class="sd">        ...                    &#39;mask&#39;: [&#39;red&#39;, &#39;purple&#39;],</span>
<span class="sd">        ...                    &#39;weapon&#39;: [&#39;sai&#39;, &#39;bo staff&#39;]})</span>
<span class="sd">        &gt;&gt;&gt; df.to_csv(index=False)</span>
<span class="sd">        &#39;name,mask,weapon\nRaphael,red,sai\nDonatello,purple,bo staff\n&#39;</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">df</span> <span class="o">=</span> <span class="bp">self</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ABCDataFrame</span><span class="p">)</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">to_frame</span><span class="p">()</span>

        <span class="kn">from</span> <span class="nn">pandas.io.formats.csvs</span> <span class="k">import</span> <span class="n">CSVFormatter</span>

        <span class="n">formatter</span> <span class="o">=</span> <span class="n">CSVFormatter</span><span class="p">(</span>
            <span class="n">df</span><span class="p">,</span>
            <span class="n">path_or_buf</span><span class="p">,</span>
            <span class="n">line_terminator</span><span class="o">=</span><span class="n">line_terminator</span><span class="p">,</span>
            <span class="n">sep</span><span class="o">=</span><span class="n">sep</span><span class="p">,</span>
            <span class="n">encoding</span><span class="o">=</span><span class="n">encoding</span><span class="p">,</span>
            <span class="n">compression</span><span class="o">=</span><span class="n">compression</span><span class="p">,</span>
            <span class="n">quoting</span><span class="o">=</span><span class="n">quoting</span><span class="p">,</span>
            <span class="n">na_rep</span><span class="o">=</span><span class="n">na_rep</span><span class="p">,</span>
            <span class="n">float_format</span><span class="o">=</span><span class="n">float_format</span><span class="p">,</span>
            <span class="n">cols</span><span class="o">=</span><span class="n">columns</span><span class="p">,</span>
            <span class="n">header</span><span class="o">=</span><span class="n">header</span><span class="p">,</span>
            <span class="n">index</span><span class="o">=</span><span class="n">index</span><span class="p">,</span>
            <span class="n">index_label</span><span class="o">=</span><span class="n">index_label</span><span class="p">,</span>
            <span class="n">mode</span><span class="o">=</span><span class="n">mode</span><span class="p">,</span>
            <span class="n">chunksize</span><span class="o">=</span><span class="n">chunksize</span><span class="p">,</span>
            <span class="n">quotechar</span><span class="o">=</span><span class="n">quotechar</span><span class="p">,</span>
            <span class="n">date_format</span><span class="o">=</span><span class="n">date_format</span><span class="p">,</span>
            <span class="n">doublequote</span><span class="o">=</span><span class="n">doublequote</span><span class="p">,</span>
            <span class="n">escapechar</span><span class="o">=</span><span class="n">escapechar</span><span class="p">,</span>
            <span class="n">decimal</span><span class="o">=</span><span class="n">decimal</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">formatter</span><span class="o">.</span><span class="n">save</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">path_or_buf</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">formatter</span><span class="o">.</span><span class="n">path_or_buf</span><span class="o">.</span><span class="n">getvalue</span><span class="p">()</span>

    <span class="c1"># ----------------------------------------------------------------------</span>
    <span class="c1"># Fancy Indexing</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">_create_indexer</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">indexer</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Create an indexer like _name in the class.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">_indexer</span> <span class="o">=</span> <span class="n">functools</span><span class="o">.</span><span class="n">partial</span><span class="p">(</span><span class="n">indexer</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>
            <span class="nb">setattr</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="nb">property</span><span class="p">(</span><span class="n">_indexer</span><span class="p">,</span> <span class="n">doc</span><span class="o">=</span><span class="n">indexer</span><span class="o">.</span><span class="vm">__doc__</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">get</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get item from object for given key (ex: DataFrame column).</span>

<span class="sd">        Returns default value if not found.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        key : object</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        value : same type as items contained in object</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
        <span class="k">except</span> <span class="p">(</span><span class="ne">KeyError</span><span class="p">,</span> <span class="ne">ValueError</span><span class="p">,</span> <span class="ne">IndexError</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">default</span>

    <span class="k">def</span> <span class="nf">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">item</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_item_cache</span><span class="p">(</span><span class="n">item</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_get_item_cache</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">item</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the cached item, item represents a label indexer.&quot;&quot;&quot;</span>
        <span class="n">cache</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_item_cache</span>
        <span class="n">res</span> <span class="o">=</span> <span class="n">cache</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">item</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">res</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">values</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">item</span><span class="p">)</span>
            <span class="n">res</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_box_item_values</span><span class="p">(</span><span class="n">item</span><span class="p">,</span> <span class="n">values</span><span class="p">)</span>
            <span class="n">cache</span><span class="p">[</span><span class="n">item</span><span class="p">]</span> <span class="o">=</span> <span class="n">res</span>
            <span class="n">res</span><span class="o">.</span><span class="n">_set_as_cached</span><span class="p">(</span><span class="n">item</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>

            <span class="c1"># for a chain</span>
            <span class="n">res</span><span class="o">.</span><span class="n">_is_copy</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_copy</span>
        <span class="k">return</span> <span class="n">res</span>

    <span class="k">def</span> <span class="nf">_set_as_cached</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">item</span><span class="p">,</span> <span class="n">cacher</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Set the _cacher attribute on the calling object with a weakref to</span>
<span class="sd">        cacher.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_cacher</span> <span class="o">=</span> <span class="p">(</span><span class="n">item</span><span class="p">,</span> <span class="n">weakref</span><span class="o">.</span><span class="n">ref</span><span class="p">(</span><span class="n">cacher</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">_reset_cacher</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Reset the cacher.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;_cacher&quot;</span><span class="p">):</span>
            <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cacher</span>

    <span class="k">def</span> <span class="nf">_iget_item_cache</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">item</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the cached item, item represents a positional indexer.&quot;&quot;&quot;</span>
        <span class="n">ax</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_info_axis</span>
        <span class="k">if</span> <span class="n">ax</span><span class="o">.</span><span class="n">is_unique</span><span class="p">:</span>
            <span class="n">lower</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_item_cache</span><span class="p">(</span><span class="n">ax</span><span class="p">[</span><span class="n">item</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">lower</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">take</span><span class="p">(</span><span class="n">item</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_info_axis_number</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">lower</span>

    <span class="k">def</span> <span class="nf">_box_item_values</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">values</span><span class="p">):</span>
        <span class="k">raise</span> <span class="n">AbstractMethodError</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_maybe_cache_changed</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">item</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;The object has called back to us saying maybe it has changed.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">item</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_is_cached</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return boolean indicating if self is cached or not.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;_cacher&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="nf">_get_cacher</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;return my cacher or None&quot;&quot;&quot;</span>
        <span class="n">cacher</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;_cacher&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">cacher</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">cacher</span> <span class="o">=</span> <span class="n">cacher</span><span class="p">[</span><span class="mi">1</span><span class="p">]()</span>
        <span class="k">return</span> <span class="n">cacher</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_is_view</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return boolean indicating if self is view of another array &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">is_view</span>

    <span class="k">def</span> <span class="nf">_maybe_update_cacher</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">clear</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">verify_is_copy</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        See if we need to update our parent cacher if clear, then clear our</span>
<span class="sd">        cache.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        clear : boolean, default False</span>
<span class="sd">            clear the item cache</span>
<span class="sd">        verify_is_copy : boolean, default True</span>
<span class="sd">            provide is_copy checks</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">cacher</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;_cacher&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">cacher</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">ref</span> <span class="o">=</span> <span class="n">cacher</span><span class="p">[</span><span class="mi">1</span><span class="p">]()</span>

            <span class="c1"># we are trying to reference a dead referant, hence</span>
            <span class="c1"># a copy</span>
            <span class="k">if</span> <span class="n">ref</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cacher</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">ref</span><span class="o">.</span><span class="n">_maybe_cache_changed</span><span class="p">(</span><span class="n">cacher</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="p">)</span>
                <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
                    <span class="k">pass</span>

        <span class="k">if</span> <span class="n">verify_is_copy</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_check_setitem_copy</span><span class="p">(</span><span class="n">stacklevel</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">t</span><span class="o">=</span><span class="s2">&quot;referant&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">clear</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_clear_item_cache</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">_clear_item_cache</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">i</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">i</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_item_cache</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_item_cache</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">_slice</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">slobj</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">kind</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Construct a slice of this container.</span>

<span class="sd">        kind parameter is maintained for compatibility with Series slicing.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">axis</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_block_manager_axis</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span>
        <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_constructor</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">get_slice</span><span class="p">(</span><span class="n">slobj</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">))</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">__finalize__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

        <span class="c1"># this could be a view</span>
        <span class="c1"># but only in a single-dtyped view sliceable case</span>
        <span class="n">is_copy</span> <span class="o">=</span> <span class="n">axis</span> <span class="o">!=</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">result</span><span class="o">.</span><span class="n">_is_view</span>
        <span class="n">result</span><span class="o">.</span><span class="n">_set_is_copy</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="n">is_copy</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">result</span>

    <span class="k">def</span> <span class="nf">_set_item</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_clear_item_cache</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">_set_is_copy</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ref</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">copy</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_is_copy</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">ref</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_is_copy</span> <span class="o">=</span> <span class="n">weakref</span><span class="o">.</span><span class="n">ref</span><span class="p">(</span><span class="n">ref</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_is_copy</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="nf">_check_is_chained_assignment_possible</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Check if we are a view, have a cacher, and are of mixed type.</span>
<span class="sd">        If so, then force a setitem_copy check.</span>

<span class="sd">        Should be called just near setting a value</span>

<span class="sd">        Will return a boolean if it we are a view and are cached, but a</span>
<span class="sd">        single-dtype meaning that the cacher should be updated following</span>
<span class="sd">        setting.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_view</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_cached</span><span class="p">:</span>
            <span class="n">ref</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_cacher</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">ref</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">ref</span><span class="o">.</span><span class="n">_is_mixed_type</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_check_setitem_copy</span><span class="p">(</span><span class="n">stacklevel</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">t</span><span class="o">=</span><span class="s2">&quot;referant&quot;</span><span class="p">,</span> <span class="n">force</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="k">return</span> <span class="kc">True</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_copy</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_check_setitem_copy</span><span class="p">(</span><span class="n">stacklevel</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">t</span><span class="o">=</span><span class="s2">&quot;referant&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="kc">False</span>

    <span class="k">def</span> <span class="nf">_check_setitem_copy</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">stacklevel</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">t</span><span class="o">=</span><span class="s2">&quot;setting&quot;</span><span class="p">,</span> <span class="n">force</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        stacklevel : integer, default 4</span>
<span class="sd">           the level to show of the stack when the error is output</span>
<span class="sd">        t : string, the type of setting error</span>
<span class="sd">        force : boolean, default False</span>
<span class="sd">           if True, then force showing an error</span>

<span class="sd">        validate if we are doing a setitem on a chained copy.</span>

<span class="sd">        If you call this function, be sure to set the stacklevel such that the</span>
<span class="sd">        user will see the error *at the level of setting*</span>

<span class="sd">        It is technically possible to figure out that we are setting on</span>
<span class="sd">        a copy even WITH a multi-dtyped pandas object. In other words, some</span>
<span class="sd">        blocks may be views while other are not. Currently _is_view will ALWAYS</span>
<span class="sd">        return False for multi-blocks to avoid having to handle this case.</span>

<span class="sd">        df = DataFrame(np.arange(0,9), columns=[&#39;count&#39;])</span>
<span class="sd">        df[&#39;group&#39;] = &#39;b&#39;</span>

<span class="sd">        # This technically need not raise SettingWithCopy if both are view</span>
<span class="sd">        # (which is not # generally guaranteed but is usually True.  However,</span>
<span class="sd">        # this is in general not a good practice and we recommend using .loc.</span>
<span class="sd">        df.iloc[0:5][&#39;group&#39;] = &#39;a&#39;</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># return early if the check is not needed</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">force</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_copy</span><span class="p">):</span>
            <span class="k">return</span>

        <span class="n">value</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">get_option</span><span class="p">(</span><span class="s2">&quot;mode.chained_assignment&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">value</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span>

        <span class="c1"># see if the copy is not actually referred; if so, then dissolve</span>
        <span class="c1"># the copy weakref</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_copy</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_is_copy</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="n">r</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_copy</span><span class="p">()</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">gc</span><span class="o">.</span><span class="n">get_referents</span><span class="p">(</span><span class="n">r</span><span class="p">)</span> <span class="ow">or</span> <span class="n">r</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_is_copy</span> <span class="o">=</span> <span class="kc">None</span>
                <span class="k">return</span>

        <span class="c1"># a custom message</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_is_copy</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="n">t</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_copy</span>

        <span class="k">elif</span> <span class="n">t</span> <span class="o">==</span> <span class="s2">&quot;referant&quot;</span><span class="p">:</span>
            <span class="n">t</span> <span class="o">=</span> <span class="p">(</span>
                <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span>
                <span class="s2">&quot;A value is trying to be set on a copy of a slice from a &quot;</span>
                <span class="s2">&quot;DataFrame</span><span class="se">\n\n</span><span class="s2">&quot;</span>
                <span class="s2">&quot;See the caveats in the documentation: &quot;</span>
                <span class="s2">&quot;http://pandas.pydata.org/pandas-docs/stable/user_guide/&quot;</span>
                <span class="s2">&quot;indexing.html#returning-a-view-versus-a-copy&quot;</span>
            <span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="n">t</span> <span class="o">=</span> <span class="p">(</span>
                <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span>
                <span class="s2">&quot;A value is trying to be set on a copy of a slice from a &quot;</span>
                <span class="s2">&quot;DataFrame.</span><span class="se">\n</span><span class="s2">&quot;</span>
                <span class="s2">&quot;Try using .loc[row_indexer,col_indexer] = value &quot;</span>
                <span class="s2">&quot;instead</span><span class="se">\n\n</span><span class="s2">See the caveats in the documentation: &quot;</span>
                <span class="s2">&quot;http://pandas.pydata.org/pandas-docs/stable/user_guide/&quot;</span>
                <span class="s2">&quot;indexing.html#returning-a-view-versus-a-copy&quot;</span>
            <span class="p">)</span>

        <span class="k">if</span> <span class="n">value</span> <span class="o">==</span> <span class="s2">&quot;raise&quot;</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">com</span><span class="o">.</span><span class="n">SettingWithCopyError</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">value</span> <span class="o">==</span> <span class="s2">&quot;warn&quot;</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">com</span><span class="o">.</span><span class="n">SettingWithCopyWarning</span><span class="p">,</span> <span class="n">stacklevel</span><span class="o">=</span><span class="n">stacklevel</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__delitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Delete item</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">deleted</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="n">maybe_shortcut</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">2</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">columns</span><span class="p">,</span> <span class="n">MultiIndex</span><span class="p">):</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">maybe_shortcut</span> <span class="o">=</span> <span class="n">key</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">_engine</span>
            <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
                <span class="k">pass</span>

        <span class="k">if</span> <span class="n">maybe_shortcut</span><span class="p">:</span>
            <span class="c1"># Allow shorthand to delete all columns whose first len(key)</span>
            <span class="c1"># elements match key:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
                <span class="n">key</span> <span class="o">=</span> <span class="p">(</span><span class="n">key</span><span class="p">,)</span>
            <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">col</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)</span> <span class="ow">and</span> <span class="n">col</span><span class="p">[:</span> <span class="nb">len</span><span class="p">(</span><span class="n">key</span><span class="p">)]</span> <span class="o">==</span> <span class="n">key</span><span class="p">:</span>
                    <span class="k">del</span> <span class="bp">self</span><span class="p">[</span><span class="n">col</span><span class="p">]</span>
                    <span class="n">deleted</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">deleted</span><span class="p">:</span>
            <span class="c1"># If the above loop ran and didn&#39;t delete anything because</span>
            <span class="c1"># there was no match, this call should raise the appropriate</span>
            <span class="c1"># exception:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>

        <span class="c1"># delete from the caches</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">_item_cache</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="k">pass</span>

    <span class="k">def</span> <span class="nf">take</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">indices</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">is_copy</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the elements in the given *positional* indices along an axis.</span>

<span class="sd">        This means that we are not indexing according to actual values in</span>
<span class="sd">        the index attribute of the object. We are indexing according to the</span>
<span class="sd">        actual position of the element in the object.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        indices : array-like</span>
<span class="sd">            An array of ints indicating which positions to take.</span>
<span class="sd">        axis : {0 or &#39;index&#39;, 1 or &#39;columns&#39;, None}, default 0</span>
<span class="sd">            The axis on which to select elements. ``0`` means that we are</span>
<span class="sd">            selecting rows, ``1`` means that we are selecting columns.</span>
<span class="sd">        is_copy : bool, default True</span>
<span class="sd">            Whether to return a copy of the original object or not.</span>
<span class="sd">        **kwargs</span>
<span class="sd">            For compatibility with :meth:`numpy.take`. Has no effect on the</span>
<span class="sd">            output.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        taken : same type as caller</span>
<span class="sd">            An array-like containing the elements taken from the object.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        DataFrame.loc : Select a subset of a DataFrame by labels.</span>
<span class="sd">        DataFrame.iloc : Select a subset of a DataFrame by positions.</span>
<span class="sd">        numpy.take : Take elements from an array along an axis.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; df = pd.DataFrame([(&#39;falcon&#39;, &#39;bird&#39;,    389.0),</span>
<span class="sd">        ...                    (&#39;parrot&#39;, &#39;bird&#39;,     24.0),</span>
<span class="sd">        ...                    (&#39;lion&#39;,   &#39;mammal&#39;,   80.5),</span>
<span class="sd">        ...                    (&#39;monkey&#39;, &#39;mammal&#39;, np.nan)],</span>
<span class="sd">        ...                    columns=[&#39;name&#39;, &#39;class&#39;, &#39;max_speed&#39;],</span>
<span class="sd">        ...                    index=[0, 2, 3, 1])</span>
<span class="sd">        &gt;&gt;&gt; df</span>
<span class="sd">             name   class  max_speed</span>
<span class="sd">        0  falcon    bird      389.0</span>
<span class="sd">        2  parrot    bird       24.0</span>
<span class="sd">        3    lion  mammal       80.5</span>
<span class="sd">        1  monkey  mammal        NaN</span>

<span class="sd">        Take elements at positions 0 and 3 along the axis 0 (default).</span>

<span class="sd">        Note how the actual indices selected (0 and 1) do not correspond to</span>
<span class="sd">        our selected indices 0 and 3. That&#39;s because we are selecting the 0th</span>
<span class="sd">        and 3rd rows, not rows whose indices equal 0 and 3.</span>

<span class="sd">        &gt;&gt;&gt; df.take([0, 3])</span>
<span class="sd">             name   class  max_speed</span>
<span class="sd">        0  falcon    bird      389.0</span>
<span class="sd">        1  monkey  mammal        NaN</span>

<span class="sd">        Take elements at indices 1 and 2 along the axis 1 (column selection).</span>

<span class="sd">        &gt;&gt;&gt; df.take([1, 2], axis=1)</span>
<span class="sd">            class  max_speed</span>
<span class="sd">        0    bird      389.0</span>
<span class="sd">        2    bird       24.0</span>
<span class="sd">        3  mammal       80.5</span>
<span class="sd">        1  mammal        NaN</span>

<span class="sd">        We may take elements using negative integers for positive indices,</span>
<span class="sd">        starting from the end of the object, just like with Python lists.</span>

<span class="sd">        &gt;&gt;&gt; df.take([-1, -2])</span>
<span class="sd">             name   class  max_speed</span>
<span class="sd">        1  monkey  mammal        NaN</span>
<span class="sd">        3    lion  mammal       80.5</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">nv</span><span class="o">.</span><span class="n">validate_take</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(),</span> <span class="n">kwargs</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_consolidate_inplace</span><span class="p">()</span>

        <span class="n">new_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">take</span><span class="p">(</span>
            <span class="n">indices</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_get_block_manager_axis</span><span class="p">(</span><span class="n">axis</span><span class="p">),</span> <span class="n">verify</span><span class="o">=</span><span class="kc">True</span>
        <span class="p">)</span>
        <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_constructor</span><span class="p">(</span><span class="n">new_data</span><span class="p">)</span><span class="o">.</span><span class="n">__finalize__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

        <span class="c1"># Maybe set copy if we didn&#39;t actually change the index.</span>
        <span class="k">if</span> <span class="n">is_copy</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">result</span><span class="o">.</span><span class="n">_get_axis</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span><span class="o">.</span><span class="n">equals</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_get_axis</span><span class="p">(</span><span class="n">axis</span><span class="p">)):</span>
                <span class="n">result</span><span class="o">.</span><span class="n">_set_is_copy</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">result</span>

    <span class="k">def</span> <span class="nf">xs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">level</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">drop_level</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return cross-section from the Series/DataFrame.</span>

<span class="sd">        This method takes a `key` argument to select data at a particular</span>
<span class="sd">        level of a MultiIndex.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        key : label or tuple of label</span>
<span class="sd">            Label contained in the index, or partially in a MultiIndex.</span>
<span class="sd">        axis : {0 or &#39;index&#39;, 1 or &#39;columns&#39;}, default 0</span>
<span class="sd">            Axis to retrieve cross-section on.</span>
<span class="sd">        level : object, defaults to first n levels (n=1 or len(key))</span>
<span class="sd">            In case of a key partially contained in a MultiIndex, indicate</span>
<span class="sd">            which levels are used. Levels can be referred by label or position.</span>
<span class="sd">        drop_level : bool, default True</span>
<span class="sd">            If False, returns object with same levels as self.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Series or DataFrame</span>
<span class="sd">            Cross-section from the original Series or DataFrame</span>
<span class="sd">            corresponding to the selected index levels.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        DataFrame.loc : Access a group of rows and columns</span>
<span class="sd">            by label(s) or a boolean array.</span>
<span class="sd">        DataFrame.iloc : Purely integer-location based indexing</span>
<span class="sd">            for selection by position.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        `xs` can not be used to set values.</span>

<span class="sd">        MultiIndex Slicers is a generic way to get/set values on</span>
<span class="sd">        any level or levels.</span>
<span class="sd">        It is a superset of `xs` functionality, see</span>
<span class="sd">        :ref:`MultiIndex Slicers &lt;advanced.mi_slicers&gt;`.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; d = {&#39;num_legs&#39;: [4, 4, 2, 2],</span>
<span class="sd">        ...      &#39;num_wings&#39;: [0, 0, 2, 2],</span>
<span class="sd">        ...      &#39;class&#39;: [&#39;mammal&#39;, &#39;mammal&#39;, &#39;mammal&#39;, &#39;bird&#39;],</span>
<span class="sd">        ...      &#39;animal&#39;: [&#39;cat&#39;, &#39;dog&#39;, &#39;bat&#39;, &#39;penguin&#39;],</span>
<span class="sd">        ...      &#39;locomotion&#39;: [&#39;walks&#39;, &#39;walks&#39;, &#39;flies&#39;, &#39;walks&#39;]}</span>
<span class="sd">        &gt;&gt;&gt; df = pd.DataFrame(data=d)</span>
<span class="sd">        &gt;&gt;&gt; df = df.set_index([&#39;class&#39;, &#39;animal&#39;, &#39;locomotion&#39;])</span>
<span class="sd">        &gt;&gt;&gt; df</span>
<span class="sd">                                   num_legs  num_wings</span>
<span class="sd">        class  animal  locomotion</span>
<span class="sd">        mammal cat     walks              4          0</span>
<span class="sd">               dog     walks              4          0</span>
<span class="sd">               bat     flies              2          2</span>
<span class="sd">        bird   penguin walks              2          2</span>

<span class="sd">        Get values at specified index</span>

<span class="sd">        &gt;&gt;&gt; df.xs(&#39;mammal&#39;)</span>
<span class="sd">                           num_legs  num_wings</span>
<span class="sd">        animal locomotion</span>
<span class="sd">        cat    walks              4          0</span>
<span class="sd">        dog    walks              4          0</span>
<span class="sd">        bat    flies              2          2</span>

<span class="sd">        Get values at several indexes</span>

<span class="sd">        &gt;&gt;&gt; df.xs((&#39;mammal&#39;, &#39;dog&#39;))</span>
<span class="sd">                    num_legs  num_wings</span>
<span class="sd">        locomotion</span>
<span class="sd">        walks              4          0</span>

<span class="sd">        Get values at specified index and level</span>

<span class="sd">        &gt;&gt;&gt; df.xs(&#39;cat&#39;, level=1)</span>
<span class="sd">                           num_legs  num_wings</span>
<span class="sd">        class  locomotion</span>
<span class="sd">        mammal walks              4          0</span>

<span class="sd">        Get values at several indexes and levels</span>

<span class="sd">        &gt;&gt;&gt; df.xs((&#39;bird&#39;, &#39;walks&#39;),</span>
<span class="sd">        ...       level=[0, &#39;locomotion&#39;])</span>
<span class="sd">                 num_legs  num_wings</span>
<span class="sd">        animal</span>
<span class="sd">        penguin         2          2</span>

<span class="sd">        Get values at specified column and axis</span>

<span class="sd">        &gt;&gt;&gt; df.xs(&#39;num_wings&#39;, axis=1)</span>
<span class="sd">        class   animal   locomotion</span>
<span class="sd">        mammal  cat      walks         0</span>
<span class="sd">                dog      walks         0</span>
<span class="sd">                bat      flies         2</span>
<span class="sd">        bird    penguin  walks         2</span>
<span class="sd">        Name: num_wings, dtype: int64</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">axis</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_axis_number</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span>
        <span class="n">labels</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_axis</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">level</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">loc</span><span class="p">,</span> <span class="n">new_ax</span> <span class="o">=</span> <span class="n">labels</span><span class="o">.</span><span class="n">get_loc_level</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">level</span><span class="o">=</span><span class="n">level</span><span class="p">,</span> <span class="n">drop_level</span><span class="o">=</span><span class="n">drop_level</span><span class="p">)</span>

            <span class="c1"># create the tuple of the indexer</span>
            <span class="n">indexer</span> <span class="o">=</span> <span class="p">[</span><span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">)]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">ndim</span>
            <span class="n">indexer</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="n">loc</span>
            <span class="n">indexer</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">indexer</span><span class="p">)</span>

            <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">indexer</span><span class="p">]</span>
            <span class="nb">setattr</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">result</span><span class="o">.</span><span class="n">_get_axis_name</span><span class="p">(</span><span class="n">axis</span><span class="p">),</span> <span class="n">new_ax</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">result</span>

        <span class="k">if</span> <span class="n">axis</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_consolidate_inplace</span><span class="p">()</span>

        <span class="n">index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">index</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">MultiIndex</span><span class="p">):</span>
            <span class="n">loc</span><span class="p">,</span> <span class="n">new_index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">get_loc_level</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">drop_level</span><span class="o">=</span><span class="n">drop_level</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">loc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">get_loc</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>

            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">loc</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">loc</span><span class="o">.</span><span class="n">dtype</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">bool_</span><span class="p">:</span>
                    <span class="n">inds</span><span class="p">,</span> <span class="o">=</span> <span class="n">loc</span><span class="o">.</span><span class="n">nonzero</span><span class="p">()</span>
                    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">take</span><span class="p">(</span><span class="n">inds</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">take</span><span class="p">(</span><span class="n">loc</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span>

            <span class="k">if</span> <span class="ow">not</span> <span class="n">is_scalar</span><span class="p">(</span><span class="n">loc</span><span class="p">):</span>
                <span class="n">new_index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="p">[</span><span class="n">loc</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">is_scalar</span><span class="p">(</span><span class="n">loc</span><span class="p">):</span>
            <span class="n">new_values</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">fast_xs</span><span class="p">(</span><span class="n">loc</span><span class="p">)</span>

            <span class="c1"># may need to box a datelike-scalar</span>
            <span class="c1">#</span>
            <span class="c1"># if we encounter an array-like and we only have 1 dim</span>
            <span class="c1"># that means that their are list/ndarrays inside the Series!</span>
            <span class="c1"># so just return them (GH 6394)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">is_list_like</span><span class="p">(</span><span class="n">new_values</span><span class="p">)</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">com</span><span class="o">.</span><span class="n">maybe_box_datetimelike</span><span class="p">(</span><span class="n">new_values</span><span class="p">)</span>

            <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_constructor_sliced</span><span class="p">(</span>
                <span class="n">new_values</span><span class="p">,</span>
                <span class="n">index</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">columns</span><span class="p">,</span>
                <span class="n">name</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="p">[</span><span class="n">loc</span><span class="p">],</span>
                <span class="n">dtype</span><span class="o">=</span><span class="n">new_values</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span>
            <span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">loc</span><span class="p">]</span>
            <span class="n">result</span><span class="o">.</span><span class="n">index</span> <span class="o">=</span> <span class="n">new_index</span>

        <span class="c1"># this could be a view</span>
        <span class="c1"># but only in a single-dtyped view sliceable case</span>
        <span class="n">result</span><span class="o">.</span><span class="n">_set_is_copy</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="ow">not</span> <span class="n">result</span><span class="o">.</span><span class="n">_is_view</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">result</span>

    <span class="n">_xs</span> <span class="o">=</span> <span class="n">xs</span>  <span class="c1"># type: Callable</span>

    <span class="k">def</span> <span class="nf">reindex_like</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">limit</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">tolerance</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return an object with matching indices as other object.</span>

<span class="sd">        Conform the object to the same index on all axes. Optional</span>
<span class="sd">        filling logic, placing NaN in locations having no value</span>
<span class="sd">        in the previous index. A new object is produced unless the</span>
<span class="sd">        new index is equivalent to the current one and copy=False.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        other : Object of the same data type</span>
<span class="sd">            Its row and column indices are used to define the new indices</span>
<span class="sd">            of this object.</span>
<span class="sd">        method : {None, &#39;backfill&#39;/&#39;bfill&#39;, &#39;pad&#39;/&#39;ffill&#39;, &#39;nearest&#39;}</span>
<span class="sd">            Method to use for filling holes in reindexed DataFrame.</span>
<span class="sd">            Please note: this is only applicable to DataFrames/Series with a</span>
<span class="sd">            monotonically increasing/decreasing index.</span>

<span class="sd">            * None (default): don&#39;t fill gaps</span>
<span class="sd">            * pad / ffill: propagate last valid observation forward to next</span>
<span class="sd">              valid</span>
<span class="sd">            * backfill / bfill: use next valid observation to fill gap</span>
<span class="sd">            * nearest: use nearest valid observations to fill gap</span>

<span class="sd">        copy : bool, default True</span>
<span class="sd">            Return a new object, even if the passed indexes are the same.</span>
<span class="sd">        limit : int, default None</span>
<span class="sd">            Maximum number of consecutive labels to fill for inexact matches.</span>
<span class="sd">        tolerance : optional</span>
<span class="sd">            Maximum distance between original and new labels for inexact</span>
<span class="sd">            matches. The values of the index at the matching locations most</span>
<span class="sd">            satisfy the equation ``abs(index[indexer] - target) &lt;= tolerance``.</span>

<span class="sd">            Tolerance may be a scalar value, which applies the same tolerance</span>
<span class="sd">            to all values, or list-like, which applies variable tolerance per</span>
<span class="sd">            element. List-like includes list, tuple, array, Series, and must be</span>
<span class="sd">            the same size as the index and its dtype must exactly match the</span>
<span class="sd">            index&#39;s type.</span>

<span class="sd">            .. versionadded:: 0.21.0 (list-like tolerance)</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Series or DataFrame</span>
<span class="sd">            Same type as caller, but with changed indices on each axis.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        DataFrame.set_index : Set row labels.</span>
<span class="sd">        DataFrame.reset_index : Remove row labels or move them to new columns.</span>
<span class="sd">        DataFrame.reindex : Change to new indices or expand indices.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        Same as calling</span>
<span class="sd">        ``.reindex(index=other.index, columns=other.columns,...)``.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; df1 = pd.DataFrame([[24.3, 75.7, &#39;high&#39;],</span>
<span class="sd">        ...                     [31, 87.8, &#39;high&#39;],</span>
<span class="sd">        ...                     [22, 71.6, &#39;medium&#39;],</span>
<span class="sd">        ...                     [35, 95, &#39;medium&#39;]],</span>
<span class="sd">        ...     columns=[&#39;temp_celsius&#39;, &#39;temp_fahrenheit&#39;, &#39;windspeed&#39;],</span>
<span class="sd">        ...     index=pd.date_range(start=&#39;2014-02-12&#39;,</span>
<span class="sd">        ...                         end=&#39;2014-02-15&#39;, freq=&#39;D&#39;))</span>

<span class="sd">        &gt;&gt;&gt; df1</span>
<span class="sd">                    temp_celsius  temp_fahrenheit windspeed</span>
<span class="sd">        2014-02-12          24.3             75.7      high</span>
<span class="sd">        2014-02-13          31.0             87.8      high</span>
<span class="sd">        2014-02-14          22.0             71.6    medium</span>
<span class="sd">        2014-02-15          35.0             95.0    medium</span>

<span class="sd">        &gt;&gt;&gt; df2 = pd.DataFrame([[28, &#39;low&#39;],</span>
<span class="sd">        ...                     [30, &#39;low&#39;],</span>
<span class="sd">        ...                     [35.1, &#39;medium&#39;]],</span>
<span class="sd">        ...     columns=[&#39;temp_celsius&#39;, &#39;windspeed&#39;],</span>
<span class="sd">        ...     index=pd.DatetimeIndex([&#39;2014-02-12&#39;, &#39;2014-02-13&#39;,</span>
<span class="sd">        ...                             &#39;2014-02-15&#39;]))</span>

<span class="sd">        &gt;&gt;&gt; df2</span>
<span class="sd">                    temp_celsius windspeed</span>
<span class="sd">        2014-02-12          28.0       low</span>
<span class="sd">        2014-02-13          30.0       low</span>
<span class="sd">        2014-02-15          35.1    medium</span>

<span class="sd">        &gt;&gt;&gt; df2.reindex_like(df1)</span>
<span class="sd">                    temp_celsius  temp_fahrenheit windspeed</span>
<span class="sd">        2014-02-12          28.0              NaN       low</span>
<span class="sd">        2014-02-13          30.0              NaN       low</span>
<span class="sd">        2014-02-14           NaN              NaN       NaN</span>
<span class="sd">        2014-02-15          35.1              NaN    medium</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">d</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">_construct_axes_dict</span><span class="p">(</span>
            <span class="n">axes</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_AXIS_ORDERS</span><span class="p">,</span>
            <span class="n">method</span><span class="o">=</span><span class="n">method</span><span class="p">,</span>
            <span class="n">copy</span><span class="o">=</span><span class="n">copy</span><span class="p">,</span>
            <span class="n">limit</span><span class="o">=</span><span class="n">limit</span><span class="p">,</span>
            <span class="n">tolerance</span><span class="o">=</span><span class="n">tolerance</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">reindex</span><span class="p">(</span><span class="o">**</span><span class="n">d</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">drop</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">labels</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
        <span class="n">index</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">columns</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">level</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">inplace</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">errors</span><span class="o">=</span><span class="s2">&quot;raise&quot;</span><span class="p">,</span>
    <span class="p">):</span>

        <span class="n">inplace</span> <span class="o">=</span> <span class="n">validate_bool_kwarg</span><span class="p">(</span><span class="n">inplace</span><span class="p">,</span> <span class="s2">&quot;inplace&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">labels</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">index</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">columns</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;Cannot specify both &#39;labels&#39; and &quot;</span> <span class="s2">&quot;&#39;index&#39;/&#39;columns&#39;&quot;</span>
                <span class="p">)</span>
            <span class="n">axis_name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_axis_name</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span>
            <span class="n">axes</span> <span class="o">=</span> <span class="p">{</span><span class="n">axis_name</span><span class="p">:</span> <span class="n">labels</span><span class="p">}</span>
        <span class="k">elif</span> <span class="n">index</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">columns</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">axes</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_construct_axes_from_arguments</span><span class="p">((</span><span class="n">index</span><span class="p">,</span> <span class="n">columns</span><span class="p">),</span> <span class="p">{})</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Need to specify at least one of &#39;labels&#39;, &quot;</span> <span class="s2">&quot;&#39;index&#39; or &#39;columns&#39;&quot;</span>
            <span class="p">)</span>

        <span class="n">obj</span> <span class="o">=</span> <span class="bp">self</span>

        <span class="k">for</span> <span class="n">axis</span><span class="p">,</span> <span class="n">labels</span> <span class="ow">in</span> <span class="n">axes</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">labels</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">obj</span> <span class="o">=</span> <span class="n">obj</span><span class="o">.</span><span class="n">_drop_axis</span><span class="p">(</span><span class="n">labels</span><span class="p">,</span> <span class="n">axis</span><span class="p">,</span> <span class="n">level</span><span class="o">=</span><span class="n">level</span><span class="p">,</span> <span class="n">errors</span><span class="o">=</span><span class="n">errors</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">inplace</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_update_inplace</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">obj</span>

    <span class="k">def</span> <span class="nf">_drop_axis</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">labels</span><span class="p">,</span> <span class="n">axis</span><span class="p">,</span> <span class="n">level</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">errors</span><span class="o">=</span><span class="s2">&quot;raise&quot;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Drop labels from specified axis. Used in the ``drop`` method</span>
<span class="sd">        internally.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        labels : single label or list-like</span>
<span class="sd">        axis : int or axis name</span>
<span class="sd">        level : int or level name, default None</span>
<span class="sd">            For MultiIndex</span>
<span class="sd">        errors : {&#39;ignore&#39;, &#39;raise&#39;}, default &#39;raise&#39;</span>
<span class="sd">            If &#39;ignore&#39;, suppress error and existing labels are dropped.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">axis</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_axis_number</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span>
        <span class="n">axis_name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_axis_name</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span>
        <span class="n">axis</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_axis</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">axis</span><span class="o">.</span><span class="n">is_unique</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">level</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">axis</span><span class="p">,</span> <span class="n">MultiIndex</span><span class="p">):</span>
                    <span class="k">raise</span> <span class="ne">AssertionError</span><span class="p">(</span><span class="s2">&quot;axis must be a MultiIndex&quot;</span><span class="p">)</span>
                <span class="n">new_axis</span> <span class="o">=</span> <span class="n">axis</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="n">labels</span><span class="p">,</span> <span class="n">level</span><span class="o">=</span><span class="n">level</span><span class="p">,</span> <span class="n">errors</span><span class="o">=</span><span class="n">errors</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">new_axis</span> <span class="o">=</span> <span class="n">axis</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="n">labels</span><span class="p">,</span> <span class="n">errors</span><span class="o">=</span><span class="n">errors</span><span class="p">)</span>
            <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">reindex</span><span class="p">(</span><span class="o">**</span><span class="p">{</span><span class="n">axis_name</span><span class="p">:</span> <span class="n">new_axis</span><span class="p">})</span>

        <span class="c1"># Case for non-unique axis</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">labels</span> <span class="o">=</span> <span class="n">ensure_object</span><span class="p">(</span><span class="n">com</span><span class="o">.</span><span class="n">index_labels_to_array</span><span class="p">(</span><span class="n">labels</span><span class="p">))</span>
            <span class="k">if</span> <span class="n">level</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">axis</span><span class="p">,</span> <span class="n">MultiIndex</span><span class="p">):</span>
                    <span class="k">raise</span> <span class="ne">AssertionError</span><span class="p">(</span><span class="s2">&quot;axis must be a MultiIndex&quot;</span><span class="p">)</span>
                <span class="n">indexer</span> <span class="o">=</span> <span class="o">~</span><span class="n">axis</span><span class="o">.</span><span class="n">get_level_values</span><span class="p">(</span><span class="n">level</span><span class="p">)</span><span class="o">.</span><span class="n">isin</span><span class="p">(</span><span class="n">labels</span><span class="p">)</span>

                <span class="c1"># GH 18561 MultiIndex.drop should raise if label is absent</span>
                <span class="k">if</span> <span class="n">errors</span> <span class="o">==</span> <span class="s2">&quot;raise&quot;</span> <span class="ow">and</span> <span class="n">indexer</span><span class="o">.</span><span class="n">all</span><span class="p">():</span>
                    <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">{}</span><span class="s2"> not found in axis&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">labels</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">indexer</span> <span class="o">=</span> <span class="o">~</span><span class="n">axis</span><span class="o">.</span><span class="n">isin</span><span class="p">(</span><span class="n">labels</span><span class="p">)</span>
                <span class="c1"># Check if label doesn&#39;t exist along axis</span>
                <span class="n">labels_missing</span> <span class="o">=</span> <span class="p">(</span><span class="n">axis</span><span class="o">.</span><span class="n">get_indexer_for</span><span class="p">(</span><span class="n">labels</span><span class="p">)</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">()</span>
                <span class="k">if</span> <span class="n">errors</span> <span class="o">==</span> <span class="s2">&quot;raise&quot;</span> <span class="ow">and</span> <span class="n">labels_missing</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">{}</span><span class="s2"> not found in axis&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">labels</span><span class="p">))</span>

            <span class="n">slicer</span> <span class="o">=</span> <span class="p">[</span><span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">)]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">ndim</span>
            <span class="n">slicer</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_get_axis_number</span><span class="p">(</span><span class="n">axis_name</span><span class="p">)]</span> <span class="o">=</span> <span class="n">indexer</span>

            <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">slicer</span><span class="p">)]</span>

        <span class="k">return</span> <span class="n">result</span>

    <span class="k">def</span> <span class="nf">_update_inplace</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">result</span><span class="p">,</span> <span class="n">verify_is_copy</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Replace self internals with result.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        verify_is_copy : boolean, default True</span>
<span class="sd">            provide is_copy checks</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># NOTE: This does *not* call __finalize__ and that&#39;s an explicit</span>
        <span class="c1"># decision that we may revisit in the future.</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_reset_cache</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_clear_item_cache</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_data</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="s2">&quot;_data&quot;</span><span class="p">,</span> <span class="n">result</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_maybe_update_cacher</span><span class="p">(</span><span class="n">verify_is_copy</span><span class="o">=</span><span class="n">verify_is_copy</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">add_prefix</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">prefix</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Prefix labels with string `prefix`.</span>

<span class="sd">        For Series, the row labels are prefixed.</span>
<span class="sd">        For DataFrame, the column labels are prefixed.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        prefix : str</span>
<span class="sd">            The string to add before each label.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Series or DataFrame</span>
<span class="sd">            New Series or DataFrame with updated labels.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        Series.add_suffix: Suffix row labels with string `suffix`.</span>
<span class="sd">        DataFrame.add_suffix: Suffix column labels with string `suffix`.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; s = pd.Series([1, 2, 3, 4])</span>
<span class="sd">        &gt;&gt;&gt; s</span>
<span class="sd">        0    1</span>
<span class="sd">        1    2</span>
<span class="sd">        2    3</span>
<span class="sd">        3    4</span>
<span class="sd">        dtype: int64</span>

<span class="sd">        &gt;&gt;&gt; s.add_prefix(&#39;item_&#39;)</span>
<span class="sd">        item_0    1</span>
<span class="sd">        item_1    2</span>
<span class="sd">        item_2    3</span>
<span class="sd">        item_3    4</span>
<span class="sd">        dtype: int64</span>

<span class="sd">        &gt;&gt;&gt; df = pd.DataFrame({&#39;A&#39;: [1, 2, 3, 4],  &#39;B&#39;: [3, 4, 5, 6]})</span>
<span class="sd">        &gt;&gt;&gt; df</span>
<span class="sd">           A  B</span>
<span class="sd">        0  1  3</span>
<span class="sd">        1  2  4</span>
<span class="sd">        2  3  5</span>
<span class="sd">        3  4  6</span>

<span class="sd">        &gt;&gt;&gt; df.add_prefix(&#39;col_&#39;)</span>
<span class="sd">             col_A  col_B</span>
<span class="sd">        0       1       3</span>
<span class="sd">        1       2       4</span>
<span class="sd">        2       3       5</span>
<span class="sd">        3       4       6</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">f</span> <span class="o">=</span> <span class="n">functools</span><span class="o">.</span><span class="n">partial</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">{prefix}{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">,</span> <span class="n">prefix</span><span class="o">=</span><span class="n">prefix</span><span class="p">)</span>

        <span class="n">mapper</span> <span class="o">=</span> <span class="p">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_info_axis_name</span><span class="p">:</span> <span class="n">f</span><span class="p">}</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="o">**</span><span class="n">mapper</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">add_suffix</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">suffix</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Suffix labels with string `suffix`.</span>

<span class="sd">        For Series, the row labels are suffixed.</span>
<span class="sd">        For DataFrame, the column labels are suffixed.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        suffix : str</span>
<span class="sd">            The string to add after each label.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Series or DataFrame</span>
<span class="sd">            New Series or DataFrame with updated labels.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        Series.add_prefix: Prefix row labels with string `prefix`.</span>
<span class="sd">        DataFrame.add_prefix: Prefix column labels with string `prefix`.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; s = pd.Series([1, 2, 3, 4])</span>
<span class="sd">        &gt;&gt;&gt; s</span>
<span class="sd">        0    1</span>
<span class="sd">        1    2</span>
<span class="sd">        2    3</span>
<span class="sd">        3    4</span>
<span class="sd">        dtype: int64</span>

<span class="sd">        &gt;&gt;&gt; s.add_suffix(&#39;_item&#39;)</span>
<span class="sd">        0_item    1</span>
<span class="sd">        1_item    2</span>
<span class="sd">        2_item    3</span>
<span class="sd">        3_item    4</span>
<span class="sd">        dtype: int64</span>

<span class="sd">        &gt;&gt;&gt; df = pd.DataFrame({&#39;A&#39;: [1, 2, 3, 4],  &#39;B&#39;: [3, 4, 5, 6]})</span>
<span class="sd">        &gt;&gt;&gt; df</span>
<span class="sd">           A  B</span>
<span class="sd">        0  1  3</span>
<span class="sd">        1  2  4</span>
<span class="sd">        2  3  5</span>
<span class="sd">        3  4  6</span>

<span class="sd">        &gt;&gt;&gt; df.add_suffix(&#39;_col&#39;)</span>
<span class="sd">             A_col  B_col</span>
<span class="sd">        0       1       3</span>
<span class="sd">        1       2       4</span>
<span class="sd">        2       3       5</span>
<span class="sd">        3       4       6</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">f</span> <span class="o">=</span> <span class="n">functools</span><span class="o">.</span><span class="n">partial</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">{}{suffix}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">,</span> <span class="n">suffix</span><span class="o">=</span><span class="n">suffix</span><span class="p">)</span>

        <span class="n">mapper</span> <span class="o">=</span> <span class="p">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_info_axis_name</span><span class="p">:</span> <span class="n">f</span><span class="p">}</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="o">**</span><span class="n">mapper</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">sort_values</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">by</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
        <span class="n">ascending</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">inplace</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">kind</span><span class="o">=</span><span class="s2">&quot;quicksort&quot;</span><span class="p">,</span>
        <span class="n">na_position</span><span class="o">=</span><span class="s2">&quot;last&quot;</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Sort by the values along either axis.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------%(optional_by)s</span>
<span class="sd">        axis : %(axes_single_arg)s, default 0</span>
<span class="sd">             Axis to be sorted.</span>
<span class="sd">        ascending : bool or list of bool, default True</span>
<span class="sd">             Sort ascending vs. descending. Specify list for multiple sort</span>
<span class="sd">             orders.  If this is a list of bools, must match the length of</span>
<span class="sd">             the by.</span>
<span class="sd">        inplace : bool, default False</span>
<span class="sd">             If True, perform operation in-place.</span>
<span class="sd">        kind : {&#39;quicksort&#39;, &#39;mergesort&#39;, &#39;heapsort&#39;}, default &#39;quicksort&#39;</span>
<span class="sd">             Choice of sorting algorithm. See also ndarray.np.sort for more</span>
<span class="sd">             information.  `mergesort` is the only stable algorithm. For</span>
<span class="sd">             DataFrames, this option is only applied when sorting on a single</span>
<span class="sd">             column or label.</span>
<span class="sd">        na_position : {&#39;first&#39;, &#39;last&#39;}, default &#39;last&#39;</span>
<span class="sd">             Puts NaNs at the beginning if `first`; `last` puts NaNs at the</span>
<span class="sd">             end.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        sorted_obj : DataFrame or None</span>
<span class="sd">            DataFrame with sorted values if inplace=False, None otherwise.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; df = pd.DataFrame({</span>
<span class="sd">        ...     &#39;col1&#39;: [&#39;A&#39;, &#39;A&#39;, &#39;B&#39;, np.nan, &#39;D&#39;, &#39;C&#39;],</span>
<span class="sd">        ...     &#39;col2&#39;: [2, 1, 9, 8, 7, 4],</span>
<span class="sd">        ...     &#39;col3&#39;: [0, 1, 9, 4, 2, 3],</span>
<span class="sd">        ... })</span>
<span class="sd">        &gt;&gt;&gt; df</span>
<span class="sd">            col1 col2 col3</span>
<span class="sd">        0   A    2    0</span>
<span class="sd">        1   A    1    1</span>
<span class="sd">        2   B    9    9</span>
<span class="sd">        3   NaN  8    4</span>
<span class="sd">        4   D    7    2</span>
<span class="sd">        5   C    4    3</span>

<span class="sd">        Sort by col1</span>

<span class="sd">        &gt;&gt;&gt; df.sort_values(by=[&#39;col1&#39;])</span>
<span class="sd">            col1 col2 col3</span>
<span class="sd">        0   A    2    0</span>
<span class="sd">        1   A    1    1</span>
<span class="sd">        2   B    9    9</span>
<span class="sd">        5   C    4    3</span>
<span class="sd">        4   D    7    2</span>
<span class="sd">        3   NaN  8    4</span>

<span class="sd">        Sort by multiple columns</span>

<span class="sd">        &gt;&gt;&gt; df.sort_values(by=[&#39;col1&#39;, &#39;col2&#39;])</span>
<span class="sd">            col1 col2 col3</span>
<span class="sd">        1   A    1    1</span>
<span class="sd">        0   A    2    0</span>
<span class="sd">        2   B    9    9</span>
<span class="sd">        5   C    4    3</span>
<span class="sd">        4   D    7    2</span>
<span class="sd">        3   NaN  8    4</span>

<span class="sd">        Sort Descending</span>

<span class="sd">        &gt;&gt;&gt; df.sort_values(by=&#39;col1&#39;, ascending=False)</span>
<span class="sd">            col1 col2 col3</span>
<span class="sd">        4   D    7    2</span>
<span class="sd">        5   C    4    3</span>
<span class="sd">        2   B    9    9</span>
<span class="sd">        0   A    2    0</span>
<span class="sd">        1   A    1    1</span>
<span class="sd">        3   NaN  8    4</span>

<span class="sd">        Putting NAs first</span>

<span class="sd">        &gt;&gt;&gt; df.sort_values(by=&#39;col1&#39;, ascending=False, na_position=&#39;first&#39;)</span>
<span class="sd">            col1 col2 col3</span>
<span class="sd">        3   NaN  8    4</span>
<span class="sd">        4   D    7    2</span>
<span class="sd">        5   C    4    3</span>
<span class="sd">        2   B    9    9</span>
<span class="sd">        0   A    2    0</span>
<span class="sd">        1   A    1    1</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="n">AbstractMethodError</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">sort_index</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
        <span class="n">level</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">ascending</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">inplace</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">kind</span><span class="o">=</span><span class="s2">&quot;quicksort&quot;</span><span class="p">,</span>
        <span class="n">na_position</span><span class="o">=</span><span class="s2">&quot;last&quot;</span><span class="p">,</span>
        <span class="n">sort_remaining</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Sort object by labels (along an axis).</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        axis : {0 or &#39;index&#39;, 1 or &#39;columns&#39;}, default 0</span>
<span class="sd">            The axis along which to sort.  The value 0 identifies the rows,</span>
<span class="sd">            and 1 identifies the columns.</span>
<span class="sd">        level : int or level name or list of ints or list of level names</span>
<span class="sd">            If not None, sort on values in specified index level(s).</span>
<span class="sd">        ascending : bool, default True</span>
<span class="sd">            Sort ascending vs. descending.</span>
<span class="sd">        inplace : bool, default False</span>
<span class="sd">            If True, perform operation in-place.</span>
<span class="sd">        kind : {&#39;quicksort&#39;, &#39;mergesort&#39;, &#39;heapsort&#39;}, default &#39;quicksort&#39;</span>
<span class="sd">            Choice of sorting algorithm. See also ndarray.np.sort for more</span>
<span class="sd">            information.  `mergesort` is the only stable algorithm. For</span>
<span class="sd">            DataFrames, this option is only applied when sorting on a single</span>
<span class="sd">            column or label.</span>
<span class="sd">        na_position : {&#39;first&#39;, &#39;last&#39;}, default &#39;last&#39;</span>
<span class="sd">            Puts NaNs at the beginning if `first`; `last` puts NaNs at the end.</span>
<span class="sd">            Not implemented for MultiIndex.</span>
<span class="sd">        sort_remaining : bool, default True</span>
<span class="sd">            If True and sorting by level and index is multilevel, sort by other</span>
<span class="sd">            levels too (in order) after sorting by specified level.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        sorted_obj : DataFrame or None</span>
<span class="sd">            DataFrame with sorted index if inplace=False, None otherwise.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">inplace</span> <span class="o">=</span> <span class="n">validate_bool_kwarg</span><span class="p">(</span><span class="n">inplace</span><span class="p">,</span> <span class="s2">&quot;inplace&quot;</span><span class="p">)</span>
        <span class="n">axis</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_axis_number</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span>
        <span class="n">axis_name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_axis_name</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span>
        <span class="n">labels</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_axis</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">level</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;level is not implemented&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">inplace</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;inplace is not implemented&quot;</span><span class="p">)</span>

        <span class="n">sort_index</span> <span class="o">=</span> <span class="n">labels</span><span class="o">.</span><span class="n">argsort</span><span class="p">()</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">ascending</span><span class="p">:</span>
            <span class="n">sort_index</span> <span class="o">=</span> <span class="n">sort_index</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

        <span class="n">new_axis</span> <span class="o">=</span> <span class="n">labels</span><span class="o">.</span><span class="n">take</span><span class="p">(</span><span class="n">sort_index</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">reindex</span><span class="p">(</span><span class="o">**</span><span class="p">{</span><span class="n">axis_name</span><span class="p">:</span> <span class="n">new_axis</span><span class="p">})</span>

    <span class="k">def</span> <span class="nf">reindex</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Conform %(klass)s to new index with optional filling logic, placing</span>
<span class="sd">        NA/NaN in locations having no value in the previous index. A new object</span>
<span class="sd">        is produced unless the new index is equivalent to the current one and</span>
<span class="sd">        ``copy=False``.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        %(optional_labels)s</span>
<span class="sd">        %(axes)s : array-like, optional</span>
<span class="sd">            New labels / index to conform to, should be specified using</span>
<span class="sd">            keywords. Preferably an Index object to avoid duplicating data</span>
<span class="sd">        %(optional_axis)s</span>
<span class="sd">        method : {None, &#39;backfill&#39;/&#39;bfill&#39;, &#39;pad&#39;/&#39;ffill&#39;, &#39;nearest&#39;}</span>
<span class="sd">            Method to use for filling holes in reindexed DataFrame.</span>
<span class="sd">            Please note: this is only applicable to DataFrames/Series with a</span>
<span class="sd">            monotonically increasing/decreasing index.</span>

<span class="sd">            * None (default): don&#39;t fill gaps</span>
<span class="sd">            * pad / ffill: propagate last valid observation forward to next</span>
<span class="sd">              valid</span>
<span class="sd">            * backfill / bfill: use next valid observation to fill gap</span>
<span class="sd">            * nearest: use nearest valid observations to fill gap</span>

<span class="sd">        copy : bool, default True</span>
<span class="sd">            Return a new object, even if the passed indexes are the same.</span>
<span class="sd">        level : int or name</span>
<span class="sd">            Broadcast across a level, matching Index values on the</span>
<span class="sd">            passed MultiIndex level.</span>
<span class="sd">        fill_value : scalar, default np.NaN</span>
<span class="sd">            Value to use for missing values. Defaults to NaN, but can be any</span>
<span class="sd">            &quot;compatible&quot; value.</span>
<span class="sd">        limit : int, default None</span>
<span class="sd">            Maximum number of consecutive elements to forward or backward fill.</span>
<span class="sd">        tolerance : optional</span>
<span class="sd">            Maximum distance between original and new labels for inexact</span>
<span class="sd">            matches. The values of the index at the matching locations most</span>
<span class="sd">            satisfy the equation ``abs(index[indexer] - target) &lt;= tolerance``.</span>

<span class="sd">            Tolerance may be a scalar value, which applies the same tolerance</span>
<span class="sd">            to all values, or list-like, which applies variable tolerance per</span>
<span class="sd">            element. List-like includes list, tuple, array, Series, and must be</span>
<span class="sd">            the same size as the index and its dtype must exactly match the</span>
<span class="sd">            index&#39;s type.</span>

<span class="sd">            .. versionadded:: 0.21.0 (list-like tolerance)</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        %(klass)s with changed index.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        DataFrame.set_index : Set row labels.</span>
<span class="sd">        DataFrame.reset_index : Remove row labels or move them to new columns.</span>
<span class="sd">        DataFrame.reindex_like : Change to same indices as other DataFrame.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>

<span class="sd">        ``DataFrame.reindex`` supports two calling conventions</span>

<span class="sd">        * ``(index=index_labels, columns=column_labels, ...)``</span>
<span class="sd">        * ``(labels, axis={&#39;index&#39;, &#39;columns&#39;}, ...)``</span>

<span class="sd">        We *highly* recommend using keyword arguments to clarify your</span>
<span class="sd">        intent.</span>

<span class="sd">        Create a dataframe with some fictional data.</span>

<span class="sd">        &gt;&gt;&gt; index = [&#39;Firefox&#39;, &#39;Chrome&#39;, &#39;Safari&#39;, &#39;IE10&#39;, &#39;Konqueror&#39;]</span>
<span class="sd">        &gt;&gt;&gt; df = pd.DataFrame({</span>
<span class="sd">        ...      &#39;http_status&#39;: [200,200,404,404,301],</span>
<span class="sd">        ...      &#39;response_time&#39;: [0.04, 0.02, 0.07, 0.08, 1.0]},</span>
<span class="sd">        ...       index=index)</span>
<span class="sd">        &gt;&gt;&gt; df</span>
<span class="sd">                   http_status  response_time</span>
<span class="sd">        Firefox            200           0.04</span>
<span class="sd">        Chrome             200           0.02</span>
<span class="sd">        Safari             404           0.07</span>
<span class="sd">        IE10               404           0.08</span>
<span class="sd">        Konqueror          301           1.00</span>

<span class="sd">        Create a new index and reindex the dataframe. By default</span>
<span class="sd">        values in the new index that do not have corresponding</span>
<span class="sd">        records in the dataframe are assigned ``NaN``.</span>

<span class="sd">        &gt;&gt;&gt; new_index= [&#39;Safari&#39;, &#39;Iceweasel&#39;, &#39;Comodo Dragon&#39;, &#39;IE10&#39;,</span>
<span class="sd">        ...             &#39;Chrome&#39;]</span>
<span class="sd">        &gt;&gt;&gt; df.reindex(new_index)</span>
<span class="sd">                       http_status  response_time</span>
<span class="sd">        Safari               404.0           0.07</span>
<span class="sd">        Iceweasel              NaN            NaN</span>
<span class="sd">        Comodo Dragon          NaN            NaN</span>
<span class="sd">        IE10                 404.0           0.08</span>
<span class="sd">        Chrome               200.0           0.02</span>

<span class="sd">        We can fill in the missing values by passing a value to</span>
<span class="sd">        the keyword ``fill_value``. Because the index is not monotonically</span>
<span class="sd">        increasing or decreasing, we cannot use arguments to the keyword</span>
<span class="sd">        ``method`` to fill the ``NaN`` values.</span>

<span class="sd">        &gt;&gt;&gt; df.reindex(new_index, fill_value=0)</span>
<span class="sd">                       http_status  response_time</span>
<span class="sd">        Safari                 404           0.07</span>
<span class="sd">        Iceweasel                0           0.00</span>
<span class="sd">        Comodo Dragon            0           0.00</span>
<span class="sd">        IE10                   404           0.08</span>
<span class="sd">        Chrome                 200           0.02</span>

<span class="sd">        &gt;&gt;&gt; df.reindex(new_index, fill_value=&#39;missing&#39;)</span>
<span class="sd">                      http_status response_time</span>
<span class="sd">        Safari                404          0.07</span>
<span class="sd">        Iceweasel         missing       missing</span>
<span class="sd">        Comodo Dragon     missing       missing</span>
<span class="sd">        IE10                  404          0.08</span>
<span class="sd">        Chrome                200          0.02</span>

<span class="sd">        We can also reindex the columns.</span>

<span class="sd">        &gt;&gt;&gt; df.reindex(columns=[&#39;http_status&#39;, &#39;user_agent&#39;])</span>
<span class="sd">                   http_status  user_agent</span>
<span class="sd">        Firefox            200         NaN</span>
<span class="sd">        Chrome             200         NaN</span>
<span class="sd">        Safari             404         NaN</span>
<span class="sd">        IE10               404         NaN</span>
<span class="sd">        Konqueror          301         NaN</span>

<span class="sd">        Or we can use &quot;axis-style&quot; keyword arguments</span>

<span class="sd">        &gt;&gt;&gt; df.reindex([&#39;http_status&#39;, &#39;user_agent&#39;], axis=&quot;columns&quot;)</span>
<span class="sd">                   http_status  user_agent</span>
<span class="sd">        Firefox            200         NaN</span>
<span class="sd">        Chrome             200         NaN</span>
<span class="sd">        Safari             404         NaN</span>
<span class="sd">        IE10               404         NaN</span>
<span class="sd">        Konqueror          301         NaN</span>

<span class="sd">        To further illustrate the filling functionality in</span>
<span class="sd">        ``reindex``, we will create a dataframe with a</span>
<span class="sd">        monotonically increasing index (for example, a sequence</span>
<span class="sd">        of dates).</span>

<span class="sd">        &gt;&gt;&gt; date_index = pd.date_range(&#39;1/1/2010&#39;, periods=6, freq=&#39;D&#39;)</span>
<span class="sd">        &gt;&gt;&gt; df2 = pd.DataFrame({&quot;prices&quot;: [100, 101, np.nan, 100, 89, 88]},</span>
<span class="sd">        ...                    index=date_index)</span>
<span class="sd">        &gt;&gt;&gt; df2</span>
<span class="sd">                    prices</span>
<span class="sd">        2010-01-01   100.0</span>
<span class="sd">        2010-01-02   101.0</span>
<span class="sd">        2010-01-03     NaN</span>
<span class="sd">        2010-01-04   100.0</span>
<span class="sd">        2010-01-05    89.0</span>
<span class="sd">        2010-01-06    88.0</span>

<span class="sd">        Suppose we decide to expand the dataframe to cover a wider</span>
<span class="sd">        date range.</span>

<span class="sd">        &gt;&gt;&gt; date_index2 = pd.date_range(&#39;12/29/2009&#39;, periods=10, freq=&#39;D&#39;)</span>
<span class="sd">        &gt;&gt;&gt; df2.reindex(date_index2)</span>
<span class="sd">                    prices</span>
<span class="sd">        2009-12-29     NaN</span>
<span class="sd">        2009-12-30     NaN</span>
<span class="sd">        2009-12-31     NaN</span>
<span class="sd">        2010-01-01   100.0</span>
<span class="sd">        2010-01-02   101.0</span>
<span class="sd">        2010-01-03     NaN</span>
<span class="sd">        2010-01-04   100.0</span>
<span class="sd">        2010-01-05    89.0</span>
<span class="sd">        2010-01-06    88.0</span>
<span class="sd">        2010-01-07     NaN</span>

<span class="sd">        The index entries that did not have a value in the original data frame</span>
<span class="sd">        (for example, &#39;2009-12-29&#39;) are by default filled with ``NaN``.</span>
<span class="sd">        If desired, we can fill in the missing values using one of several</span>
<span class="sd">        options.</span>

<span class="sd">        For example, to back-propagate the last valid value to fill the ``NaN``</span>
<span class="sd">        values, pass ``bfill`` as an argument to the ``method`` keyword.</span>

<span class="sd">        &gt;&gt;&gt; df2.reindex(date_index2, method=&#39;bfill&#39;)</span>
<span class="sd">                    prices</span>
<span class="sd">        2009-12-29   100.0</span>
<span class="sd">        2009-12-30   100.0</span>
<span class="sd">        2009-12-31   100.0</span>
<span class="sd">        2010-01-01   100.0</span>
<span class="sd">        2010-01-02   101.0</span>
<span class="sd">        2010-01-03     NaN</span>
<span class="sd">        2010-01-04   100.0</span>
<span class="sd">        2010-01-05    89.0</span>
<span class="sd">        2010-01-06    88.0</span>
<span class="sd">        2010-01-07     NaN</span>

<span class="sd">        Please note that the ``NaN`` value present in the original dataframe</span>
<span class="sd">        (at index value 2010-01-03) will not be filled by any of the</span>
<span class="sd">        value propagation schemes. This is because filling while reindexing</span>
<span class="sd">        does not look at dataframe values, but only compares the original and</span>
<span class="sd">        desired indexes. If you do want to fill in the ``NaN`` values present</span>
<span class="sd">        in the original dataframe, use the ``fillna()`` method.</span>

<span class="sd">        See the :ref:`user guide &lt;basics.reindexing&gt;` for more.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># TODO: Decide if we care about having different examples for different</span>
        <span class="c1"># kinds</span>

        <span class="c1"># construct the args</span>
        <span class="n">axes</span><span class="p">,</span> <span class="n">kwargs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_construct_axes_from_arguments</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">)</span>
        <span class="n">method</span> <span class="o">=</span> <span class="n">missing</span><span class="o">.</span><span class="n">clean_reindex_fill_method</span><span class="p">(</span><span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;method&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">))</span>
        <span class="n">level</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;level&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="n">copy</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;copy&quot;</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
        <span class="n">limit</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;limit&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="n">tolerance</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;tolerance&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="n">fill_value</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;fill_value&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>

        <span class="c1"># Series.reindex doesn&#39;t use / need the axis kwarg</span>
        <span class="c1"># We pop and ignore it here, to make writing Series/Frame generic code</span>
        <span class="c1"># easier</span>
        <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;axis&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">kwargs</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                <span class="s2">&quot;reindex() got an unexpected keyword &quot;</span>
                <span class="s1">&#39;argument &quot;</span><span class="si">{0}</span><span class="s1">&quot;&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">kwargs</span><span class="o">.</span><span class="n">keys</span><span class="p">())[</span><span class="mi">0</span><span class="p">])</span>
            <span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_consolidate_inplace</span><span class="p">()</span>

        <span class="c1"># if all axes that are requested to reindex are equal, then only copy</span>
        <span class="c1"># if indicated must have index names equal here as well as values</span>
        <span class="k">if</span> <span class="nb">all</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_get_axis</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span><span class="o">.</span><span class="n">identical</span><span class="p">(</span><span class="n">ax</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">axis</span><span class="p">,</span> <span class="n">ax</span> <span class="ow">in</span> <span class="n">axes</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">ax</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
        <span class="p">):</span>
            <span class="k">if</span> <span class="n">copy</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="k">return</span> <span class="bp">self</span>

        <span class="c1"># check if we are a multi reindex</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_needs_reindex_multi</span><span class="p">(</span><span class="n">axes</span><span class="p">,</span> <span class="n">method</span><span class="p">,</span> <span class="n">level</span><span class="p">):</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_reindex_multi</span><span class="p">(</span><span class="n">axes</span><span class="p">,</span> <span class="n">copy</span><span class="p">,</span> <span class="n">fill_value</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
                <span class="k">pass</span>

        <span class="c1"># perform the reindex on the axes</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_reindex_axes</span><span class="p">(</span>
            <span class="n">axes</span><span class="p">,</span> <span class="n">level</span><span class="p">,</span> <span class="n">limit</span><span class="p">,</span> <span class="n">tolerance</span><span class="p">,</span> <span class="n">method</span><span class="p">,</span> <span class="n">fill_value</span><span class="p">,</span> <span class="n">copy</span>
        <span class="p">)</span><span class="o">.</span><span class="n">__finalize__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_reindex_axes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axes</span><span class="p">,</span> <span class="n">level</span><span class="p">,</span> <span class="n">limit</span><span class="p">,</span> <span class="n">tolerance</span><span class="p">,</span> <span class="n">method</span><span class="p">,</span> <span class="n">fill_value</span><span class="p">,</span> <span class="n">copy</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Perform the reindex for all the axes.&quot;&quot;&quot;</span>
        <span class="n">obj</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_AXIS_ORDERS</span><span class="p">:</span>
            <span class="n">labels</span> <span class="o">=</span> <span class="n">axes</span><span class="p">[</span><span class="n">a</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">labels</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">continue</span>

            <span class="n">ax</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_axis</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
            <span class="n">new_index</span><span class="p">,</span> <span class="n">indexer</span> <span class="o">=</span> <span class="n">ax</span><span class="o">.</span><span class="n">reindex</span><span class="p">(</span>
                <span class="n">labels</span><span class="p">,</span> <span class="n">level</span><span class="o">=</span><span class="n">level</span><span class="p">,</span> <span class="n">limit</span><span class="o">=</span><span class="n">limit</span><span class="p">,</span> <span class="n">tolerance</span><span class="o">=</span><span class="n">tolerance</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="n">method</span>
            <span class="p">)</span>

            <span class="n">axis</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_axis_number</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
            <span class="n">obj</span> <span class="o">=</span> <span class="n">obj</span><span class="o">.</span><span class="n">_reindex_with_indexers</span><span class="p">(</span>
                <span class="p">{</span><span class="n">axis</span><span class="p">:</span> <span class="p">[</span><span class="n">new_index</span><span class="p">,</span> <span class="n">indexer</span><span class="p">]},</span>
                <span class="n">fill_value</span><span class="o">=</span><span class="n">fill_value</span><span class="p">,</span>
                <span class="n">copy</span><span class="o">=</span><span class="n">copy</span><span class="p">,</span>
                <span class="n">allow_dups</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
            <span class="p">)</span>

        <span class="k">return</span> <span class="n">obj</span>

    <span class="k">def</span> <span class="nf">_needs_reindex_multi</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axes</span><span class="p">,</span> <span class="n">method</span><span class="p">,</span> <span class="n">level</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Check if we do need a multi reindex.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">(</span>
            <span class="p">(</span><span class="n">com</span><span class="o">.</span><span class="n">count_not_none</span><span class="p">(</span><span class="o">*</span><span class="n">axes</span><span class="o">.</span><span class="n">values</span><span class="p">())</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">_AXIS_LEN</span><span class="p">)</span>
            <span class="ow">and</span> <span class="n">method</span> <span class="ow">is</span> <span class="kc">None</span>
            <span class="ow">and</span> <span class="n">level</span> <span class="ow">is</span> <span class="kc">None</span>
            <span class="ow">and</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_mixed_type</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">_reindex_multi</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axes</span><span class="p">,</span> <span class="n">copy</span><span class="p">,</span> <span class="n">fill_value</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">NotImplemented</span>

    <span class="k">def</span> <span class="nf">_reindex_with_indexers</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">reindexers</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">allow_dups</span><span class="o">=</span><span class="kc">False</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;allow_dups indicates an internal call here &quot;&quot;&quot;</span>

        <span class="c1"># reindex doing multiple operations on different axes if indicated</span>
        <span class="n">new_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span>
        <span class="k">for</span> <span class="n">axis</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">reindexers</span><span class="o">.</span><span class="n">keys</span><span class="p">()):</span>
            <span class="n">index</span><span class="p">,</span> <span class="n">indexer</span> <span class="o">=</span> <span class="n">reindexers</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span>
            <span class="n">baxis</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_block_manager_axis</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">index</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">continue</span>

            <span class="n">index</span> <span class="o">=</span> <span class="n">ensure_index</span><span class="p">(</span><span class="n">index</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">indexer</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">indexer</span> <span class="o">=</span> <span class="n">ensure_int64</span><span class="p">(</span><span class="n">indexer</span><span class="p">)</span>

            <span class="c1"># TODO: speed up on homogeneous DataFrame objects</span>
            <span class="n">new_data</span> <span class="o">=</span> <span class="n">new_data</span><span class="o">.</span><span class="n">reindex_indexer</span><span class="p">(</span>
                <span class="n">index</span><span class="p">,</span>
                <span class="n">indexer</span><span class="p">,</span>
                <span class="n">axis</span><span class="o">=</span><span class="n">baxis</span><span class="p">,</span>
                <span class="n">fill_value</span><span class="o">=</span><span class="n">fill_value</span><span class="p">,</span>
                <span class="n">allow_dups</span><span class="o">=</span><span class="n">allow_dups</span><span class="p">,</span>
                <span class="n">copy</span><span class="o">=</span><span class="n">copy</span><span class="p">,</span>
            <span class="p">)</span>

        <span class="k">if</span> <span class="n">copy</span> <span class="ow">and</span> <span class="n">new_data</span> <span class="ow">is</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">:</span>
            <span class="n">new_data</span> <span class="o">=</span> <span class="n">new_data</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_constructor</span><span class="p">(</span><span class="n">new_data</span><span class="p">)</span><span class="o">.</span><span class="n">__finalize__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">filter</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">items</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">like</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">regex</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Subset rows or columns of dataframe according to labels in</span>
<span class="sd">        the specified index.</span>

<span class="sd">        Note that this routine does not filter a dataframe on its</span>
<span class="sd">        contents. The filter is applied to the labels of the index.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        items : list-like</span>
<span class="sd">            Keep labels from axis which are in items.</span>
<span class="sd">        like : string</span>
<span class="sd">            Keep labels from axis for which &quot;like in label == True&quot;.</span>
<span class="sd">        regex : string (regular expression)</span>
<span class="sd">            Keep labels from axis for which re.search(regex, label) == True.</span>
<span class="sd">        axis : int or string axis name</span>
<span class="sd">            The axis to filter on.  By default this is the info axis,</span>
<span class="sd">            &#39;index&#39; for Series, &#39;columns&#39; for DataFrame.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        same type as input object</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        DataFrame.loc</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        The ``items``, ``like``, and ``regex`` parameters are</span>
<span class="sd">        enforced to be mutually exclusive.</span>

<span class="sd">        ``axis`` defaults to the info axis that is used when indexing</span>
<span class="sd">        with ``[]``.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; df = pd.DataFrame(np.array(([1, 2, 3], [4, 5, 6])),</span>
<span class="sd">        ...                   index=[&#39;mouse&#39;, &#39;rabbit&#39;],</span>
<span class="sd">        ...                   columns=[&#39;one&#39;, &#39;two&#39;, &#39;three&#39;])</span>

<span class="sd">        &gt;&gt;&gt; # select columns by name</span>
<span class="sd">        &gt;&gt;&gt; df.filter(items=[&#39;one&#39;, &#39;three&#39;])</span>
<span class="sd">                 one  three</span>
<span class="sd">        mouse     1      3</span>
<span class="sd">        rabbit    4      6</span>

<span class="sd">        &gt;&gt;&gt; # select columns by regular expression</span>
<span class="sd">        &gt;&gt;&gt; df.filter(regex=&#39;e$&#39;, axis=1)</span>
<span class="sd">                 one  three</span>
<span class="sd">        mouse     1      3</span>
<span class="sd">        rabbit    4      6</span>

<span class="sd">        &gt;&gt;&gt; # select rows containing &#39;bbi&#39;</span>
<span class="sd">        &gt;&gt;&gt; df.filter(like=&#39;bbi&#39;, axis=0)</span>
<span class="sd">                 one  two  three</span>
<span class="sd">        rabbit    4    5      6</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">import</span> <span class="nn">re</span>

        <span class="n">nkw</span> <span class="o">=</span> <span class="n">com</span><span class="o">.</span><span class="n">count_not_none</span><span class="p">(</span><span class="n">items</span><span class="p">,</span> <span class="n">like</span><span class="p">,</span> <span class="n">regex</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">nkw</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                <span class="s2">&quot;Keyword arguments `items`, `like`, or `regex` &quot;</span>
                <span class="s2">&quot;are mutually exclusive&quot;</span>
            <span class="p">)</span>

        <span class="k">if</span> <span class="n">axis</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">axis</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_info_axis_name</span>
        <span class="n">labels</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_axis</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">items</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_axis_name</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">reindex</span><span class="p">(</span><span class="o">**</span><span class="p">{</span><span class="n">name</span><span class="p">:</span> <span class="p">[</span><span class="n">r</span> <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">items</span> <span class="k">if</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">labels</span><span class="p">]})</span>
        <span class="k">elif</span> <span class="n">like</span><span class="p">:</span>

            <span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">like</span> <span class="ow">in</span> <span class="n">ensure_str</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>

            <span class="n">values</span> <span class="o">=</span> <span class="n">labels</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">loc</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)[</span><span class="n">values</span><span class="p">]</span>
        <span class="k">elif</span> <span class="n">regex</span><span class="p">:</span>

            <span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">matcher</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="n">ensure_str</span><span class="p">(</span><span class="n">x</span><span class="p">))</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>

            <span class="n">matcher</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="n">regex</span><span class="p">)</span>
            <span class="n">values</span> <span class="o">=</span> <span class="n">labels</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">loc</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)[</span><span class="n">values</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Must pass either `items`, `like`, or `regex`&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">head</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="mi">5</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the first `n` rows.</span>

<span class="sd">        This function returns the first `n` rows for the object based</span>
<span class="sd">        on position. It is useful for quickly testing if your object</span>
<span class="sd">        has the right type of data in it.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        n : int, default 5</span>
<span class="sd">            Number of rows to select.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        obj_head : same type as caller</span>
<span class="sd">            The first `n` rows of the caller object.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        DataFrame.tail: Returns the last `n` rows.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; df = pd.DataFrame({&#39;animal&#39;:[&#39;alligator&#39;, &#39;bee&#39;, &#39;falcon&#39;, &#39;lion&#39;,</span>
<span class="sd">        ...                    &#39;monkey&#39;, &#39;parrot&#39;, &#39;shark&#39;, &#39;whale&#39;, &#39;zebra&#39;]})</span>
<span class="sd">        &gt;&gt;&gt; df</span>
<span class="sd">              animal</span>
<span class="sd">        0  alligator</span>
<span class="sd">        1        bee</span>
<span class="sd">        2     falcon</span>
<span class="sd">        3       lion</span>
<span class="sd">        4     monkey</span>
<span class="sd">        5     parrot</span>
<span class="sd">        6      shark</span>
<span class="sd">        7      whale</span>
<span class="sd">        8      zebra</span>

<span class="sd">        Viewing the first 5 lines</span>

<span class="sd">        &gt;&gt;&gt; df.head()</span>
<span class="sd">              animal</span>
<span class="sd">        0  alligator</span>
<span class="sd">        1        bee</span>
<span class="sd">        2     falcon</span>
<span class="sd">        3       lion</span>
<span class="sd">        4     monkey</span>

<span class="sd">        Viewing the first `n` lines (three in this case)</span>

<span class="sd">        &gt;&gt;&gt; df.head(3)</span>
<span class="sd">              animal</span>
<span class="sd">        0  alligator</span>
<span class="sd">        1        bee</span>
<span class="sd">        2     falcon</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">iloc</span><span class="p">[:</span><span class="n">n</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">tail</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="mi">5</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the last `n` rows.</span>

<span class="sd">        This function returns last `n` rows from the object based on</span>
<span class="sd">        position. It is useful for quickly verifying data, for example,</span>
<span class="sd">        after sorting or appending rows.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        n : int, default 5</span>
<span class="sd">            Number of rows to select.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        type of caller</span>
<span class="sd">            The last `n` rows of the caller object.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        DataFrame.head : The first `n` rows of the caller object.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; df = pd.DataFrame({&#39;animal&#39;:[&#39;alligator&#39;, &#39;bee&#39;, &#39;falcon&#39;, &#39;lion&#39;,</span>
<span class="sd">        ...                    &#39;monkey&#39;, &#39;parrot&#39;, &#39;shark&#39;, &#39;whale&#39;, &#39;zebra&#39;]})</span>
<span class="sd">        &gt;&gt;&gt; df</span>
<span class="sd">              animal</span>
<span class="sd">        0  alligator</span>
<span class="sd">        1        bee</span>
<span class="sd">        2     falcon</span>
<span class="sd">        3       lion</span>
<span class="sd">        4     monkey</span>
<span class="sd">        5     parrot</span>
<span class="sd">        6      shark</span>
<span class="sd">        7      whale</span>
<span class="sd">        8      zebra</span>

<span class="sd">        Viewing the last 5 lines</span>

<span class="sd">        &gt;&gt;&gt; df.tail()</span>
<span class="sd">           animal</span>
<span class="sd">        4  monkey</span>
<span class="sd">        5  parrot</span>
<span class="sd">        6   shark</span>
<span class="sd">        7   whale</span>
<span class="sd">        8   zebra</span>

<span class="sd">        Viewing the last `n` lines (three in this case)</span>

<span class="sd">        &gt;&gt;&gt; df.tail(3)</span>
<span class="sd">          animal</span>
<span class="sd">        6  shark</span>
<span class="sd">        7  whale</span>
<span class="sd">        8  zebra</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="o">-</span><span class="n">n</span><span class="p">:]</span>

    <span class="k">def</span> <span class="nf">sample</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">n</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">frac</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">replace</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">weights</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">random_state</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">axis</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a random sample of items from an axis of object.</span>

<span class="sd">        You can use `random_state` for reproducibility.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        n : int, optional</span>
<span class="sd">            Number of items from axis to return. Cannot be used with `frac`.</span>
<span class="sd">            Default = 1 if `frac` = None.</span>
<span class="sd">        frac : float, optional</span>
<span class="sd">            Fraction of axis items to return. Cannot be used with `n`.</span>
<span class="sd">        replace : bool, default False</span>
<span class="sd">            Sample with or without replacement.</span>
<span class="sd">        weights : str or ndarray-like, optional</span>
<span class="sd">            Default &#39;None&#39; results in equal probability weighting.</span>
<span class="sd">            If passed a Series, will align with target object on index. Index</span>
<span class="sd">            values in weights not found in sampled object will be ignored and</span>
<span class="sd">            index values in sampled object not in weights will be assigned</span>
<span class="sd">            weights of zero.</span>
<span class="sd">            If called on a DataFrame, will accept the name of a column</span>
<span class="sd">            when axis = 0.</span>
<span class="sd">            Unless weights are a Series, weights must be same length as axis</span>
<span class="sd">            being sampled.</span>
<span class="sd">            If weights do not sum to 1, they will be normalized to sum to 1.</span>
<span class="sd">            Missing values in the weights column will be treated as zero.</span>
<span class="sd">            Infinite values not allowed.</span>
<span class="sd">        random_state : int or numpy.random.RandomState, optional</span>
<span class="sd">            Seed for the random number generator (if int), or numpy RandomState</span>
<span class="sd">            object.</span>
<span class="sd">        axis : int or string, optional</span>
<span class="sd">            Axis to sample. Accepts axis number or name. Default is stat axis</span>
<span class="sd">            for given data type (0 for Series and DataFrames).</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Series or DataFrame</span>
<span class="sd">            A new object of same type as caller containing `n` items randomly</span>
<span class="sd">            sampled from the caller object.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        numpy.random.choice: Generates a random sample from a given 1-D numpy</span>
<span class="sd">            array.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; df = pd.DataFrame({&#39;num_legs&#39;: [2, 4, 8, 0],</span>
<span class="sd">        ...                    &#39;num_wings&#39;: [2, 0, 0, 0],</span>
<span class="sd">        ...                    &#39;num_specimen_seen&#39;: [10, 2, 1, 8]},</span>
<span class="sd">        ...                   index=[&#39;falcon&#39;, &#39;dog&#39;, &#39;spider&#39;, &#39;fish&#39;])</span>
<span class="sd">        &gt;&gt;&gt; df</span>
<span class="sd">                num_legs  num_wings  num_specimen_seen</span>
<span class="sd">        falcon         2          2                 10</span>
<span class="sd">        dog            4          0                  2</span>
<span class="sd">        spider         8          0                  1</span>
<span class="sd">        fish           0          0                  8</span>

<span class="sd">        Extract 3 random elements from the ``Series`` ``df[&#39;num_legs&#39;]``:</span>
<span class="sd">        Note that we use `random_state` to ensure the reproducibility of</span>
<span class="sd">        the examples.</span>

<span class="sd">        &gt;&gt;&gt; df[&#39;num_legs&#39;].sample(n=3, random_state=1)</span>
<span class="sd">        fish      0</span>
<span class="sd">        spider    8</span>
<span class="sd">        falcon    2</span>
<span class="sd">        Name: num_legs, dtype: int64</span>

<span class="sd">        A random 50% sample of the ``DataFrame`` with replacement:</span>

<span class="sd">        &gt;&gt;&gt; df.sample(frac=0.5, replace=True, random_state=1)</span>
<span class="sd">              num_legs  num_wings  num_specimen_seen</span>
<span class="sd">        dog          4          0                  2</span>
<span class="sd">        fish         0          0                  8</span>

<span class="sd">        Using a DataFrame column as weights. Rows with larger value in the</span>
<span class="sd">        `num_specimen_seen` column are more likely to be sampled.</span>

<span class="sd">        &gt;&gt;&gt; df.sample(n=2, weights=&#39;num_specimen_seen&#39;, random_state=1)</span>
<span class="sd">                num_legs  num_wings  num_specimen_seen</span>
<span class="sd">        falcon         2          2                 10</span>
<span class="sd">        fish           0          0                  8</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">axis</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">axis</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_stat_axis_number</span>

        <span class="n">axis</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_axis_number</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span>
        <span class="n">axis_length</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span>

        <span class="c1"># Process random_state argument</span>
        <span class="n">rs</span> <span class="o">=</span> <span class="n">com</span><span class="o">.</span><span class="n">random_state</span><span class="p">(</span><span class="n">random_state</span><span class="p">)</span>

        <span class="c1"># Check weights for compliance</span>
        <span class="k">if</span> <span class="n">weights</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>

            <span class="c1"># If a series, align with frame</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">weights</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">):</span>
                <span class="n">weights</span> <span class="o">=</span> <span class="n">weights</span><span class="o">.</span><span class="n">reindex</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">axes</span><span class="p">[</span><span class="n">axis</span><span class="p">])</span>

            <span class="c1"># Strings acceptable if a dataframe and axis = 0</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">weights</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">):</span>
                    <span class="k">if</span> <span class="n">axis</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="k">try</span><span class="p">:</span>
                            <span class="n">weights</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="n">weights</span><span class="p">]</span>
                        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                            <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span>
                                <span class="s2">&quot;String passed to weights not a &quot;</span> <span class="s2">&quot;valid column&quot;</span>
                            <span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                            <span class="s2">&quot;Strings can only be passed to &quot;</span>
                            <span class="s2">&quot;weights when sampling from rows on &quot;</span>
                            <span class="s2">&quot;a DataFrame&quot;</span>
                        <span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                        <span class="s2">&quot;Strings cannot be passed as weights &quot;</span>
                        <span class="s2">&quot;when sampling from a Series.&quot;</span>
                    <span class="p">)</span>

            <span class="n">weights</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">weights</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;float64&quot;</span><span class="p">)</span>

            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">weights</span><span class="p">)</span> <span class="o">!=</span> <span class="n">axis_length</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;Weights and axis to be sampled must be of &quot;</span> <span class="s2">&quot;same length&quot;</span>
                <span class="p">)</span>

            <span class="k">if</span> <span class="p">(</span><span class="n">weights</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">()</span> <span class="ow">or</span> <span class="p">(</span><span class="n">weights</span> <span class="o">==</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;weight vector may not include `inf` values&quot;</span><span class="p">)</span>

            <span class="k">if</span> <span class="p">(</span><span class="n">weights</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;weight vector many not include negative &quot;</span> <span class="s2">&quot;values&quot;</span><span class="p">)</span>

            <span class="c1"># If has nan, set to zero.</span>
            <span class="n">weights</span> <span class="o">=</span> <span class="n">weights</span><span class="o">.</span><span class="n">fillna</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>

            <span class="c1"># Renormalize if don&#39;t sum to 1</span>
            <span class="k">if</span> <span class="n">weights</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">weights</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">weights</span> <span class="o">=</span> <span class="n">weights</span> <span class="o">/</span> <span class="n">weights</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Invalid weights: weights sum to zero&quot;</span><span class="p">)</span>

            <span class="n">weights</span> <span class="o">=</span> <span class="n">weights</span><span class="o">.</span><span class="n">values</span>

        <span class="c1"># If no frac or n, default to n=1.</span>
        <span class="k">if</span> <span class="n">n</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">frac</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">n</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">elif</span> <span class="n">n</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">frac</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">n</span> <span class="o">%</span> <span class="mi">1</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Only integers accepted as `n` values&quot;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">n</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">frac</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">n</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="n">frac</span> <span class="o">*</span> <span class="n">axis_length</span><span class="p">))</span>
        <span class="k">elif</span> <span class="n">n</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">frac</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Please enter a value for `frac` OR `n`, not &quot;</span> <span class="s2">&quot;both&quot;</span><span class="p">)</span>

        <span class="c1"># Check for negative sizes</span>
        <span class="k">if</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;A negative number of rows requested. Please &quot;</span> <span class="s2">&quot;provide positive value.&quot;</span>
            <span class="p">)</span>

        <span class="n">locs</span> <span class="o">=</span> <span class="n">rs</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="n">axis_length</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="n">n</span><span class="p">,</span> <span class="n">replace</span><span class="o">=</span><span class="n">replace</span><span class="p">,</span> <span class="n">p</span><span class="o">=</span><span class="n">weights</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">take</span><span class="p">(</span><span class="n">locs</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">is_copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

    <span class="n">_shared_docs</span><span class="p">[</span>
        <span class="s2">&quot;pipe&quot;</span>
    <span class="p">]</span> <span class="o">=</span> <span class="sa">r</span><span class="s2">&quot;&quot;&quot;</span>
<span class="s2">        Apply func(self, \*args, \*\*kwargs).</span>

<span class="s2">        Parameters</span>
<span class="s2">        ----------</span>
<span class="s2">        func : function</span>
<span class="s2">            function to apply to the </span><span class="si">%(klass)s</span><span class="s2">.</span>
<span class="s2">            ``args``, and ``kwargs`` are passed into ``func``.</span>
<span class="s2">            Alternatively a ``(callable, data_keyword)`` tuple where</span>
<span class="s2">            ``data_keyword`` is a string indicating the keyword of</span>
<span class="s2">            ``callable`` that expects the </span><span class="si">%(klass)s</span><span class="s2">.</span>
<span class="s2">        args : iterable, optional</span>
<span class="s2">            positional arguments passed into ``func``.</span>
<span class="s2">        kwargs : mapping, optional</span>
<span class="s2">            a dictionary of keyword arguments passed into ``func``.</span>

<span class="s2">        Returns</span>
<span class="s2">        -------</span>
<span class="s2">        object : the return type of ``func``.</span>

<span class="s2">        See Also</span>
<span class="s2">        --------</span>
<span class="s2">        DataFrame.apply</span>
<span class="s2">        DataFrame.applymap</span>
<span class="s2">        Series.map</span>

<span class="s2">        Notes</span>
<span class="s2">        -----</span>

<span class="s2">        Use ``.pipe`` when chaining together functions that expect</span>
<span class="s2">        Series, DataFrames or GroupBy objects. Instead of writing</span>

<span class="s2">        &gt;&gt;&gt; f(g(h(df), arg1=a), arg2=b, arg3=c)</span>

<span class="s2">        You can write</span>

<span class="s2">        &gt;&gt;&gt; (df.pipe(h)</span>
<span class="s2">        ...    .pipe(g, arg1=a)</span>
<span class="s2">        ...    .pipe(f, arg2=b, arg3=c)</span>
<span class="s2">        ... )</span>

<span class="s2">        If you have a function that takes the data as (say) the second</span>
<span class="s2">        argument, pass a tuple indicating which keyword expects the</span>
<span class="s2">        data. For example, suppose ``f`` takes its data as ``arg2``:</span>

<span class="s2">        &gt;&gt;&gt; (df.pipe(h)</span>
<span class="s2">        ...    .pipe(g, arg1=a)</span>
<span class="s2">        ...    .pipe((f, &#39;arg2&#39;), arg1=a, arg3=c)</span>
<span class="s2">        ...  )</span>
<span class="s2">    &quot;&quot;&quot;</span>

    <span class="nd">@Appender</span><span class="p">(</span><span class="n">_shared_docs</span><span class="p">[</span><span class="s2">&quot;pipe&quot;</span><span class="p">]</span> <span class="o">%</span> <span class="n">_shared_doc_kwargs</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">pipe</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">func</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">com</span><span class="o">.</span><span class="n">_pipe</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">func</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="n">_shared_docs</span><span class="p">[</span><span class="s2">&quot;aggregate&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">dedent</span><span class="p">(</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Aggregate using one or more operations over the specified axis.</span>
<span class="sd">    %(versionadded)s</span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    func : function, str, list or dict</span>
<span class="sd">        Function to use for aggregating the data. If a function, must either</span>
<span class="sd">        work when passed a %(klass)s or when passed to %(klass)s.apply.</span>

<span class="sd">        Accepted combinations are:</span>

<span class="sd">        - function</span>
<span class="sd">        - string function name</span>
<span class="sd">        - list of functions and/or function names, e.g. ``[np.sum, &#39;mean&#39;]``</span>
<span class="sd">        - dict of axis labels -&gt; functions, function names or list of such.</span>
<span class="sd">    %(axis)s</span>
<span class="sd">    *args</span>
<span class="sd">        Positional arguments to pass to `func`.</span>
<span class="sd">    **kwargs</span>
<span class="sd">        Keyword arguments to pass to `func`.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    scalar, Series or DataFrame</span>

<span class="sd">        The return can be:</span>

<span class="sd">        * scalar : when Series.agg is called with single function</span>
<span class="sd">        * Series : when DataFrame.agg is called with a single function</span>
<span class="sd">        * DataFrame : when DataFrame.agg is called with several functions</span>

<span class="sd">        Return scalar, Series or DataFrame.</span>
<span class="sd">    %(see_also)s</span>
<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    `agg` is an alias for `aggregate`. Use the alias.</span>

<span class="sd">    A passed user-defined-function will be passed a Series for evaluation.</span>
<span class="sd">    %(examples)s&quot;&quot;&quot;</span>
    <span class="p">)</span>

    <span class="n">_shared_docs</span><span class="p">[</span>
        <span class="s2">&quot;transform&quot;</span>
    <span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;</span>
<span class="s2">    Call ``func`` on self producing a </span><span class="si">%(klass)s</span><span class="s2"> with transformed values</span>
<span class="s2">    and that has the same axis length as self.</span>

<span class="s2">    .. versionadded:: 0.20.0</span>

<span class="s2">    Parameters</span>
<span class="s2">    ----------</span>
<span class="s2">    func : function, str, list or dict</span>
<span class="s2">        Function to use for transforming the data. If a function, must either</span>
<span class="s2">        work when passed a </span><span class="si">%(klass)s</span><span class="s2"> or when passed to </span><span class="si">%(klass)s</span><span class="s2">.apply.</span>

<span class="s2">        Accepted combinations are:</span>

<span class="s2">        - function</span>
<span class="s2">        - string function name</span>
<span class="s2">        - list of functions and/or function names, e.g. ``[np.exp. &#39;sqrt&#39;]``</span>
<span class="s2">        - dict of axis labels -&gt; functions, function names or list of such.</span>
<span class="s2">    </span><span class="si">%(axis)s</span><span class="s2"></span>
<span class="s2">    *args</span>
<span class="s2">        Positional arguments to pass to `func`.</span>
<span class="s2">    **kwargs</span>
<span class="s2">        Keyword arguments to pass to `func`.</span>

<span class="s2">    Returns</span>
<span class="s2">    -------</span>
<span class="s2">    </span><span class="si">%(klass)s</span><span class="s2"></span>
<span class="s2">        A </span><span class="si">%(klass)s</span><span class="s2"> that must have the same length as self.</span>

<span class="s2">    Raises</span>
<span class="s2">    ------</span>
<span class="s2">    ValueError : If the returned </span><span class="si">%(klass)s</span><span class="s2"> has a different length than self.</span>

<span class="s2">    See Also</span>
<span class="s2">    --------</span>
<span class="s2">    </span><span class="si">%(klass)s</span><span class="s2">.agg : Only perform aggregating type operations.</span>
<span class="s2">    </span><span class="si">%(klass)s</span><span class="s2">.apply : Invoke function on a </span><span class="si">%(klass)s</span><span class="s2">.</span>

<span class="s2">    Examples</span>
<span class="s2">    --------</span>
<span class="s2">    &gt;&gt;&gt; df = pd.DataFrame({&#39;A&#39;: range(3), &#39;B&#39;: range(1, 4)})</span>
<span class="s2">    &gt;&gt;&gt; df</span>
<span class="s2">       A  B</span>
<span class="s2">    0  0  1</span>
<span class="s2">    1  1  2</span>
<span class="s2">    2  2  3</span>
<span class="s2">    &gt;&gt;&gt; df.transform(lambda x: x + 1)</span>
<span class="s2">       A  B</span>
<span class="s2">    0  1  2</span>
<span class="s2">    1  2  3</span>
<span class="s2">    2  3  4</span>

<span class="s2">    Even though the resulting </span><span class="si">%(klass)s</span><span class="s2"> must have the same length as the</span>
<span class="s2">    input </span><span class="si">%(klass)s</span><span class="s2">, it is possible to provide several input functions:</span>

<span class="s2">    &gt;&gt;&gt; s = pd.Series(range(3))</span>
<span class="s2">    &gt;&gt;&gt; s</span>
<span class="s2">    0    0</span>
<span class="s2">    1    1</span>
<span class="s2">    2    2</span>
<span class="s2">    dtype: int64</span>
<span class="s2">    &gt;&gt;&gt; s.transform([np.sqrt, np.exp])</span>
<span class="s2">           sqrt        exp</span>
<span class="s2">    0  0.000000   1.000000</span>
<span class="s2">    1  1.000000   2.718282</span>
<span class="s2">    2  1.414214   7.389056</span>
<span class="s2">    &quot;&quot;&quot;</span>

    <span class="c1"># ----------------------------------------------------------------------</span>
    <span class="c1"># Attribute access</span>

    <span class="k">def</span> <span class="nf">__finalize__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Propagate metadata from other to self.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        other : the object from which to get the attributes that we are going</span>
<span class="sd">            to propagate</span>
<span class="sd">        method : optional, a passed method name ; possibly to take different</span>
<span class="sd">            types of propagation actions based on this</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">NDFrame</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_metadata</span><span class="p">:</span>
                <span class="nb">object</span><span class="o">.</span><span class="fm">__setattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="kc">None</span><span class="p">))</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">__getattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;After regular attribute access, try looking up the name</span>
<span class="sd">        This allows simpler access to columns for interactive use.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Note: obj.x will always call obj.__getattribute__(&#39;x&#39;) prior to</span>
        <span class="c1"># calling obj.__getattr__(&#39;x&#39;).</span>

        <span class="k">if</span> <span class="p">(</span>
            <span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_internal_names_set</span>
            <span class="ow">or</span> <span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_metadata</span>
            <span class="ow">or</span> <span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_accessors</span>
        <span class="p">):</span>
            <span class="k">return</span> <span class="nb">object</span><span class="o">.</span><span class="fm">__getattribute__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_info_axis</span><span class="o">.</span><span class="n">_can_hold_identifiers_and_holds_name</span><span class="p">(</span><span class="n">name</span><span class="p">):</span>
                <span class="k">return</span> <span class="bp">self</span><span class="p">[</span><span class="n">name</span><span class="p">]</span>
            <span class="k">return</span> <span class="nb">object</span><span class="o">.</span><span class="fm">__getattribute__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__setattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;After regular attribute access, try setting the name</span>
<span class="sd">        This allows simpler access to columns for interactive use.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># first try regular attribute access via __getattribute__, so that</span>
        <span class="c1"># e.g. ``obj.x`` and ``obj.x = 4`` will always reference/modify</span>
        <span class="c1"># the same attribute.</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="nb">object</span><span class="o">.</span><span class="fm">__getattribute__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>
            <span class="k">return</span> <span class="nb">object</span><span class="o">.</span><span class="fm">__setattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="k">pass</span>

        <span class="c1"># if this fails, go on to more involved attribute setting</span>
        <span class="c1"># (note that this matches __getattr__, above).</span>
        <span class="k">if</span> <span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_internal_names_set</span><span class="p">:</span>
            <span class="nb">object</span><span class="o">.</span><span class="fm">__setattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_metadata</span><span class="p">:</span>
            <span class="nb">object</span><span class="o">.</span><span class="fm">__setattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">existing</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">existing</span><span class="p">,</span> <span class="n">Index</span><span class="p">):</span>
                    <span class="nb">object</span><span class="o">.</span><span class="fm">__setattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
                <span class="k">elif</span> <span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_info_axis</span><span class="p">:</span>
                    <span class="bp">self</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="nb">object</span><span class="o">.</span><span class="fm">__setattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
            <span class="k">except</span> <span class="p">(</span><span class="ne">AttributeError</span><span class="p">,</span> <span class="ne">TypeError</span><span class="p">):</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ABCDataFrame</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">is_list_like</span><span class="p">(</span><span class="n">value</span><span class="p">)):</span>
                    <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                        <span class="s2">&quot;Pandas doesn&#39;t allow columns to be &quot;</span>
                        <span class="s2">&quot;created via a new attribute name - see &quot;</span>
                        <span class="s2">&quot;https://pandas.pydata.org/pandas-docs/&quot;</span>
                        <span class="s2">&quot;stable/indexing.html#attribute-access&quot;</span><span class="p">,</span>
                        <span class="n">stacklevel</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
                    <span class="p">)</span>
                <span class="nb">object</span><span class="o">.</span><span class="fm">__setattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_dir_additions</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; add the string-like attributes from the info_axis.</span>
<span class="sd">        If info_axis is a MultiIndex, it&#39;s first level values are used.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">additions</span> <span class="o">=</span> <span class="p">{</span>
            <span class="n">c</span>
            <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_info_axis</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">level</span><span class="o">=</span><span class="mi">0</span><span class="p">)[:</span><span class="mi">100</span><span class="p">]</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="ow">and</span> <span class="n">c</span><span class="o">.</span><span class="n">isidentifier</span><span class="p">()</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">_dir_additions</span><span class="p">()</span><span class="o">.</span><span class="n">union</span><span class="p">(</span><span class="n">additions</span><span class="p">)</span>

    <span class="c1"># ----------------------------------------------------------------------</span>
    <span class="c1"># Consolidation of internals</span>

    <span class="k">def</span> <span class="nf">_protect_consolidate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">f</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Consolidate _data -- if the blocks have changed, then clear the</span>
<span class="sd">        cache</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">blocks_before</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">blocks</span><span class="p">)</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">f</span><span class="p">()</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">blocks</span><span class="p">)</span> <span class="o">!=</span> <span class="n">blocks_before</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_clear_item_cache</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">result</span>

    <span class="k">def</span> <span class="nf">_consolidate_inplace</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Consolidate data in place and return None&quot;&quot;&quot;</span>

        <span class="k">def</span> <span class="nf">f</span><span class="p">():</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">consolidate</span><span class="p">()</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_protect_consolidate</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_consolidate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute NDFrame with &quot;consolidated&quot; internals (data of each dtype</span>
<span class="sd">        grouped together in a single ndarray).</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        inplace : boolean, default False</span>
<span class="sd">            If False return new object, otherwise modify existing object</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        consolidated : same type as caller</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">inplace</span> <span class="o">=</span> <span class="n">validate_bool_kwarg</span><span class="p">(</span><span class="n">inplace</span><span class="p">,</span> <span class="s2">&quot;inplace&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">inplace</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_consolidate_inplace</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">f</span> <span class="o">=</span> <span class="k">lambda</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">consolidate</span><span class="p">()</span>
            <span class="n">cons_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_protect_consolidate</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_constructor</span><span class="p">(</span><span class="n">cons_data</span><span class="p">)</span><span class="o">.</span><span class="n">__finalize__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_is_mixed_type</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">f</span> <span class="o">=</span> <span class="k">lambda</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">is_mixed_type</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_protect_consolidate</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_is_numeric_mixed_type</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">f</span> <span class="o">=</span> <span class="k">lambda</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">is_numeric_mixed_type</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_protect_consolidate</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_is_datelike_mixed_type</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">f</span> <span class="o">=</span> <span class="k">lambda</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">is_datelike_mixed_type</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_protect_consolidate</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_check_inplace_setting</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; check whether we allow in-place setting with this type of value &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_mixed_type</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_numeric_mixed_type</span><span class="p">:</span>

                <span class="c1"># allow an actual np.nan thru</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">value</span><span class="p">):</span>
                        <span class="k">return</span> <span class="kc">True</span>
                <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
                    <span class="k">pass</span>

                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                    <span class="s2">&quot;Cannot do inplace boolean setting on &quot;</span>
                    <span class="s2">&quot;mixed-types with a non np.nan value&quot;</span>
                <span class="p">)</span>

        <span class="k">return</span> <span class="kc">True</span>

    <span class="k">def</span> <span class="nf">_get_numeric_data</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_constructor</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">get_numeric_data</span><span class="p">())</span><span class="o">.</span><span class="n">__finalize__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_get_bool_data</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_constructor</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">get_bool_data</span><span class="p">())</span><span class="o">.</span><span class="n">__finalize__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="c1"># ----------------------------------------------------------------------</span>
    <span class="c1"># Internal Interface Methods</span>

    <span class="k">def</span> <span class="nf">as_matrix</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">columns</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Convert the frame to its Numpy-array representation.</span>

<span class="sd">        .. deprecated:: 0.23.0</span>
<span class="sd">            Use :meth:`DataFrame.values` instead.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        columns : list, optional, default:None</span>
<span class="sd">            If None, return all columns, otherwise, returns specified columns.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        values : ndarray</span>
<span class="sd">            If the caller is heterogeneous and contains booleans or objects,</span>
<span class="sd">            the result will be of dtype=object. See Notes.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        DataFrame.values</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        Return is NOT a Numpy-matrix, rather, a Numpy-array.</span>

<span class="sd">        The dtype will be a lower-common-denominator dtype (implicit</span>
<span class="sd">        upcasting); that is to say if the dtypes (even of numeric types)</span>
<span class="sd">        are mixed, the one that accommodates all will be chosen. Use this</span>
<span class="sd">        with care if you are not dealing with the blocks.</span>

<span class="sd">        e.g. If the dtypes are float16 and float32, dtype will be upcast to</span>
<span class="sd">        float32.  If dtypes are int32 and uint8, dtype will be upcase to</span>
<span class="sd">        int32. By numpy.find_common_type convention, mixing int64 and uint64</span>
<span class="sd">        will result in a float64 dtype.</span>

<span class="sd">        This method is provided for backwards compatibility. Generally,</span>
<span class="sd">        it is recommended to use &#39;.values&#39;.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
            <span class="s2">&quot;Method .as_matrix will be removed in a future version. &quot;</span>
            <span class="s2">&quot;Use .values instead.&quot;</span><span class="p">,</span>
            <span class="ne">FutureWarning</span><span class="p">,</span>
            <span class="n">stacklevel</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_consolidate_inplace</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">as_array</span><span class="p">(</span><span class="n">transpose</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_AXIS_REVERSED</span><span class="p">,</span> <span class="n">items</span><span class="o">=</span><span class="n">columns</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">values</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a Numpy representation of the DataFrame.</span>

<span class="sd">        .. warning::</span>

<span class="sd">           We recommend using :meth:`DataFrame.to_numpy` instead.</span>

<span class="sd">        Only the values in the DataFrame will be returned, the axes labels</span>
<span class="sd">        will be removed.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        numpy.ndarray</span>
<span class="sd">            The values of the DataFrame.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        DataFrame.to_numpy : Recommended alternative to this method.</span>
<span class="sd">        DataFrame.index : Retrieve the index labels.</span>
<span class="sd">        DataFrame.columns : Retrieving the column names.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        The dtype will be a lower-common-denominator dtype (implicit</span>
<span class="sd">        upcasting); that is to say if the dtypes (even of numeric types)</span>
<span class="sd">        are mixed, the one that accommodates all will be chosen. Use this</span>
<span class="sd">        with care if you are not dealing with the blocks.</span>

<span class="sd">        e.g. If the dtypes are float16 and float32, dtype will be upcast to</span>
<span class="sd">        float32.  If dtypes are int32 and uint8, dtype will be upcast to</span>
<span class="sd">        int32. By :func:`numpy.find_common_type` convention, mixing int64</span>
<span class="sd">        and uint64 will result in a float64 dtype.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        A DataFrame where all columns are the same type (e.g., int64) results</span>
<span class="sd">        in an array of the same type.</span>

<span class="sd">        &gt;&gt;&gt; df = pd.DataFrame({&#39;age&#39;:    [ 3,  29],</span>
<span class="sd">        ...                    &#39;height&#39;: [94, 170],</span>
<span class="sd">        ...                    &#39;weight&#39;: [31, 115]})</span>
<span class="sd">        &gt;&gt;&gt; df</span>
<span class="sd">           age  height  weight</span>
<span class="sd">        0    3      94      31</span>
<span class="sd">        1   29     170     115</span>
<span class="sd">        &gt;&gt;&gt; df.dtypes</span>
<span class="sd">        age       int64</span>
<span class="sd">        height    int64</span>
<span class="sd">        weight    int64</span>
<span class="sd">        dtype: object</span>
<span class="sd">        &gt;&gt;&gt; df.values</span>
<span class="sd">        array([[  3,  94,  31],</span>
<span class="sd">               [ 29, 170, 115]], dtype=int64)</span>

<span class="sd">        A DataFrame with mixed type columns(e.g., str/object, int64, float32)</span>
<span class="sd">        results in an ndarray of the broadest type that accommodates these</span>
<span class="sd">        mixed types (e.g., object).</span>

<span class="sd">        &gt;&gt;&gt; df2 = pd.DataFrame([(&#39;parrot&#39;,   24.0, &#39;second&#39;),</span>
<span class="sd">        ...                     (&#39;lion&#39;,     80.5, 1),</span>
<span class="sd">        ...                     (&#39;monkey&#39;, np.nan, None)],</span>
<span class="sd">        ...                   columns=(&#39;name&#39;, &#39;max_speed&#39;, &#39;rank&#39;))</span>
<span class="sd">        &gt;&gt;&gt; df2.dtypes</span>
<span class="sd">        name          object</span>
<span class="sd">        max_speed    float64</span>
<span class="sd">        rank          object</span>
<span class="sd">        dtype: object</span>
<span class="sd">        &gt;&gt;&gt; df2.values</span>
<span class="sd">        array([[&#39;parrot&#39;, 24.0, &#39;second&#39;],</span>
<span class="sd">               [&#39;lion&#39;, 80.5, 1],</span>
<span class="sd">               [&#39;monkey&#39;, nan, None]], dtype=object)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_consolidate_inplace</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">as_array</span><span class="p">(</span><span class="n">transpose</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_AXIS_REVERSED</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_values</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;internal implementation&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">values</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_get_values</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># compat</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">values</span>

    <span class="k">def</span> <span class="nf">get_values</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return an ndarray after converting sparse values to dense.</span>

<span class="sd">        .. deprecated:: 0.25.0</span>
<span class="sd">            Use ``np.asarray(..)`` or :meth:`DataFrame.values` instead.</span>

<span class="sd">        This is the same as ``.values`` for non-sparse data. For sparse</span>
<span class="sd">        data contained in a `SparseArray`, the data are first</span>
<span class="sd">        converted to a dense representation.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        numpy.ndarray</span>
<span class="sd">            Numpy representation of DataFrame.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        values : Numpy representation of DataFrame.</span>
<span class="sd">        SparseArray : Container for sparse data.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; df = pd.DataFrame({&#39;a&#39;: [1, 2], &#39;b&#39;: [True, False],</span>
<span class="sd">        ...                    &#39;c&#39;: [1.0, 2.0]})</span>
<span class="sd">        &gt;&gt;&gt; df</span>
<span class="sd">           a      b    c</span>
<span class="sd">        0  1   True  1.0</span>
<span class="sd">        1  2  False  2.0</span>

<span class="sd">        &gt;&gt;&gt; df.get_values()</span>
<span class="sd">        array([[1, True, 1.0], [2, False, 2.0]], dtype=object)</span>

<span class="sd">        &gt;&gt;&gt; df = pd.DataFrame({&quot;a&quot;: pd.SparseArray([1, None, None]),</span>
<span class="sd">        ...                    &quot;c&quot;: [1.0, 2.0, 3.0]})</span>
<span class="sd">        &gt;&gt;&gt; df</span>
<span class="sd">             a    c</span>
<span class="sd">        0  1.0  1.0</span>
<span class="sd">        1  NaN  2.0</span>
<span class="sd">        2  NaN  3.0</span>

<span class="sd">        &gt;&gt;&gt; df.get_values()</span>
<span class="sd">        array([[ 1.,  1.],</span>
<span class="sd">               [nan,  2.],</span>
<span class="sd">               [nan,  3.]])</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
            <span class="s2">&quot;The &#39;get_values&#39; method is deprecated and will be removed in a &quot;</span>
            <span class="s2">&quot;future version. Use &#39;.values&#39; or &#39;np.asarray(..)&#39; instead.&quot;</span><span class="p">,</span>
            <span class="ne">FutureWarning</span><span class="p">,</span>
            <span class="n">stacklevel</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_internal_get_values</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">_internal_get_values</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">values</span>

    <span class="k">def</span> <span class="nf">get_dtype_counts</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return counts of unique dtypes in this object.</span>

<span class="sd">        .. deprecated:: 0.25.0</span>

<span class="sd">        Use `.dtypes.value_counts()` instead.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        dtype : Series</span>
<span class="sd">            Series with the count of columns with each dtype.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        dtypes : Return the dtypes in this object.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; a = [[&#39;a&#39;, 1, 1.0], [&#39;b&#39;, 2, 2.0], [&#39;c&#39;, 3, 3.0]]</span>
<span class="sd">        &gt;&gt;&gt; df = pd.DataFrame(a, columns=[&#39;str&#39;, &#39;int&#39;, &#39;float&#39;])</span>
<span class="sd">        &gt;&gt;&gt; df</span>
<span class="sd">          str  int  float</span>
<span class="sd">        0   a    1    1.0</span>
<span class="sd">        1   b    2    2.0</span>
<span class="sd">        2   c    3    3.0</span>

<span class="sd">        &gt;&gt;&gt; df.get_dtype_counts()</span>
<span class="sd">        float64    1</span>
<span class="sd">        int64      1</span>
<span class="sd">        object     1</span>
<span class="sd">        dtype: int64</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
            <span class="s2">&quot;`get_dtype_counts` has been deprecated and will be &quot;</span>
            <span class="s2">&quot;removed in a future version. For DataFrames use &quot;</span>
            <span class="s2">&quot;`.dtypes.value_counts()&quot;</span><span class="p">,</span>
            <span class="ne">FutureWarning</span><span class="p">,</span>
            <span class="n">stacklevel</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="kn">from</span> <span class="nn">pandas</span> <span class="k">import</span> <span class="n">Series</span>

        <span class="k">return</span> <span class="n">Series</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">get_dtype_counts</span><span class="p">())</span>

    <span class="k">def</span> <span class="nf">get_ftype_counts</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return counts of unique ftypes in this object.</span>

<span class="sd">        .. deprecated:: 0.23.0</span>

<span class="sd">        This is useful for SparseDataFrame or for DataFrames containing</span>
<span class="sd">        sparse arrays.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        dtype : Series</span>
<span class="sd">            Series with the count of columns with each type and</span>
<span class="sd">            sparsity (dense/sparse).</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        ftypes : Return ftypes (indication of sparse/dense and dtype) in</span>
<span class="sd">            this object.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; a = [[&#39;a&#39;, 1, 1.0], [&#39;b&#39;, 2, 2.0], [&#39;c&#39;, 3, 3.0]]</span>
<span class="sd">        &gt;&gt;&gt; df = pd.DataFrame(a, columns=[&#39;str&#39;, &#39;int&#39;, &#39;float&#39;])</span>
<span class="sd">        &gt;&gt;&gt; df</span>
<span class="sd">          str  int  float</span>
<span class="sd">        0   a    1    1.0</span>
<span class="sd">        1   b    2    2.0</span>
<span class="sd">        2   c    3    3.0</span>

<span class="sd">        &gt;&gt;&gt; df.get_ftype_counts()  # doctest: +SKIP</span>
<span class="sd">        float64:dense    1</span>
<span class="sd">        int64:dense      1</span>
<span class="sd">        object:dense     1</span>
<span class="sd">        dtype: int64</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
            <span class="s2">&quot;get_ftype_counts is deprecated and will &quot;</span> <span class="s2">&quot;be removed in a future version&quot;</span><span class="p">,</span>
            <span class="ne">FutureWarning</span><span class="p">,</span>
            <span class="n">stacklevel</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="kn">from</span> <span class="nn">pandas</span> <span class="k">import</span> <span class="n">Series</span>

        <span class="k">return</span> <span class="n">Series</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">get_ftype_counts</span><span class="p">())</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">dtypes</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the dtypes in the DataFrame.</span>

<span class="sd">        This returns a Series with the data type of each column.</span>
<span class="sd">        The result&#39;s index is the original DataFrame&#39;s columns. Columns</span>
<span class="sd">        with mixed types are stored with the ``object`` dtype. See</span>
<span class="sd">        :ref:`the User Guide &lt;basics.dtypes&gt;` for more.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        pandas.Series</span>
<span class="sd">            The data type of each column.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        DataFrame.ftypes : Dtype and sparsity information.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; df = pd.DataFrame({&#39;float&#39;: [1.0],</span>
<span class="sd">        ...                    &#39;int&#39;: [1],</span>
<span class="sd">        ...                    &#39;datetime&#39;: [pd.Timestamp(&#39;20180310&#39;)],</span>
<span class="sd">        ...                    &#39;string&#39;: [&#39;foo&#39;]})</span>
<span class="sd">        &gt;&gt;&gt; df.dtypes</span>
<span class="sd">        float              float64</span>
<span class="sd">        int                  int64</span>
<span class="sd">        datetime    datetime64[ns]</span>
<span class="sd">        string              object</span>
<span class="sd">        dtype: object</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">pandas</span> <span class="k">import</span> <span class="n">Series</span>

        <span class="k">return</span> <span class="n">Series</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">get_dtypes</span><span class="p">(),</span> <span class="n">index</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_info_axis</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">object_</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">ftypes</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the ftypes (indication of sparse/dense and dtype) in DataFrame.</span>

<span class="sd">        .. deprecated:: 0.25.0</span>
<span class="sd">           Use :func:`dtypes` instead.</span>

<span class="sd">        This returns a Series with the data type of each column.</span>
<span class="sd">        The result&#39;s index is the original DataFrame&#39;s columns. Columns</span>
<span class="sd">        with mixed types are stored with the ``object`` dtype.  See</span>
<span class="sd">        :ref:`the User Guide &lt;basics.dtypes&gt;` for more.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        pandas.Series</span>
<span class="sd">            The data type and indication of sparse/dense of each column.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        DataFrame.dtypes: Series with just dtype information.</span>
<span class="sd">        SparseDataFrame : Container for sparse tabular data.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        Sparse data should have the same dtypes as its dense representation.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; arr = np.random.RandomState(0).randn(100, 4)</span>
<span class="sd">        &gt;&gt;&gt; arr[arr &lt; .8] = np.nan</span>
<span class="sd">        &gt;&gt;&gt; pd.DataFrame(arr).ftypes</span>
<span class="sd">        0    float64:dense</span>
<span class="sd">        1    float64:dense</span>
<span class="sd">        2    float64:dense</span>
<span class="sd">        3    float64:dense</span>
<span class="sd">        dtype: object</span>

<span class="sd">        &gt;&gt;&gt; pd.SparseDataFrame(arr).ftypes  # doctest: +SKIP</span>
<span class="sd">        0    float64:sparse</span>
<span class="sd">        1    float64:sparse</span>
<span class="sd">        2    float64:sparse</span>
<span class="sd">        3    float64:sparse</span>
<span class="sd">        dtype: object</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
            <span class="s2">&quot;DataFrame.ftypes is deprecated and will &quot;</span>
            <span class="s2">&quot;be removed in a future version. &quot;</span>
            <span class="s2">&quot;Use DataFrame.dtypes instead.&quot;</span><span class="p">,</span>
            <span class="ne">FutureWarning</span><span class="p">,</span>
            <span class="n">stacklevel</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="kn">from</span> <span class="nn">pandas</span> <span class="k">import</span> <span class="n">Series</span>

        <span class="k">return</span> <span class="n">Series</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">get_ftypes</span><span class="p">(),</span> <span class="n">index</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_info_axis</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">object_</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">as_blocks</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Convert the frame to a dict of dtype -&gt; Constructor Types that each has</span>
<span class="sd">        a homogeneous dtype.</span>

<span class="sd">        .. deprecated:: 0.21.0</span>

<span class="sd">        NOTE: the dtypes of the blocks WILL BE PRESERVED HERE (unlike in</span>
<span class="sd">              as_matrix)</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        copy : boolean, default True</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        values : a dict of dtype -&gt; Constructor Types</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
            <span class="s2">&quot;as_blocks is deprecated and will &quot;</span> <span class="s2">&quot;be removed in a future version&quot;</span><span class="p">,</span>
            <span class="ne">FutureWarning</span><span class="p">,</span>
            <span class="n">stacklevel</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_to_dict_of_blocks</span><span class="p">(</span><span class="n">copy</span><span class="o">=</span><span class="n">copy</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">blocks</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Internal property, property synonym for as_blocks().</span>

<span class="sd">        .. deprecated:: 0.21.0</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">as_blocks</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">_to_dict_of_blocks</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a dict of dtype -&gt; Constructor Types that</span>
<span class="sd">        each is a homogeneous dtype.</span>

<span class="sd">        Internal ONLY</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">{</span>
            <span class="n">k</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_constructor</span><span class="p">(</span><span class="n">v</span><span class="p">)</span><span class="o">.</span><span class="n">__finalize__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">to_dict</span><span class="p">(</span><span class="n">copy</span><span class="o">=</span><span class="n">copy</span><span class="p">)</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
        <span class="p">}</span>

    <span class="k">def</span> <span class="nf">astype</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dtype</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">errors</span><span class="o">=</span><span class="s2">&quot;raise&quot;</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Cast a pandas object to a specified dtype ``dtype``.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        dtype : data type, or dict of column name -&gt; data type</span>
<span class="sd">            Use a numpy.dtype or Python type to cast entire pandas object to</span>
<span class="sd">            the same type. Alternatively, use {col: dtype, ...}, where col is a</span>
<span class="sd">            column label and dtype is a numpy.dtype or Python type to cast one</span>
<span class="sd">            or more of the DataFrame&#39;s columns to column-specific types.</span>
<span class="sd">        copy : bool, default True</span>
<span class="sd">            Return a copy when ``copy=True`` (be very careful setting</span>
<span class="sd">            ``copy=False`` as changes to values then may propagate to other</span>
<span class="sd">            pandas objects).</span>
<span class="sd">        errors : {&#39;raise&#39;, &#39;ignore&#39;}, default &#39;raise&#39;</span>
<span class="sd">            Control raising of exceptions on invalid data for provided dtype.</span>

<span class="sd">            - ``raise`` : allow exceptions to be raised</span>
<span class="sd">            - ``ignore`` : suppress exceptions. On error return original object</span>

<span class="sd">            .. versionadded:: 0.20.0</span>

<span class="sd">        kwargs : keyword arguments to pass on to the constructor</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        casted : same type as caller</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        to_datetime : Convert argument to datetime.</span>
<span class="sd">        to_timedelta : Convert argument to timedelta.</span>
<span class="sd">        to_numeric : Convert argument to a numeric type.</span>
<span class="sd">        numpy.ndarray.astype : Cast a numpy array to a specified type.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        Create a DataFrame:</span>

<span class="sd">        &gt;&gt;&gt; d = {&#39;col1&#39;: [1, 2], &#39;col2&#39;: [3, 4]}</span>
<span class="sd">        &gt;&gt;&gt; df = pd.DataFrame(data=d)</span>
<span class="sd">        &gt;&gt;&gt; df.dtypes</span>
<span class="sd">        col1    int64</span>
<span class="sd">        col2    int64</span>
<span class="sd">        dtype: object</span>

<span class="sd">        Cast all columns to int32:</span>

<span class="sd">        &gt;&gt;&gt; df.astype(&#39;int32&#39;).dtypes</span>
<span class="sd">        col1    int32</span>
<span class="sd">        col2    int32</span>
<span class="sd">        dtype: object</span>

<span class="sd">        Cast col1 to int32 using a dictionary:</span>

<span class="sd">        &gt;&gt;&gt; df.astype({&#39;col1&#39;: &#39;int32&#39;}).dtypes</span>
<span class="sd">        col1    int32</span>
<span class="sd">        col2    int64</span>
<span class="sd">        dtype: object</span>

<span class="sd">        Create a series:</span>

<span class="sd">        &gt;&gt;&gt; ser = pd.Series([1, 2], dtype=&#39;int32&#39;)</span>
<span class="sd">        &gt;&gt;&gt; ser</span>
<span class="sd">        0    1</span>
<span class="sd">        1    2</span>
<span class="sd">        dtype: int32</span>
<span class="sd">        &gt;&gt;&gt; ser.astype(&#39;int64&#39;)</span>
<span class="sd">        0    1</span>
<span class="sd">        1    2</span>
<span class="sd">        dtype: int64</span>

<span class="sd">        Convert to categorical type:</span>

<span class="sd">        &gt;&gt;&gt; ser.astype(&#39;category&#39;)</span>
<span class="sd">        0    1</span>
<span class="sd">        1    2</span>
<span class="sd">        dtype: category</span>
<span class="sd">        Categories (2, int64): [1, 2]</span>

<span class="sd">        Convert to ordered categorical type with custom ordering:</span>

<span class="sd">        &gt;&gt;&gt; cat_dtype = pd.api.types.CategoricalDtype(</span>
<span class="sd">        ...                     categories=[2, 1], ordered=True)</span>
<span class="sd">        &gt;&gt;&gt; ser.astype(cat_dtype)</span>
<span class="sd">        0    1</span>
<span class="sd">        1    2</span>
<span class="sd">        dtype: category</span>
<span class="sd">        Categories (2, int64): [2 &lt; 1]</span>

<span class="sd">        Note that using ``copy=False`` and changing data on a new</span>
<span class="sd">        pandas object may propagate changes:</span>

<span class="sd">        &gt;&gt;&gt; s1 = pd.Series([1,2])</span>
<span class="sd">        &gt;&gt;&gt; s2 = s1.astype(&#39;int64&#39;, copy=False)</span>
<span class="sd">        &gt;&gt;&gt; s2[0] = 10</span>
<span class="sd">        &gt;&gt;&gt; s1  # note that s1[0] has changed too</span>
<span class="sd">        0    10</span>
<span class="sd">        1     2</span>
<span class="sd">        dtype: int64</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">is_dict_like</span><span class="p">(</span><span class="n">dtype</span><span class="p">):</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>  <span class="c1"># i.e. Series</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">dtype</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">dtype</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span>
                        <span class="s2">&quot;Only the Series name can be used for &quot;</span>
                        <span class="s2">&quot;the key in Series dtype mappings.&quot;</span>
                    <span class="p">)</span>
                <span class="n">new_type</span> <span class="o">=</span> <span class="n">dtype</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">]</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">new_type</span><span class="p">,</span> <span class="n">copy</span><span class="p">,</span> <span class="n">errors</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

            <span class="k">for</span> <span class="n">col_name</span> <span class="ow">in</span> <span class="n">dtype</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                <span class="k">if</span> <span class="n">col_name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span>
                        <span class="s2">&quot;Only a column name can be used for the &quot;</span>
                        <span class="s2">&quot;key in a dtype mappings argument.&quot;</span>
                    <span class="p">)</span>
            <span class="n">results</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">col_name</span><span class="p">,</span> <span class="n">col</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="k">if</span> <span class="n">col_name</span> <span class="ow">in</span> <span class="n">dtype</span><span class="p">:</span>
                    <span class="n">results</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                        <span class="n">col</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span>
                            <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">[</span><span class="n">col_name</span><span class="p">],</span> <span class="n">copy</span><span class="o">=</span><span class="n">copy</span><span class="p">,</span> <span class="n">errors</span><span class="o">=</span><span class="n">errors</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span>
                        <span class="p">)</span>
                    <span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">results</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">results</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">col</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span> <span class="k">if</span> <span class="n">copy</span> <span class="k">else</span> <span class="n">col</span><span class="p">))</span>

        <span class="k">elif</span> <span class="n">is_extension_array_dtype</span><span class="p">(</span><span class="n">dtype</span><span class="p">)</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="c1"># GH 18099/22869: columnwise conversion to extension dtype</span>
            <span class="c1"># GH 24704: use iloc to handle duplicate column names</span>
            <span class="n">results</span> <span class="o">=</span> <span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">iloc</span><span class="p">[:,</span> <span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">dtype</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="n">copy</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">columns</span><span class="p">))</span>
            <span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># else, only a single dtype is given</span>
            <span class="n">new_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span>
                <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="n">copy</span><span class="p">,</span> <span class="n">errors</span><span class="o">=</span><span class="n">errors</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span>
            <span class="p">)</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_constructor</span><span class="p">(</span><span class="n">new_data</span><span class="p">)</span><span class="o">.</span><span class="n">__finalize__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

        <span class="c1"># GH 19920: retain column metadata after concat</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">(</span><span class="n">results</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">result</span><span class="o">.</span><span class="n">columns</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">columns</span>
        <span class="k">return</span> <span class="n">result</span>

    <span class="k">def</span> <span class="nf">copy</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">deep</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Make a copy of this object&#39;s indices and data.</span>

<span class="sd">        When ``deep=True`` (default), a new object will be created with a</span>
<span class="sd">        copy of the calling object&#39;s data and indices. Modifications to</span>
<span class="sd">        the data or indices of the copy will not be reflected in the</span>
<span class="sd">        original object (see notes below).</span>

<span class="sd">        When ``deep=False``, a new object will be created without copying</span>
<span class="sd">        the calling object&#39;s data or index (only references to the data</span>
<span class="sd">        and index are copied). Any changes to the data of the original</span>
<span class="sd">        will be reflected in the shallow copy (and vice versa).</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        deep : bool, default True</span>
<span class="sd">            Make a deep copy, including a copy of the data and the indices.</span>
<span class="sd">            With ``deep=False`` neither the indices nor the data are copied.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        copy : Series or DataFrame</span>
<span class="sd">            Object type matches caller.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        When ``deep=True``, data is copied but actual Python objects</span>
<span class="sd">        will not be copied recursively, only the reference to the object.</span>
<span class="sd">        This is in contrast to `copy.deepcopy` in the Standard Library,</span>
<span class="sd">        which recursively copies object data (see examples below).</span>

<span class="sd">        While ``Index`` objects are copied when ``deep=True``, the underlying</span>
<span class="sd">        numpy array is not copied for performance reasons. Since ``Index`` is</span>
<span class="sd">        immutable, the underlying data can be safely shared and a copy</span>
<span class="sd">        is not needed.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; s = pd.Series([1, 2], index=[&quot;a&quot;, &quot;b&quot;])</span>
<span class="sd">        &gt;&gt;&gt; s</span>
<span class="sd">        a    1</span>
<span class="sd">        b    2</span>
<span class="sd">        dtype: int64</span>

<span class="sd">        &gt;&gt;&gt; s_copy = s.copy()</span>
<span class="sd">        &gt;&gt;&gt; s_copy</span>
<span class="sd">        a    1</span>
<span class="sd">        b    2</span>
<span class="sd">        dtype: int64</span>

<span class="sd">        **Shallow copy versus default (deep) copy:**</span>

<span class="sd">        &gt;&gt;&gt; s = pd.Series([1, 2], index=[&quot;a&quot;, &quot;b&quot;])</span>
<span class="sd">        &gt;&gt;&gt; deep = s.copy()</span>
<span class="sd">        &gt;&gt;&gt; shallow = s.copy(deep=False)</span>

<span class="sd">        Shallow copy shares data and index with original.</span>

<span class="sd">        &gt;&gt;&gt; s is shallow</span>
<span class="sd">        False</span>
<span class="sd">        &gt;&gt;&gt; s.values is shallow.values and s.index is shallow.index</span>
<span class="sd">        True</span>

<span class="sd">        Deep copy has own copy of data and index.</span>

<span class="sd">        &gt;&gt;&gt; s is deep</span>
<span class="sd">        False</span>
<span class="sd">        &gt;&gt;&gt; s.values is deep.values or s.index is deep.index</span>
<span class="sd">        False</span>

<span class="sd">        Updates to the data shared by shallow copy and original is reflected</span>
<span class="sd">        in both; deep copy remains unchanged.</span>

<span class="sd">        &gt;&gt;&gt; s[0] = 3</span>
<span class="sd">        &gt;&gt;&gt; shallow[1] = 4</span>
<span class="sd">        &gt;&gt;&gt; s</span>
<span class="sd">        a    3</span>
<span class="sd">        b    4</span>
<span class="sd">        dtype: int64</span>
<span class="sd">        &gt;&gt;&gt; shallow</span>
<span class="sd">        a    3</span>
<span class="sd">        b    4</span>
<span class="sd">        dtype: int64</span>
<span class="sd">        &gt;&gt;&gt; deep</span>
<span class="sd">        a    1</span>
<span class="sd">        b    2</span>
<span class="sd">        dtype: int64</span>

<span class="sd">        Note that when copying an object containing Python objects, a deep copy</span>
<span class="sd">        will copy the data, but will not do so recursively. Updating a nested</span>
<span class="sd">        data object will be reflected in the deep copy.</span>

<span class="sd">        &gt;&gt;&gt; s = pd.Series([[1, 2], [3, 4]])</span>
<span class="sd">        &gt;&gt;&gt; deep = s.copy()</span>
<span class="sd">        &gt;&gt;&gt; s[0][0] = 10</span>
<span class="sd">        &gt;&gt;&gt; s</span>
<span class="sd">        0    [10, 2]</span>
<span class="sd">        1     [3, 4]</span>
<span class="sd">        dtype: object</span>
<span class="sd">        &gt;&gt;&gt; deep</span>
<span class="sd">        0    [10, 2]</span>
<span class="sd">        1     [3, 4]</span>
<span class="sd">        dtype: object</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">deep</span><span class="o">=</span><span class="n">deep</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_constructor</span><span class="p">(</span><span class="n">data</span><span class="p">)</span><span class="o">.</span><span class="n">__finalize__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__copy__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">deep</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">deep</span><span class="o">=</span><span class="n">deep</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__deepcopy__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">memo</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        memo, default None</span>
<span class="sd">            Standard signature. Unused</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">memo</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">memo</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">deep</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_convert</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">datetime</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">numeric</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">timedelta</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">coerce</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">True</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Attempt to infer better dtype for object columns</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        datetime : boolean, default False</span>
<span class="sd">            If True, convert to date where possible.</span>
<span class="sd">        numeric : boolean, default False</span>
<span class="sd">            If True, attempt to convert to numbers (including strings), with</span>
<span class="sd">            unconvertible values becoming NaN.</span>
<span class="sd">        timedelta : boolean, default False</span>
<span class="sd">            If True, convert to timedelta where possible.</span>
<span class="sd">        coerce : boolean, default False</span>
<span class="sd">            If True, force conversion with unconvertible values converted to</span>
<span class="sd">            nulls (NaN or NaT)</span>
<span class="sd">        copy : boolean, default True</span>
<span class="sd">            If True, return a copy even if no copy is necessary (e.g. no</span>
<span class="sd">            conversion was done). Note: This is meant for internal use, and</span>
<span class="sd">            should not be confused with inplace.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        converted : same as input object</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_constructor</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">convert</span><span class="p">(</span>
                <span class="n">datetime</span><span class="o">=</span><span class="n">datetime</span><span class="p">,</span>
                <span class="n">numeric</span><span class="o">=</span><span class="n">numeric</span><span class="p">,</span>
                <span class="n">timedelta</span><span class="o">=</span><span class="n">timedelta</span><span class="p">,</span>
                <span class="n">coerce</span><span class="o">=</span><span class="n">coerce</span><span class="p">,</span>
                <span class="n">copy</span><span class="o">=</span><span class="n">copy</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="p">)</span><span class="o">.</span><span class="n">__finalize__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">infer_objects</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Attempt to infer better dtypes for object columns.</span>

<span class="sd">        Attempts soft conversion of object-dtyped</span>
<span class="sd">        columns, leaving non-object and unconvertible</span>
<span class="sd">        columns unchanged. The inference rules are the</span>
<span class="sd">        same as during normal Series/DataFrame construction.</span>

<span class="sd">        .. versionadded:: 0.21.0</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        converted : same type as input object</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        to_datetime : Convert argument to datetime.</span>
<span class="sd">        to_timedelta : Convert argument to timedelta.</span>
<span class="sd">        to_numeric : Convert argument to numeric type.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; df = pd.DataFrame({&quot;A&quot;: [&quot;a&quot;, 1, 2, 3]})</span>
<span class="sd">        &gt;&gt;&gt; df = df.iloc[1:]</span>
<span class="sd">        &gt;&gt;&gt; df</span>
<span class="sd">           A</span>
<span class="sd">        1  1</span>
<span class="sd">        2  2</span>
<span class="sd">        3  3</span>

<span class="sd">        &gt;&gt;&gt; df.dtypes</span>
<span class="sd">        A    object</span>
<span class="sd">        dtype: object</span>

<span class="sd">        &gt;&gt;&gt; df.infer_objects().dtypes</span>
<span class="sd">        A    int64</span>
<span class="sd">        dtype: object</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># numeric=False necessary to only soft convert;</span>
        <span class="c1"># python objects will still be converted to</span>
        <span class="c1"># native numpy numeric types</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_constructor</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">convert</span><span class="p">(</span>
                <span class="n">datetime</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">numeric</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">timedelta</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">coerce</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">True</span>
            <span class="p">)</span>
        <span class="p">)</span><span class="o">.</span><span class="n">__finalize__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="c1"># ----------------------------------------------------------------------</span>
    <span class="c1"># Filling NA&#39;s</span>

    <span class="k">def</span> <span class="nf">fillna</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">value</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">method</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">axis</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">inplace</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">limit</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">downcast</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Fill NA/NaN values using the specified method.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        value : scalar, dict, Series, or DataFrame</span>
<span class="sd">            Value to use to fill holes (e.g. 0), alternately a</span>
<span class="sd">            dict/Series/DataFrame of values specifying which value to use for</span>
<span class="sd">            each index (for a Series) or column (for a DataFrame).  Values not</span>
<span class="sd">            in the dict/Series/DataFrame will not be filled. This value cannot</span>
<span class="sd">            be a list.</span>
<span class="sd">        method : {&#39;backfill&#39;, &#39;bfill&#39;, &#39;pad&#39;, &#39;ffill&#39;, None}, default None</span>
<span class="sd">            Method to use for filling holes in reindexed Series</span>
<span class="sd">            pad / ffill: propagate last valid observation forward to next valid</span>
<span class="sd">            backfill / bfill: use next valid observation to fill gap.</span>
<span class="sd">        axis : %(axes_single_arg)s</span>
<span class="sd">            Axis along which to fill missing values.</span>
<span class="sd">        inplace : bool, default False</span>
<span class="sd">            If True, fill in-place. Note: this will modify any</span>
<span class="sd">            other views on this object (e.g., a no-copy slice for a column in a</span>
<span class="sd">            DataFrame).</span>
<span class="sd">        limit : int, default None</span>
<span class="sd">            If method is specified, this is the maximum number of consecutive</span>
<span class="sd">            NaN values to forward/backward fill. In other words, if there is</span>
<span class="sd">            a gap with more than this number of consecutive NaNs, it will only</span>
<span class="sd">            be partially filled. If method is not specified, this is the</span>
<span class="sd">            maximum number of entries along the entire axis where NaNs will be</span>
<span class="sd">            filled. Must be greater than 0 if not None.</span>
<span class="sd">        downcast : dict, default is None</span>
<span class="sd">            A dict of item-&gt;dtype of what to downcast if possible,</span>
<span class="sd">            or the string &#39;infer&#39; which will try to downcast to an appropriate</span>
<span class="sd">            equal type (e.g. float64 to int64 if possible).</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        %(klass)s</span>
<span class="sd">            Object with missing values filled.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        interpolate : Fill NaN values using interpolation.</span>
<span class="sd">        reindex : Conform object to new index.</span>
<span class="sd">        asfreq : Convert TimeSeries to specified frequency.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; df = pd.DataFrame([[np.nan, 2, np.nan, 0],</span>
<span class="sd">        ...                    [3, 4, np.nan, 1],</span>
<span class="sd">        ...                    [np.nan, np.nan, np.nan, 5],</span>
<span class="sd">        ...                    [np.nan, 3, np.nan, 4]],</span>
<span class="sd">        ...                   columns=list(&#39;ABCD&#39;))</span>
<span class="sd">        &gt;&gt;&gt; df</span>
<span class="sd">             A    B   C  D</span>
<span class="sd">        0  NaN  2.0 NaN  0</span>
<span class="sd">        1  3.0  4.0 NaN  1</span>
<span class="sd">        2  NaN  NaN NaN  5</span>
<span class="sd">        3  NaN  3.0 NaN  4</span>

<span class="sd">        Replace all NaN elements with 0s.</span>

<span class="sd">        &gt;&gt;&gt; df.fillna(0)</span>
<span class="sd">            A   B   C   D</span>
<span class="sd">        0   0.0 2.0 0.0 0</span>
<span class="sd">        1   3.0 4.0 0.0 1</span>
<span class="sd">        2   0.0 0.0 0.0 5</span>
<span class="sd">        3   0.0 3.0 0.0 4</span>

<span class="sd">        We can also propagate non-null values forward or backward.</span>

<span class="sd">        &gt;&gt;&gt; df.fillna(method=&#39;ffill&#39;)</span>
<span class="sd">            A   B   C   D</span>
<span class="sd">        0   NaN 2.0 NaN 0</span>
<span class="sd">        1   3.0 4.0 NaN 1</span>
<span class="sd">        2   3.0 4.0 NaN 5</span>
<span class="sd">        3   3.0 3.0 NaN 4</span>

<span class="sd">        Replace all NaN elements in column &#39;A&#39;, &#39;B&#39;, &#39;C&#39;, and &#39;D&#39;, with 0, 1,</span>
<span class="sd">        2, and 3 respectively.</span>

<span class="sd">        &gt;&gt;&gt; values = {&#39;A&#39;: 0, &#39;B&#39;: 1, &#39;C&#39;: 2, &#39;D&#39;: 3}</span>
<span class="sd">        &gt;&gt;&gt; df.fillna(value=values)</span>
<span class="sd">            A   B   C   D</span>
<span class="sd">        0   0.0 2.0 2.0 0</span>
<span class="sd">        1   3.0 4.0 2.0 1</span>
<span class="sd">        2   0.0 1.0 2.0 5</span>
<span class="sd">        3   0.0 3.0 2.0 4</span>

<span class="sd">        Only replace the first NaN element.</span>

<span class="sd">        &gt;&gt;&gt; df.fillna(value=values, limit=1)</span>
<span class="sd">            A   B   C   D</span>
<span class="sd">        0   0.0 2.0 2.0 0</span>
<span class="sd">        1   3.0 4.0 NaN 1</span>
<span class="sd">        2   NaN 1.0 NaN 5</span>
<span class="sd">        3   NaN 3.0 NaN 4</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">inplace</span> <span class="o">=</span> <span class="n">validate_bool_kwarg</span><span class="p">(</span><span class="n">inplace</span><span class="p">,</span> <span class="s2">&quot;inplace&quot;</span><span class="p">)</span>
        <span class="n">value</span><span class="p">,</span> <span class="n">method</span> <span class="o">=</span> <span class="n">validate_fillna_kwargs</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">method</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_consolidate_inplace</span><span class="p">()</span>

        <span class="c1"># set the default here, so functions examining the signaure</span>
        <span class="c1"># can detect if something was set (e.g. in groupby) (GH9221)</span>
        <span class="k">if</span> <span class="n">axis</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">axis</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">axis</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_axis_number</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span>

        <span class="kn">from</span> <span class="nn">pandas</span> <span class="k">import</span> <span class="n">DataFrame</span>

        <span class="k">if</span> <span class="n">value</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_mixed_type</span> <span class="ow">and</span> <span class="n">axis</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">inplace</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">()</span>
                <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">fillna</span><span class="p">(</span><span class="n">method</span><span class="o">=</span><span class="n">method</span><span class="p">,</span> <span class="n">limit</span><span class="o">=</span><span class="n">limit</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>

                <span class="c1"># need to downcast here because of all of the transposes</span>
                <span class="n">result</span><span class="o">.</span><span class="n">_data</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">downcast</span><span class="p">()</span>

                <span class="k">return</span> <span class="n">result</span>

            <span class="n">new_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">interpolate</span><span class="p">(</span>
                <span class="n">method</span><span class="o">=</span><span class="n">method</span><span class="p">,</span>
                <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span>
                <span class="n">limit</span><span class="o">=</span><span class="n">limit</span><span class="p">,</span>
                <span class="n">inplace</span><span class="o">=</span><span class="n">inplace</span><span class="p">,</span>
                <span class="n">coerce</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">downcast</span><span class="o">=</span><span class="n">downcast</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_get_axis</span><span class="p">(</span><span class="n">axis</span><span class="p">))</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="p">(</span><span class="nb">dict</span><span class="p">,</span> <span class="n">ABCSeries</span><span class="p">)):</span>
                    <span class="kn">from</span> <span class="nn">pandas</span> <span class="k">import</span> <span class="n">Series</span>

                    <span class="n">value</span> <span class="o">=</span> <span class="n">Series</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
                <span class="k">elif</span> <span class="ow">not</span> <span class="n">is_list_like</span><span class="p">(</span><span class="n">value</span><span class="p">):</span>
                    <span class="k">pass</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                        <span class="s1">&#39;&quot;value&quot; parameter must be a scalar, dict &#39;</span>
                        <span class="s2">&quot;or Series, but you passed a &quot;</span>
                        <span class="s1">&#39;&quot;</span><span class="si">{0}</span><span class="s1">&quot;&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">value</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="p">)</span>
                    <span class="p">)</span>

                <span class="n">new_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">fillna</span><span class="p">(</span>
                    <span class="n">value</span><span class="o">=</span><span class="n">value</span><span class="p">,</span> <span class="n">limit</span><span class="o">=</span><span class="n">limit</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="n">inplace</span><span class="p">,</span> <span class="n">downcast</span><span class="o">=</span><span class="n">downcast</span>
                <span class="p">)</span>

            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="p">(</span><span class="nb">dict</span><span class="p">,</span> <span class="n">ABCSeries</span><span class="p">)):</span>
                <span class="k">if</span> <span class="n">axis</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span>
                        <span class="s2">&quot;Currently only can fill &quot;</span>
                        <span class="s2">&quot;with dict/Series column &quot;</span>
                        <span class="s2">&quot;by column&quot;</span>
                    <span class="p">)</span>

                <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span> <span class="k">if</span> <span class="n">inplace</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
                <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">value</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                    <span class="k">if</span> <span class="n">k</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">result</span><span class="p">:</span>
                        <span class="k">continue</span>
                    <span class="n">obj</span> <span class="o">=</span> <span class="n">result</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>
                    <span class="n">obj</span><span class="o">.</span><span class="n">fillna</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">limit</span><span class="o">=</span><span class="n">limit</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">downcast</span><span class="o">=</span><span class="n">downcast</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">result</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">inplace</span> <span class="k">else</span> <span class="kc">None</span>

            <span class="k">elif</span> <span class="ow">not</span> <span class="n">is_list_like</span><span class="p">(</span><span class="n">value</span><span class="p">):</span>
                <span class="n">new_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">fillna</span><span class="p">(</span>
                    <span class="n">value</span><span class="o">=</span><span class="n">value</span><span class="p">,</span> <span class="n">limit</span><span class="o">=</span><span class="n">limit</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="n">inplace</span><span class="p">,</span> <span class="n">downcast</span><span class="o">=</span><span class="n">downcast</span>
                <span class="p">)</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">DataFrame</span><span class="p">)</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                <span class="n">new_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">notna</span><span class="p">(),</span> <span class="n">value</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;invalid fill value with a </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="nb">type</span><span class="p">(</span><span class="n">value</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">inplace</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_update_inplace</span><span class="p">(</span><span class="n">new_data</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_constructor</span><span class="p">(</span><span class="n">new_data</span><span class="p">)</span><span class="o">.</span><span class="n">__finalize__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">ffill</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">limit</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">downcast</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Synonym for :meth:`DataFrame.fillna` with ``method=&#39;ffill&#39;``.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        %(klass)s</span>
<span class="sd">            Object with missing values filled.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">fillna</span><span class="p">(</span>
            <span class="n">method</span><span class="o">=</span><span class="s2">&quot;ffill&quot;</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="n">inplace</span><span class="p">,</span> <span class="n">limit</span><span class="o">=</span><span class="n">limit</span><span class="p">,</span> <span class="n">downcast</span><span class="o">=</span><span class="n">downcast</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">bfill</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">limit</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">downcast</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Synonym for :meth:`DataFrame.fillna` with ``method=&#39;bfill&#39;``.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        %(klass)s</span>
<span class="sd">            Object with missing values filled.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">fillna</span><span class="p">(</span>
            <span class="n">method</span><span class="o">=</span><span class="s2">&quot;bfill&quot;</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="n">inplace</span><span class="p">,</span> <span class="n">limit</span><span class="o">=</span><span class="n">limit</span><span class="p">,</span> <span class="n">downcast</span><span class="o">=</span><span class="n">downcast</span>
        <span class="p">)</span>

    <span class="n">_shared_docs</span><span class="p">[</span>
        <span class="s2">&quot;replace&quot;</span>
    <span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;</span>
<span class="s2">        Replace values given in `to_replace` with `value`.</span>

<span class="s2">        Values of the </span><span class="si">%(klass)s</span><span class="s2"> are replaced with other values dynamically.</span>
<span class="s2">        This differs from updating with ``.loc`` or ``.iloc``, which require</span>
<span class="s2">        you to specify a location to update with some value.</span>

<span class="s2">        Parameters</span>
<span class="s2">        ----------</span>
<span class="s2">        to_replace : str, regex, list, dict, Series, int, float, or None</span>
<span class="s2">            How to find the values that will be replaced.</span>

<span class="s2">            * numeric, str or regex:</span>

<span class="s2">                - numeric: numeric values equal to `to_replace` will be</span>
<span class="s2">                  replaced with `value`</span>
<span class="s2">                - str: string exactly matching `to_replace` will be replaced</span>
<span class="s2">                  with `value`</span>
<span class="s2">                - regex: regexs matching `to_replace` will be replaced with</span>
<span class="s2">                  `value`</span>

<span class="s2">            * list of str, regex, or numeric:</span>

<span class="s2">                - First, if `to_replace` and `value` are both lists, they</span>
<span class="s2">                  **must** be the same length.</span>
<span class="s2">                - Second, if ``regex=True`` then all of the strings in **both**</span>
<span class="s2">                  lists will be interpreted as regexs otherwise they will match</span>
<span class="s2">                  directly. This doesn&#39;t matter much for `value` since there</span>
<span class="s2">                  are only a few possible substitution regexes you can use.</span>
<span class="s2">                - str, regex and numeric rules apply as above.</span>

<span class="s2">            * dict:</span>

<span class="s2">                - Dicts can be used to specify different replacement values</span>
<span class="s2">                  for different existing values. For example,</span>
<span class="s2">                  ``{&#39;a&#39;: &#39;b&#39;, &#39;y&#39;: &#39;z&#39;}`` replaces the value &#39;a&#39; with &#39;b&#39; and</span>
<span class="s2">                  &#39;y&#39; with &#39;z&#39;. To use a dict in this way the `value`</span>
<span class="s2">                  parameter should be `None`.</span>
<span class="s2">                - For a DataFrame a dict can specify that different values</span>
<span class="s2">                  should be replaced in different columns. For example,</span>
<span class="s2">                  ``{&#39;a&#39;: 1, &#39;b&#39;: &#39;z&#39;}`` looks for the value 1 in column &#39;a&#39;</span>
<span class="s2">                  and the value &#39;z&#39; in column &#39;b&#39; and replaces these values</span>
<span class="s2">                  with whatever is specified in `value`. The `value` parameter</span>
<span class="s2">                  should not be ``None`` in this case. You can treat this as a</span>
<span class="s2">                  special case of passing two lists except that you are</span>
<span class="s2">                  specifying the column to search in.</span>
<span class="s2">                - For a DataFrame nested dictionaries, e.g.,</span>
<span class="s2">                  ``{&#39;a&#39;: {&#39;b&#39;: np.nan}}``, are read as follows: look in column</span>
<span class="s2">                  &#39;a&#39; for the value &#39;b&#39; and replace it with NaN. The `value`</span>
<span class="s2">                  parameter should be ``None`` to use a nested dict in this</span>
<span class="s2">                  way. You can nest regular expressions as well. Note that</span>
<span class="s2">                  column names (the top-level dictionary keys in a nested</span>
<span class="s2">                  dictionary) **cannot** be regular expressions.</span>

<span class="s2">            * None:</span>

<span class="s2">                - This means that the `regex` argument must be a string,</span>
<span class="s2">                  compiled regular expression, or list, dict, ndarray or</span>
<span class="s2">                  Series of such elements. If `value` is also ``None`` then</span>
<span class="s2">                  this **must** be a nested dictionary or Series.</span>

<span class="s2">            See the examples section for examples of each of these.</span>
<span class="s2">        value : scalar, dict, list, str, regex, default None</span>
<span class="s2">            Value to replace any values matching `to_replace` with.</span>
<span class="s2">            For a DataFrame a dict of values can be used to specify which</span>
<span class="s2">            value to use for each column (columns not in the dict will not be</span>
<span class="s2">            filled). Regular expressions, strings and lists or dicts of such</span>
<span class="s2">            objects are also allowed.</span>
<span class="s2">        inplace : bool, default False</span>
<span class="s2">            If True, in place. Note: this will modify any</span>
<span class="s2">            other views on this object (e.g. a column from a DataFrame).</span>
<span class="s2">            Returns the caller if this is True.</span>
<span class="s2">        limit : int, default None</span>
<span class="s2">            Maximum size gap to forward or backward fill.</span>
<span class="s2">        regex : bool or same types as `to_replace`, default False</span>
<span class="s2">            Whether to interpret `to_replace` and/or `value` as regular</span>
<span class="s2">            expressions. If this is ``True`` then `to_replace` *must* be a</span>
<span class="s2">            string. Alternatively, this could be a regular expression or a</span>
<span class="s2">            list, dict, or array of regular expressions in which case</span>
<span class="s2">            `to_replace` must be ``None``.</span>
<span class="s2">        method : {&#39;pad&#39;, &#39;ffill&#39;, &#39;bfill&#39;, `None`}</span>
<span class="s2">            The method to use when for replacement, when `to_replace` is a</span>
<span class="s2">            scalar, list or tuple and `value` is ``None``.</span>

<span class="s2">            .. versionchanged:: 0.23.0</span>
<span class="s2">                Added to DataFrame.</span>

<span class="s2">        Returns</span>
<span class="s2">        -------</span>
<span class="s2">        </span><span class="si">%(klass)s</span><span class="s2"></span>
<span class="s2">            Object after replacement.</span>

<span class="s2">        Raises</span>
<span class="s2">        ------</span>
<span class="s2">        AssertionError</span>
<span class="s2">            * If `regex` is not a ``bool`` and `to_replace` is not</span>
<span class="s2">              ``None``.</span>
<span class="s2">        TypeError</span>
<span class="s2">            * If `to_replace` is a ``dict`` and `value` is not a ``list``,</span>
<span class="s2">              ``dict``, ``ndarray``, or ``Series``</span>
<span class="s2">            * If `to_replace` is ``None`` and `regex` is not compilable</span>
<span class="s2">              into a regular expression or is a list, dict, ndarray, or</span>
<span class="s2">              Series.</span>
<span class="s2">            * When replacing multiple ``bool`` or ``datetime64`` objects and</span>
<span class="s2">              the arguments to `to_replace` does not match the type of the</span>
<span class="s2">              value being replaced</span>
<span class="s2">        ValueError</span>
<span class="s2">            * If a ``list`` or an ``ndarray`` is passed to `to_replace` and</span>
<span class="s2">              `value` but they are not the same length.</span>

<span class="s2">        See Also</span>
<span class="s2">        --------</span>
<span class="s2">        </span><span class="si">%(klass)s</span><span class="s2">.fillna : Fill NA values.</span>
<span class="s2">        </span><span class="si">%(klass)s</span><span class="s2">.where : Replace values based on boolean condition.</span>
<span class="s2">        Series.str.replace : Simple string replacement.</span>

<span class="s2">        Notes</span>
<span class="s2">        -----</span>
<span class="s2">        * Regex substitution is performed under the hood with ``re.sub``. The</span>
<span class="s2">          rules for substitution for ``re.sub`` are the same.</span>
<span class="s2">        * Regular expressions will only substitute on strings, meaning you</span>
<span class="s2">          cannot provide, for example, a regular expression matching floating</span>
<span class="s2">          point numbers and expect the columns in your frame that have a</span>
<span class="s2">          numeric dtype to be matched. However, if those floating point</span>
<span class="s2">          numbers *are* strings, then you can do this.</span>
<span class="s2">        * This method has *a lot* of options. You are encouraged to experiment</span>
<span class="s2">          and play with this method to gain intuition about how it works.</span>
<span class="s2">        * When dict is used as the `to_replace` value, it is like</span>
<span class="s2">          key(s) in the dict are the to_replace part and</span>
<span class="s2">          value(s) in the dict are the value parameter.</span>

<span class="s2">        Examples</span>
<span class="s2">        --------</span>

<span class="s2">        **Scalar `to_replace` and `value`**</span>

<span class="s2">        &gt;&gt;&gt; s = pd.Series([0, 1, 2, 3, 4])</span>
<span class="s2">        &gt;&gt;&gt; s.replace(0, 5)</span>
<span class="s2">        0    5</span>
<span class="s2">        1    1</span>
<span class="s2">        2    2</span>
<span class="s2">        3    3</span>
<span class="s2">        4    4</span>
<span class="s2">        dtype: int64</span>

<span class="s2">        &gt;&gt;&gt; df = pd.DataFrame({&#39;A&#39;: [0, 1, 2, 3, 4],</span>
<span class="s2">        ...                    &#39;B&#39;: [5, 6, 7, 8, 9],</span>
<span class="s2">        ...                    &#39;C&#39;: [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39;]})</span>
<span class="s2">        &gt;&gt;&gt; df.replace(0, 5)</span>
<span class="s2">           A  B  C</span>
<span class="s2">        0  5  5  a</span>
<span class="s2">        1  1  6  b</span>
<span class="s2">        2  2  7  c</span>
<span class="s2">        3  3  8  d</span>
<span class="s2">        4  4  9  e</span>

<span class="s2">        **List-like `to_replace`**</span>

<span class="s2">        &gt;&gt;&gt; df.replace([0, 1, 2, 3], 4)</span>
<span class="s2">           A  B  C</span>
<span class="s2">        0  4  5  a</span>
<span class="s2">        1  4  6  b</span>
<span class="s2">        2  4  7  c</span>
<span class="s2">        3  4  8  d</span>
<span class="s2">        4  4  9  e</span>

<span class="s2">        &gt;&gt;&gt; df.replace([0, 1, 2, 3], [4, 3, 2, 1])</span>
<span class="s2">           A  B  C</span>
<span class="s2">        0  4  5  a</span>
<span class="s2">        1  3  6  b</span>
<span class="s2">        2  2  7  c</span>
<span class="s2">        3  1  8  d</span>
<span class="s2">        4  4  9  e</span>

<span class="s2">        &gt;&gt;&gt; s.replace([1, 2], method=&#39;bfill&#39;)</span>
<span class="s2">        0    0</span>
<span class="s2">        1    3</span>
<span class="s2">        2    3</span>
<span class="s2">        3    3</span>
<span class="s2">        4    4</span>
<span class="s2">        dtype: int64</span>

<span class="s2">        **dict-like `to_replace`**</span>

<span class="s2">        &gt;&gt;&gt; df.replace({0: 10, 1: 100})</span>
<span class="s2">             A  B  C</span>
<span class="s2">        0   10  5  a</span>
<span class="s2">        1  100  6  b</span>
<span class="s2">        2    2  7  c</span>
<span class="s2">        3    3  8  d</span>
<span class="s2">        4    4  9  e</span>

<span class="s2">        &gt;&gt;&gt; df.replace({&#39;A&#39;: 0, &#39;B&#39;: 5}, 100)</span>
<span class="s2">             A    B  C</span>
<span class="s2">        0  100  100  a</span>
<span class="s2">        1    1    6  b</span>
<span class="s2">        2    2    7  c</span>
<span class="s2">        3    3    8  d</span>
<span class="s2">        4    4    9  e</span>

<span class="s2">        &gt;&gt;&gt; df.replace({&#39;A&#39;: {0: 100, 4: 400}})</span>
<span class="s2">             A  B  C</span>
<span class="s2">        0  100  5  a</span>
<span class="s2">        1    1  6  b</span>
<span class="s2">        2    2  7  c</span>
<span class="s2">        3    3  8  d</span>
<span class="s2">        4  400  9  e</span>

<span class="s2">        **Regular expression `to_replace`**</span>

<span class="s2">        &gt;&gt;&gt; df = pd.DataFrame({&#39;A&#39;: [&#39;bat&#39;, &#39;foo&#39;, &#39;bait&#39;],</span>
<span class="s2">        ...                    &#39;B&#39;: [&#39;abc&#39;, &#39;bar&#39;, &#39;xyz&#39;]})</span>
<span class="s2">        &gt;&gt;&gt; df.replace(to_replace=r&#39;^ba.$&#39;, value=&#39;new&#39;, regex=True)</span>
<span class="s2">              A    B</span>
<span class="s2">        0   new  abc</span>
<span class="s2">        1   foo  new</span>
<span class="s2">        2  bait  xyz</span>

<span class="s2">        &gt;&gt;&gt; df.replace({&#39;A&#39;: r&#39;^ba.$&#39;}, {&#39;A&#39;: &#39;new&#39;}, regex=True)</span>
<span class="s2">              A    B</span>
<span class="s2">        0   new  abc</span>
<span class="s2">        1   foo  bar</span>
<span class="s2">        2  bait  xyz</span>

<span class="s2">        &gt;&gt;&gt; df.replace(regex=r&#39;^ba.$&#39;, value=&#39;new&#39;)</span>
<span class="s2">              A    B</span>
<span class="s2">        0   new  abc</span>
<span class="s2">        1   foo  new</span>
<span class="s2">        2  bait  xyz</span>

<span class="s2">        &gt;&gt;&gt; df.replace(regex={r&#39;^ba.$&#39;: &#39;new&#39;, &#39;foo&#39;: &#39;xyz&#39;})</span>
<span class="s2">              A    B</span>
<span class="s2">        0   new  abc</span>
<span class="s2">        1   xyz  new</span>
<span class="s2">        2  bait  xyz</span>

<span class="s2">        &gt;&gt;&gt; df.replace(regex=[r&#39;^ba.$&#39;, &#39;foo&#39;], value=&#39;new&#39;)</span>
<span class="s2">              A    B</span>
<span class="s2">        0   new  abc</span>
<span class="s2">        1   new  new</span>
<span class="s2">        2  bait  xyz</span>

<span class="s2">        Note that when replacing multiple ``bool`` or ``datetime64`` objects,</span>
<span class="s2">        the data types in the `to_replace` parameter must match the data</span>
<span class="s2">        type of the value being replaced:</span>

<span class="s2">        &gt;&gt;&gt; df = pd.DataFrame({&#39;A&#39;: [True, False, True],</span>
<span class="s2">        ...                    &#39;B&#39;: [False, True, False]})</span>
<span class="s2">        &gt;&gt;&gt; df.replace({&#39;a string&#39;: &#39;new value&#39;, True: False})  # raises</span>
<span class="s2">        Traceback (most recent call last):</span>
<span class="s2">            ...</span>
<span class="s2">        TypeError: Cannot compare types &#39;ndarray(dtype=bool)&#39; and &#39;str&#39;</span>

<span class="s2">        This raises a ``TypeError`` because one of the ``dict`` keys is not of</span>
<span class="s2">        the correct type for replacement.</span>

<span class="s2">        Compare the behavior of ``s.replace({&#39;a&#39;: None})`` and</span>
<span class="s2">        ``s.replace(&#39;a&#39;, None)`` to understand the peculiarities</span>
<span class="s2">        of the `to_replace` parameter:</span>

<span class="s2">        &gt;&gt;&gt; s = pd.Series([10, &#39;a&#39;, &#39;a&#39;, &#39;b&#39;, &#39;a&#39;])</span>

<span class="s2">        When one uses a dict as the `to_replace` value, it is like the</span>
<span class="s2">        value(s) in the dict are equal to the `value` parameter.</span>
<span class="s2">        ``s.replace({&#39;a&#39;: None})`` is equivalent to</span>
<span class="s2">        ``s.replace(to_replace={&#39;a&#39;: None}, value=None, method=None)``:</span>

<span class="s2">        &gt;&gt;&gt; s.replace({&#39;a&#39;: None})</span>
<span class="s2">        0      10</span>
<span class="s2">        1    None</span>
<span class="s2">        2    None</span>
<span class="s2">        3       b</span>
<span class="s2">        4    None</span>
<span class="s2">        dtype: object</span>

<span class="s2">        When ``value=None`` and `to_replace` is a scalar, list or</span>
<span class="s2">        tuple, `replace` uses the method parameter (default &#39;pad&#39;) to do the</span>
<span class="s2">        replacement. So this is why the &#39;a&#39; values are being replaced by 10</span>
<span class="s2">        in rows 1 and 2 and &#39;b&#39; in row 4 in this case.</span>
<span class="s2">        The command ``s.replace(&#39;a&#39;, None)`` is actually equivalent to</span>
<span class="s2">        ``s.replace(to_replace=&#39;a&#39;, value=None, method=&#39;pad&#39;)``:</span>

<span class="s2">        &gt;&gt;&gt; s.replace(&#39;a&#39;, None)</span>
<span class="s2">        0    10</span>
<span class="s2">        1    10</span>
<span class="s2">        2    10</span>
<span class="s2">        3     b</span>
<span class="s2">        4     b</span>
<span class="s2">        dtype: object</span>
<span class="s2">    &quot;&quot;&quot;</span>

    <span class="nd">@Appender</span><span class="p">(</span><span class="n">_shared_docs</span><span class="p">[</span><span class="s2">&quot;replace&quot;</span><span class="p">]</span> <span class="o">%</span> <span class="n">_shared_doc_kwargs</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">replace</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">to_replace</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">value</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">inplace</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">limit</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">regex</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">method</span><span class="o">=</span><span class="s2">&quot;pad&quot;</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="n">inplace</span> <span class="o">=</span> <span class="n">validate_bool_kwarg</span><span class="p">(</span><span class="n">inplace</span><span class="p">,</span> <span class="s2">&quot;inplace&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">is_bool</span><span class="p">(</span><span class="n">regex</span><span class="p">)</span> <span class="ow">and</span> <span class="n">to_replace</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">AssertionError</span><span class="p">(</span>
                <span class="s2">&quot;&#39;to_replace&#39; must be &#39;None&#39; if &#39;regex&#39; is &quot;</span> <span class="s2">&quot;not a bool&quot;</span>
            <span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_consolidate_inplace</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">value</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># passing a single value that is scalar like</span>
            <span class="c1"># when value is None (GH5319), for compat</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">is_dict_like</span><span class="p">(</span><span class="n">to_replace</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">is_dict_like</span><span class="p">(</span><span class="n">regex</span><span class="p">):</span>
                <span class="n">to_replace</span> <span class="o">=</span> <span class="p">[</span><span class="n">to_replace</span><span class="p">]</span>

            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">to_replace</span><span class="p">,</span> <span class="p">(</span><span class="nb">tuple</span><span class="p">,</span> <span class="nb">list</span><span class="p">)):</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">):</span>
                    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span>
                        <span class="n">_single_replace</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="n">to_replace</span><span class="p">,</span> <span class="n">method</span><span class="p">,</span> <span class="n">inplace</span><span class="p">,</span> <span class="n">limit</span><span class="p">)</span>
                    <span class="p">)</span>
                <span class="k">return</span> <span class="n">_single_replace</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">to_replace</span><span class="p">,</span> <span class="n">method</span><span class="p">,</span> <span class="n">inplace</span><span class="p">,</span> <span class="n">limit</span><span class="p">)</span>

            <span class="k">if</span> <span class="ow">not</span> <span class="n">is_dict_like</span><span class="p">(</span><span class="n">to_replace</span><span class="p">):</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">is_dict_like</span><span class="p">(</span><span class="n">regex</span><span class="p">):</span>
                    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                        <span class="s1">&#39;If &quot;to_replace&quot; and &quot;value&quot; are both None&#39;</span>
                        <span class="s1">&#39; and &quot;to_replace&quot; is not a list, then &#39;</span>
                        <span class="s2">&quot;regex must be a mapping&quot;</span>
                    <span class="p">)</span>
                <span class="n">to_replace</span> <span class="o">=</span> <span class="n">regex</span>
                <span class="n">regex</span> <span class="o">=</span> <span class="kc">True</span>

            <span class="n">items</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">to_replace</span><span class="o">.</span><span class="n">items</span><span class="p">())</span>
            <span class="n">keys</span><span class="p">,</span> <span class="n">values</span> <span class="o">=</span> <span class="nb">zip</span><span class="p">(</span><span class="o">*</span><span class="n">items</span><span class="p">)</span> <span class="k">if</span> <span class="n">items</span> <span class="k">else</span> <span class="p">([],</span> <span class="p">[])</span>

            <span class="n">are_mappings</span> <span class="o">=</span> <span class="p">[</span><span class="n">is_dict_like</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">values</span><span class="p">]</span>

            <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">are_mappings</span><span class="p">):</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="nb">all</span><span class="p">(</span><span class="n">are_mappings</span><span class="p">):</span>
                    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                        <span class="s2">&quot;If a nested mapping is passed, all values&quot;</span>
                        <span class="s2">&quot; of the top level mapping must be &quot;</span>
                        <span class="s2">&quot;mappings&quot;</span>
                    <span class="p">)</span>
                <span class="c1"># passed a nested dict/Series</span>
                <span class="n">to_rep_dict</span> <span class="o">=</span> <span class="p">{}</span>
                <span class="n">value_dict</span> <span class="o">=</span> <span class="p">{}</span>

                <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">items</span><span class="p">:</span>
                    <span class="n">keys</span><span class="p">,</span> <span class="n">values</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="o">*</span><span class="n">v</span><span class="o">.</span><span class="n">items</span><span class="p">()))</span> <span class="ow">or</span> <span class="p">([],</span> <span class="p">[])</span>
                    <span class="k">if</span> <span class="nb">set</span><span class="p">(</span><span class="n">keys</span><span class="p">)</span> <span class="o">&amp;</span> <span class="nb">set</span><span class="p">(</span><span class="n">values</span><span class="p">):</span>
                        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                            <span class="s2">&quot;Replacement not allowed with &quot;</span>
                            <span class="s2">&quot;overlapping keys and values&quot;</span>
                        <span class="p">)</span>
                    <span class="n">to_rep_dict</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">keys</span><span class="p">)</span>
                    <span class="n">value_dict</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">values</span><span class="p">)</span>

                <span class="n">to_replace</span><span class="p">,</span> <span class="n">value</span> <span class="o">=</span> <span class="n">to_rep_dict</span><span class="p">,</span> <span class="n">value_dict</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">to_replace</span><span class="p">,</span> <span class="n">value</span> <span class="o">=</span> <span class="n">keys</span><span class="p">,</span> <span class="n">values</span>

            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span>
                <span class="n">to_replace</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="n">inplace</span><span class="p">,</span> <span class="n">limit</span><span class="o">=</span><span class="n">limit</span><span class="p">,</span> <span class="n">regex</span><span class="o">=</span><span class="n">regex</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>

            <span class="c1"># need a non-zero len on all axes</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">size</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span>

            <span class="n">new_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span>
            <span class="k">if</span> <span class="n">is_dict_like</span><span class="p">(</span><span class="n">to_replace</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">is_dict_like</span><span class="p">(</span><span class="n">value</span><span class="p">):</span>  <span class="c1"># {&#39;A&#39; : NA} -&gt; {&#39;A&#39; : 0}</span>
                    <span class="n">res</span> <span class="o">=</span> <span class="bp">self</span> <span class="k">if</span> <span class="n">inplace</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
                    <span class="k">for</span> <span class="n">c</span><span class="p">,</span> <span class="n">src</span> <span class="ow">in</span> <span class="n">to_replace</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                        <span class="k">if</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">value</span> <span class="ow">and</span> <span class="n">c</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
                            <span class="c1"># object conversion is handled in</span>
                            <span class="c1"># series.replace which is called recursively</span>
                            <span class="n">res</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="o">=</span> <span class="n">res</span><span class="p">[</span><span class="n">c</span><span class="p">]</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span>
                                <span class="n">to_replace</span><span class="o">=</span><span class="n">src</span><span class="p">,</span>
                                <span class="n">value</span><span class="o">=</span><span class="n">value</span><span class="p">[</span><span class="n">c</span><span class="p">],</span>
                                <span class="n">inplace</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                <span class="n">regex</span><span class="o">=</span><span class="n">regex</span><span class="p">,</span>
                            <span class="p">)</span>
                    <span class="k">return</span> <span class="kc">None</span> <span class="k">if</span> <span class="n">inplace</span> <span class="k">else</span> <span class="n">res</span>

                <span class="c1"># {&#39;A&#39;: NA} -&gt; 0</span>
                <span class="k">elif</span> <span class="ow">not</span> <span class="n">is_list_like</span><span class="p">(</span><span class="n">value</span><span class="p">):</span>
                    <span class="n">keys</span> <span class="o">=</span> <span class="p">[(</span><span class="n">k</span><span class="p">,</span> <span class="n">src</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">src</span> <span class="ow">in</span> <span class="n">to_replace</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="n">k</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">]</span>
                    <span class="n">keys_len</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">keys</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
                    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">src</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">keys</span><span class="p">):</span>
                        <span class="n">convert</span> <span class="o">=</span> <span class="n">i</span> <span class="o">==</span> <span class="n">keys_len</span>
                        <span class="n">new_data</span> <span class="o">=</span> <span class="n">new_data</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span>
                            <span class="n">to_replace</span><span class="o">=</span><span class="n">src</span><span class="p">,</span>
                            <span class="n">value</span><span class="o">=</span><span class="n">value</span><span class="p">,</span>
                            <span class="nb">filter</span><span class="o">=</span><span class="p">[</span><span class="n">k</span><span class="p">],</span>
                            <span class="n">inplace</span><span class="o">=</span><span class="n">inplace</span><span class="p">,</span>
                            <span class="n">regex</span><span class="o">=</span><span class="n">regex</span><span class="p">,</span>
                            <span class="n">convert</span><span class="o">=</span><span class="n">convert</span><span class="p">,</span>
                        <span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;value argument must be scalar, dict, or &quot;</span> <span class="s2">&quot;Series&quot;</span><span class="p">)</span>

            <span class="k">elif</span> <span class="n">is_list_like</span><span class="p">(</span><span class="n">to_replace</span><span class="p">):</span>  <span class="c1"># [NA, &#39;&#39;] -&gt; [0, &#39;missing&#39;]</span>
                <span class="k">if</span> <span class="n">is_list_like</span><span class="p">(</span><span class="n">value</span><span class="p">):</span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">to_replace</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">value</span><span class="p">):</span>
                        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                            <span class="s2">&quot;Replacement lists must match &quot;</span>
                            <span class="s2">&quot;in length. Expecting </span><span class="si">%d</span><span class="s2"> got </span><span class="si">%d</span><span class="s2"> &quot;</span>
                            <span class="o">%</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">to_replace</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">value</span><span class="p">))</span>
                        <span class="p">)</span>

                    <span class="n">new_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">replace_list</span><span class="p">(</span>
                        <span class="n">src_list</span><span class="o">=</span><span class="n">to_replace</span><span class="p">,</span>
                        <span class="n">dest_list</span><span class="o">=</span><span class="n">value</span><span class="p">,</span>
                        <span class="n">inplace</span><span class="o">=</span><span class="n">inplace</span><span class="p">,</span>
                        <span class="n">regex</span><span class="o">=</span><span class="n">regex</span><span class="p">,</span>
                    <span class="p">)</span>

                <span class="k">else</span><span class="p">:</span>  <span class="c1"># [NA, &#39;&#39;] -&gt; 0</span>
                    <span class="n">new_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span>
                        <span class="n">to_replace</span><span class="o">=</span><span class="n">to_replace</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="n">value</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="n">inplace</span><span class="p">,</span> <span class="n">regex</span><span class="o">=</span><span class="n">regex</span>
                    <span class="p">)</span>
            <span class="k">elif</span> <span class="n">to_replace</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span>
                    <span class="n">is_re_compilable</span><span class="p">(</span><span class="n">regex</span><span class="p">)</span>
                    <span class="ow">or</span> <span class="n">is_list_like</span><span class="p">(</span><span class="n">regex</span><span class="p">)</span>
                    <span class="ow">or</span> <span class="n">is_dict_like</span><span class="p">(</span><span class="n">regex</span><span class="p">)</span>
                <span class="p">):</span>
                    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                        <span class="s2">&quot;&#39;regex&#39; must be a string or a compiled &quot;</span>
                        <span class="s2">&quot;regular expression or a list or dict of &quot;</span>
                        <span class="s2">&quot;strings or regular expressions, you &quot;</span>
                        <span class="s2">&quot;passed a&quot;</span>
                        <span class="s2">&quot; </span><span class="si">{0!r}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">regex</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="p">)</span>
                    <span class="p">)</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span>
                    <span class="n">regex</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="n">inplace</span><span class="p">,</span> <span class="n">limit</span><span class="o">=</span><span class="n">limit</span><span class="p">,</span> <span class="n">regex</span><span class="o">=</span><span class="kc">True</span>
                <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>

                <span class="c1"># dest iterable dict-like</span>
                <span class="k">if</span> <span class="n">is_dict_like</span><span class="p">(</span><span class="n">value</span><span class="p">):</span>  <span class="c1"># NA -&gt; {&#39;A&#39; : 0, &#39;B&#39; : -1}</span>
                    <span class="n">new_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span>

                    <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">value</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                        <span class="k">if</span> <span class="n">k</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
                            <span class="n">new_data</span> <span class="o">=</span> <span class="n">new_data</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span>
                                <span class="n">to_replace</span><span class="o">=</span><span class="n">to_replace</span><span class="p">,</span>
                                <span class="n">value</span><span class="o">=</span><span class="n">v</span><span class="p">,</span>
                                <span class="nb">filter</span><span class="o">=</span><span class="p">[</span><span class="n">k</span><span class="p">],</span>
                                <span class="n">inplace</span><span class="o">=</span><span class="n">inplace</span><span class="p">,</span>
                                <span class="n">regex</span><span class="o">=</span><span class="n">regex</span><span class="p">,</span>
                            <span class="p">)</span>

                <span class="k">elif</span> <span class="ow">not</span> <span class="n">is_list_like</span><span class="p">(</span><span class="n">value</span><span class="p">):</span>  <span class="c1"># NA -&gt; 0</span>
                    <span class="n">new_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span>
                        <span class="n">to_replace</span><span class="o">=</span><span class="n">to_replace</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="n">value</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="n">inplace</span><span class="p">,</span> <span class="n">regex</span><span class="o">=</span><span class="n">regex</span>
                    <span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;Invalid &quot;to_replace&quot; type: &#39;</span> <span class="s2">&quot;</span><span class="si">{0!r}</span><span class="s2">&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                        <span class="nb">type</span><span class="p">(</span><span class="n">to_replace</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span>
                    <span class="p">)</span>
                    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>  <span class="c1"># pragma: no cover</span>

        <span class="k">if</span> <span class="n">inplace</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_update_inplace</span><span class="p">(</span><span class="n">new_data</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_constructor</span><span class="p">(</span><span class="n">new_data</span><span class="p">)</span><span class="o">.</span><span class="n">__finalize__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="n">_shared_docs</span><span class="p">[</span>
        <span class="s2">&quot;interpolate&quot;</span>
    <span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;</span>
<span class="s2">        Please note that only ``method=&#39;linear&#39;`` is supported for</span>
<span class="s2">        DataFrame/Series with a MultiIndex.</span>

<span class="s2">        Parameters</span>
<span class="s2">        ----------</span>
<span class="s2">        method : str, default &#39;linear&#39;</span>
<span class="s2">            Interpolation technique to use. One of:</span>

<span class="s2">            * &#39;linear&#39;: Ignore the index and treat the values as equally</span>
<span class="s2">              spaced. This is the only method supported on MultiIndexes.</span>
<span class="s2">            * &#39;time&#39;: Works on daily and higher resolution data to interpolate</span>
<span class="s2">              given length of interval.</span>
<span class="s2">            * &#39;index&#39;, &#39;values&#39;: use the actual numerical values of the index.</span>
<span class="s2">            * &#39;pad&#39;: Fill in NaNs using existing values.</span>
<span class="s2">            * &#39;nearest&#39;, &#39;zero&#39;, &#39;slinear&#39;, &#39;quadratic&#39;, &#39;cubic&#39;, &#39;spline&#39;,</span>
<span class="s2">              &#39;barycentric&#39;, &#39;polynomial&#39;: Passed to</span>
<span class="s2">              `scipy.interpolate.interp1d`. These methods use the numerical</span>
<span class="s2">              values of the index.  Both &#39;polynomial&#39; and &#39;spline&#39; require that</span>
<span class="s2">              you also specify an `order` (int), e.g.</span>
<span class="s2">              ``df.interpolate(method=&#39;polynomial&#39;, order=5)``.</span>
<span class="s2">            * &#39;krogh&#39;, &#39;piecewise_polynomial&#39;, &#39;spline&#39;, &#39;pchip&#39;, &#39;akima&#39;:</span>
<span class="s2">              Wrappers around the SciPy interpolation methods of similar</span>
<span class="s2">              names. See `Notes`.</span>
<span class="s2">            * &#39;from_derivatives&#39;: Refers to</span>
<span class="s2">              `scipy.interpolate.BPoly.from_derivatives` which</span>
<span class="s2">              replaces &#39;piecewise_polynomial&#39; interpolation method in</span>
<span class="s2">              scipy 0.18.</span>

<span class="s2">            .. versionadded:: 0.18.1</span>

<span class="s2">               Added support for the &#39;akima&#39; method.</span>
<span class="s2">               Added interpolate method &#39;from_derivatives&#39; which replaces</span>
<span class="s2">               &#39;piecewise_polynomial&#39; in SciPy 0.18; backwards-compatible with</span>
<span class="s2">               SciPy &lt; 0.18</span>

<span class="s2">        axis : {0 or &#39;index&#39;, 1 or &#39;columns&#39;, None}, default None</span>
<span class="s2">            Axis to interpolate along.</span>
<span class="s2">        limit : int, optional</span>
<span class="s2">            Maximum number of consecutive NaNs to fill. Must be greater than</span>
<span class="s2">            0.</span>
<span class="s2">        inplace : bool, default False</span>
<span class="s2">            Update the data in place if possible.</span>
<span class="s2">        limit_direction : {&#39;forward&#39;, &#39;backward&#39;, &#39;both&#39;}, default &#39;forward&#39;</span>
<span class="s2">            If limit is specified, consecutive NaNs will be filled in this</span>
<span class="s2">            direction.</span>
<span class="s2">        limit_area : {`None`, &#39;inside&#39;, &#39;outside&#39;}, default None</span>
<span class="s2">            If limit is specified, consecutive NaNs will be filled with this</span>
<span class="s2">            restriction.</span>

<span class="s2">            * ``None``: No fill restriction.</span>
<span class="s2">            * &#39;inside&#39;: Only fill NaNs surrounded by valid values</span>
<span class="s2">              (interpolate).</span>
<span class="s2">            * &#39;outside&#39;: Only fill NaNs outside valid values (extrapolate).</span>

<span class="s2">            .. versionadded:: 0.23.0</span>

<span class="s2">        downcast : optional, &#39;infer&#39; or None, defaults to None</span>
<span class="s2">            Downcast dtypes if possible.</span>
<span class="s2">        **kwargs</span>
<span class="s2">            Keyword arguments to pass on to the interpolating function.</span>

<span class="s2">        Returns</span>
<span class="s2">        -------</span>
<span class="s2">        Series or DataFrame</span>
<span class="s2">            Returns the same object type as the caller, interpolated at</span>
<span class="s2">            some or all ``NaN`` values.</span>

<span class="s2">        See Also</span>
<span class="s2">        --------</span>
<span class="s2">        fillna : Fill missing values using different methods.</span>
<span class="s2">        scipy.interpolate.Akima1DInterpolator : Piecewise cubic polynomials</span>
<span class="s2">            (Akima interpolator).</span>
<span class="s2">        scipy.interpolate.BPoly.from_derivatives : Piecewise polynomial in the</span>
<span class="s2">            Bernstein basis.</span>
<span class="s2">        scipy.interpolate.interp1d : Interpolate a 1-D function.</span>
<span class="s2">        scipy.interpolate.KroghInterpolator : Interpolate polynomial (Krogh</span>
<span class="s2">            interpolator).</span>
<span class="s2">        scipy.interpolate.PchipInterpolator : PCHIP 1-d monotonic cubic</span>
<span class="s2">            interpolation.</span>
<span class="s2">        scipy.interpolate.CubicSpline : Cubic spline data interpolator.</span>

<span class="s2">        Notes</span>
<span class="s2">        -----</span>
<span class="s2">        The &#39;krogh&#39;, &#39;piecewise_polynomial&#39;, &#39;spline&#39;, &#39;pchip&#39; and &#39;akima&#39;</span>
<span class="s2">        methods are wrappers around the respective SciPy implementations of</span>
<span class="s2">        similar names. These use the actual numerical values of the index.</span>
<span class="s2">        For more information on their behavior, see the</span>
<span class="s2">        `SciPy documentation</span>
<span class="s2">        &lt;http://docs.scipy.org/doc/scipy/reference/interpolate.html#univariate-interpolation&gt;`__</span>
<span class="s2">        and `SciPy tutorial</span>
<span class="s2">        &lt;http://docs.scipy.org/doc/scipy/reference/tutorial/interpolate.html&gt;`__.</span>

<span class="s2">        Examples</span>
<span class="s2">        --------</span>
<span class="s2">        Filling in ``NaN`` in a :class:`~pandas.Series` via linear</span>
<span class="s2">        interpolation.</span>

<span class="s2">        &gt;&gt;&gt; s = pd.Series([0, 1, np.nan, 3])</span>
<span class="s2">        &gt;&gt;&gt; s</span>
<span class="s2">        0    0.0</span>
<span class="s2">        1    1.0</span>
<span class="s2">        2    NaN</span>
<span class="s2">        3    3.0</span>
<span class="s2">        dtype: float64</span>
<span class="s2">        &gt;&gt;&gt; s.interpolate()</span>
<span class="s2">        0    0.0</span>
<span class="s2">        1    1.0</span>
<span class="s2">        2    2.0</span>
<span class="s2">        3    3.0</span>
<span class="s2">        dtype: float64</span>

<span class="s2">        Filling in ``NaN`` in a Series by padding, but filling at most two</span>
<span class="s2">        consecutive ``NaN`` at a time.</span>

<span class="s2">        &gt;&gt;&gt; s = pd.Series([np.nan, &quot;single_one&quot;, np.nan,</span>
<span class="s2">        ...                &quot;fill_two_more&quot;, np.nan, np.nan, np.nan,</span>
<span class="s2">        ...                4.71, np.nan])</span>
<span class="s2">        &gt;&gt;&gt; s</span>
<span class="s2">        0              NaN</span>
<span class="s2">        1       single_one</span>
<span class="s2">        2              NaN</span>
<span class="s2">        3    fill_two_more</span>
<span class="s2">        4              NaN</span>
<span class="s2">        5              NaN</span>
<span class="s2">        6              NaN</span>
<span class="s2">        7             4.71</span>
<span class="s2">        8              NaN</span>
<span class="s2">        dtype: object</span>
<span class="s2">        &gt;&gt;&gt; s.interpolate(method=&#39;pad&#39;, limit=2)</span>
<span class="s2">        0              NaN</span>
<span class="s2">        1       single_one</span>
<span class="s2">        2       single_one</span>
<span class="s2">        3    fill_two_more</span>
<span class="s2">        4    fill_two_more</span>
<span class="s2">        5    fill_two_more</span>
<span class="s2">        6              NaN</span>
<span class="s2">        7             4.71</span>
<span class="s2">        8             4.71</span>
<span class="s2">        dtype: object</span>

<span class="s2">        Filling in ``NaN`` in a Series via polynomial interpolation or splines:</span>
<span class="s2">        Both &#39;polynomial&#39; and &#39;spline&#39; methods require that you also specify</span>
<span class="s2">        an ``order`` (int).</span>

<span class="s2">        &gt;&gt;&gt; s = pd.Series([0, 2, np.nan, 8])</span>
<span class="s2">        &gt;&gt;&gt; s.interpolate(method=&#39;polynomial&#39;, order=2)</span>
<span class="s2">        0    0.000000</span>
<span class="s2">        1    2.000000</span>
<span class="s2">        2    4.666667</span>
<span class="s2">        3    8.000000</span>
<span class="s2">        dtype: float64</span>

<span class="s2">        Fill the DataFrame forward (that is, going down) along each column</span>
<span class="s2">        using linear interpolation.</span>

<span class="s2">        Note how the last entry in column &#39;a&#39; is interpolated differently,</span>
<span class="s2">        because there is no entry after it to use for interpolation.</span>
<span class="s2">        Note how the first entry in column &#39;b&#39; remains ``NaN``, because there</span>
<span class="s2">        is no entry before it to use for interpolation.</span>

<span class="s2">        &gt;&gt;&gt; df = pd.DataFrame([(0.0, np.nan, -1.0, 1.0),</span>
<span class="s2">        ...                    (np.nan, 2.0, np.nan, np.nan),</span>
<span class="s2">        ...                    (2.0, 3.0, np.nan, 9.0),</span>
<span class="s2">        ...                    (np.nan, 4.0, -4.0, 16.0)],</span>
<span class="s2">        ...                   columns=list(&#39;abcd&#39;))</span>
<span class="s2">        &gt;&gt;&gt; df</span>
<span class="s2">             a    b    c     d</span>
<span class="s2">        0  0.0  NaN -1.0   1.0</span>
<span class="s2">        1  NaN  2.0  NaN   NaN</span>
<span class="s2">        2  2.0  3.0  NaN   9.0</span>
<span class="s2">        3  NaN  4.0 -4.0  16.0</span>
<span class="s2">        &gt;&gt;&gt; df.interpolate(method=&#39;linear&#39;, limit_direction=&#39;forward&#39;, axis=0)</span>
<span class="s2">             a    b    c     d</span>
<span class="s2">        0  0.0  NaN -1.0   1.0</span>
<span class="s2">        1  1.0  2.0 -2.0   5.0</span>
<span class="s2">        2  2.0  3.0 -3.0   9.0</span>
<span class="s2">        3  2.0  4.0 -4.0  16.0</span>

<span class="s2">        Using polynomial interpolation.</span>

<span class="s2">        &gt;&gt;&gt; df[&#39;d&#39;].interpolate(method=&#39;polynomial&#39;, order=2)</span>
<span class="s2">        0     1.0</span>
<span class="s2">        1     4.0</span>
<span class="s2">        2     9.0</span>
<span class="s2">        3    16.0</span>
<span class="s2">        Name: d, dtype: float64</span>
<span class="s2">        &quot;&quot;&quot;</span>

    <span class="nd">@Appender</span><span class="p">(</span><span class="n">_shared_docs</span><span class="p">[</span><span class="s2">&quot;interpolate&quot;</span><span class="p">]</span> <span class="o">%</span> <span class="n">_shared_doc_kwargs</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">interpolate</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">method</span><span class="o">=</span><span class="s2">&quot;linear&quot;</span><span class="p">,</span>
        <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
        <span class="n">limit</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">inplace</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">limit_direction</span><span class="o">=</span><span class="s2">&quot;forward&quot;</span><span class="p">,</span>
        <span class="n">limit_area</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">downcast</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Interpolate values according to different methods.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">inplace</span> <span class="o">=</span> <span class="n">validate_bool_kwarg</span><span class="p">(</span><span class="n">inplace</span><span class="p">,</span> <span class="s2">&quot;inplace&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">axis</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">ax</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_info_axis_name</span>
            <span class="n">_maybe_transposed_self</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="k">elif</span> <span class="n">axis</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">_maybe_transposed_self</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">T</span>
            <span class="n">ax</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">_maybe_transposed_self</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="n">ax</span> <span class="o">=</span> <span class="n">_maybe_transposed_self</span><span class="o">.</span><span class="n">_get_axis_number</span><span class="p">(</span><span class="n">ax</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">_maybe_transposed_self</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">alt_ax</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">ax</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">alt_ax</span> <span class="o">=</span> <span class="n">ax</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">_maybe_transposed_self</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="n">MultiIndex</span><span class="p">)</span> <span class="ow">and</span> <span class="n">method</span> <span class="o">!=</span> <span class="s2">&quot;linear&quot;</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Only `method=linear` interpolation is supported &quot;</span> <span class="s2">&quot;on MultiIndexes.&quot;</span>
            <span class="p">)</span>

        <span class="k">if</span> <span class="n">_maybe_transposed_self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">get_dtype_counts</span><span class="p">()</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;object&quot;</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span>
            <span class="n">_maybe_transposed_self</span><span class="o">.</span><span class="n">T</span>
        <span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                <span class="s2">&quot;Cannot interpolate with all object-dtype columns &quot;</span>
                <span class="s2">&quot;in the DataFrame. Try setting at least one &quot;</span>
                <span class="s2">&quot;column to a numeric dtype.&quot;</span>
            <span class="p">)</span>

        <span class="c1"># create/use the index</span>
        <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="s2">&quot;linear&quot;</span><span class="p">:</span>
            <span class="c1"># prior default</span>
            <span class="n">index</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">_maybe_transposed_self</span><span class="o">.</span><span class="n">_get_axis</span><span class="p">(</span><span class="n">alt_ax</span><span class="p">)))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">index</span> <span class="o">=</span> <span class="n">_maybe_transposed_self</span><span class="o">.</span><span class="n">_get_axis</span><span class="p">(</span><span class="n">alt_ax</span><span class="p">)</span>
            <span class="n">methods</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;index&quot;</span><span class="p">,</span> <span class="s2">&quot;values&quot;</span><span class="p">,</span> <span class="s2">&quot;nearest&quot;</span><span class="p">,</span> <span class="s2">&quot;time&quot;</span><span class="p">}</span>
            <span class="n">is_numeric_or_datetime</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">is_numeric_dtype</span><span class="p">(</span><span class="n">index</span><span class="p">)</span>
                <span class="ow">or</span> <span class="n">is_datetime64_any_dtype</span><span class="p">(</span><span class="n">index</span><span class="p">)</span>
                <span class="ow">or</span> <span class="n">is_timedelta64_dtype</span><span class="p">(</span><span class="n">index</span><span class="p">)</span>
            <span class="p">)</span>
            <span class="k">if</span> <span class="n">method</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">methods</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">is_numeric_or_datetime</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;Index column must be numeric or datetime type when &quot;</span>
                    <span class="s2">&quot;using </span><span class="si">{method}</span><span class="s2"> method other than linear. &quot;</span>
                    <span class="s2">&quot;Try setting a numeric or datetime index column before &quot;</span>
                    <span class="s2">&quot;interpolating.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">method</span><span class="o">=</span><span class="n">method</span><span class="p">)</span>
                <span class="p">)</span>

        <span class="k">if</span> <span class="n">isna</span><span class="p">(</span><span class="n">index</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span>
                <span class="s2">&quot;Interpolation with NaNs in the index &quot;</span>
                <span class="s2">&quot;has not been implemented. Try filling &quot;</span>
                <span class="s2">&quot;those NaNs before interpolating.&quot;</span>
            <span class="p">)</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">_maybe_transposed_self</span><span class="o">.</span><span class="n">_data</span>
        <span class="n">new_data</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">interpolate</span><span class="p">(</span>
            <span class="n">method</span><span class="o">=</span><span class="n">method</span><span class="p">,</span>
            <span class="n">axis</span><span class="o">=</span><span class="n">ax</span><span class="p">,</span>
            <span class="n">index</span><span class="o">=</span><span class="n">index</span><span class="p">,</span>
            <span class="n">values</span><span class="o">=</span><span class="n">_maybe_transposed_self</span><span class="p">,</span>
            <span class="n">limit</span><span class="o">=</span><span class="n">limit</span><span class="p">,</span>
            <span class="n">limit_direction</span><span class="o">=</span><span class="n">limit_direction</span><span class="p">,</span>
            <span class="n">limit_area</span><span class="o">=</span><span class="n">limit_area</span><span class="p">,</span>
            <span class="n">inplace</span><span class="o">=</span><span class="n">inplace</span><span class="p">,</span>
            <span class="n">downcast</span><span class="o">=</span><span class="n">downcast</span><span class="p">,</span>
            <span class="o">**</span><span class="n">kwargs</span>
        <span class="p">)</span>

        <span class="k">if</span> <span class="n">inplace</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">axis</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">new_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_constructor</span><span class="p">(</span><span class="n">new_data</span><span class="p">)</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">_data</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_update_inplace</span><span class="p">(</span><span class="n">new_data</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">res</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_constructor</span><span class="p">(</span><span class="n">new_data</span><span class="p">)</span><span class="o">.</span><span class="n">__finalize__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">axis</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">res</span> <span class="o">=</span> <span class="n">res</span><span class="o">.</span><span class="n">T</span>
            <span class="k">return</span> <span class="n">res</span>

    <span class="c1"># ----------------------------------------------------------------------</span>
    <span class="c1"># Timeseries methods Methods</span>

    <span class="k">def</span> <span class="nf">asof</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">where</span><span class="p">,</span> <span class="n">subset</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the last row(s) without any NaNs before `where`.</span>

<span class="sd">        The last row (for each element in `where`, if list) without any</span>
<span class="sd">        NaN is taken.</span>
<span class="sd">        In case of a :class:`~pandas.DataFrame`, the last row without NaN</span>
<span class="sd">        considering only the subset of columns (if not `None`)</span>

<span class="sd">        .. versionadded:: 0.19.0 For DataFrame</span>

<span class="sd">        If there is no good value, NaN is returned for a Series or</span>
<span class="sd">        a Series of NaN values for a DataFrame</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        where : date or array-like of dates</span>
<span class="sd">            Date(s) before which the last row(s) are returned.</span>
<span class="sd">        subset : str or array-like of str, default `None`</span>
<span class="sd">            For DataFrame, if not `None`, only use these columns to</span>
<span class="sd">            check for NaNs.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        scalar, Series, or DataFrame</span>

<span class="sd">            The return can be:</span>

<span class="sd">            * scalar : when `self` is a Series and `where` is a scalar</span>
<span class="sd">            * Series: when `self` is a Series and `where` is an array-like,</span>
<span class="sd">              or when `self` is a DataFrame and `where` is a scalar</span>
<span class="sd">            * DataFrame : when `self` is a DataFrame and `where` is an</span>
<span class="sd">              array-like</span>

<span class="sd">            Return scalar, Series, or DataFrame.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        merge_asof : Perform an asof merge. Similar to left join.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        Dates are assumed to be sorted. Raises if this is not the case.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        A Series and a scalar `where`.</span>

<span class="sd">        &gt;&gt;&gt; s = pd.Series([1, 2, np.nan, 4], index=[10, 20, 30, 40])</span>
<span class="sd">        &gt;&gt;&gt; s</span>
<span class="sd">        10    1.0</span>
<span class="sd">        20    2.0</span>
<span class="sd">        30    NaN</span>
<span class="sd">        40    4.0</span>
<span class="sd">        dtype: float64</span>

<span class="sd">        &gt;&gt;&gt; s.asof(20)</span>
<span class="sd">        2.0</span>

<span class="sd">        For a sequence `where`, a Series is returned. The first value is</span>
<span class="sd">        NaN, because the first element of `where` is before the first</span>
<span class="sd">        index value.</span>

<span class="sd">        &gt;&gt;&gt; s.asof([5, 20])</span>
<span class="sd">        5     NaN</span>
<span class="sd">        20    2.0</span>
<span class="sd">        dtype: float64</span>

<span class="sd">        Missing values are not considered. The following is ``2.0``, not</span>
<span class="sd">        NaN, even though NaN is at the index location for ``30``.</span>

<span class="sd">        &gt;&gt;&gt; s.asof(30)</span>
<span class="sd">        2.0</span>

<span class="sd">        Take all columns into consideration</span>

<span class="sd">        &gt;&gt;&gt; df = pd.DataFrame({&#39;a&#39;: [10, 20, 30, 40, 50],</span>
<span class="sd">        ...                    &#39;b&#39;: [None, None, None, None, 500]},</span>
<span class="sd">        ...                   index=pd.DatetimeIndex([&#39;2018-02-27 09:01:00&#39;,</span>
<span class="sd">        ...                                           &#39;2018-02-27 09:02:00&#39;,</span>
<span class="sd">        ...                                           &#39;2018-02-27 09:03:00&#39;,</span>
<span class="sd">        ...                                           &#39;2018-02-27 09:04:00&#39;,</span>
<span class="sd">        ...                                           &#39;2018-02-27 09:05:00&#39;]))</span>
<span class="sd">        &gt;&gt;&gt; df.asof(pd.DatetimeIndex([&#39;2018-02-27 09:03:30&#39;,</span>
<span class="sd">        ...                           &#39;2018-02-27 09:04:30&#39;]))</span>
<span class="sd">                              a   b</span>
<span class="sd">        2018-02-27 09:03:30 NaN NaN</span>
<span class="sd">        2018-02-27 09:04:30 NaN NaN</span>

<span class="sd">        Take a single column into consideration</span>

<span class="sd">        &gt;&gt;&gt; df.asof(pd.DatetimeIndex([&#39;2018-02-27 09:03:30&#39;,</span>
<span class="sd">        ...                           &#39;2018-02-27 09:04:30&#39;]),</span>
<span class="sd">        ...         subset=[&#39;a&#39;])</span>
<span class="sd">                                 a   b</span>
<span class="sd">        2018-02-27 09:03:30   30.0 NaN</span>
<span class="sd">        2018-02-27 09:04:30   40.0 NaN</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">where</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="kn">from</span> <span class="nn">pandas</span> <span class="k">import</span> <span class="n">to_datetime</span>

            <span class="n">where</span> <span class="o">=</span> <span class="n">to_datetime</span><span class="p">(</span><span class="n">where</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">is_monotonic</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;asof requires a sorted index&quot;</span><span class="p">)</span>

        <span class="n">is_series</span> <span class="o">=</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ABCSeries</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">is_series</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">subset</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;subset is not valid for Series&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">subset</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">subset</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">columns</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">is_list_like</span><span class="p">(</span><span class="n">subset</span><span class="p">):</span>
                <span class="n">subset</span> <span class="o">=</span> <span class="p">[</span><span class="n">subset</span><span class="p">]</span>

        <span class="n">is_list</span> <span class="o">=</span> <span class="n">is_list_like</span><span class="p">(</span><span class="n">where</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">is_list</span><span class="p">:</span>
            <span class="n">start</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="n">PeriodIndex</span><span class="p">):</span>
                <span class="n">where</span> <span class="o">=</span> <span class="n">Period</span><span class="p">(</span><span class="n">where</span><span class="p">,</span> <span class="n">freq</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">freq</span><span class="p">)</span><span class="o">.</span><span class="n">ordinal</span>
                <span class="n">start</span> <span class="o">=</span> <span class="n">start</span><span class="o">.</span><span class="n">ordinal</span>

            <span class="k">if</span> <span class="n">where</span> <span class="o">&lt;</span> <span class="n">start</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">is_series</span><span class="p">:</span>
                    <span class="kn">from</span> <span class="nn">pandas</span> <span class="k">import</span> <span class="n">Series</span>

                    <span class="k">return</span> <span class="n">Series</span><span class="p">(</span><span class="n">index</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">columns</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">where</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>

            <span class="c1"># It&#39;s always much faster to use a *while* loop here for</span>
            <span class="c1"># Series than pre-computing all the NAs. However a</span>
            <span class="c1"># *while* loop is extremely expensive for DataFrame</span>
            <span class="c1"># so we later pre-compute all the NAs and use the same</span>
            <span class="c1"># code path whether *where* is a scalar or list.</span>
            <span class="c1"># See PR: https://github.com/pandas-dev/pandas/pull/14476</span>
            <span class="k">if</span> <span class="n">is_series</span><span class="p">:</span>
                <span class="n">loc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">searchsorted</span><span class="p">(</span><span class="n">where</span><span class="p">,</span> <span class="n">side</span><span class="o">=</span><span class="s2">&quot;right&quot;</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">loc</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">loc</span> <span class="o">-=</span> <span class="mi">1</span>

                <span class="n">values</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_values</span>
                <span class="k">while</span> <span class="n">loc</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">isna</span><span class="p">(</span><span class="n">values</span><span class="p">[</span><span class="n">loc</span><span class="p">]):</span>
                    <span class="n">loc</span> <span class="o">-=</span> <span class="mi">1</span>
                <span class="k">return</span> <span class="n">values</span><span class="p">[</span><span class="n">loc</span><span class="p">]</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">where</span><span class="p">,</span> <span class="n">Index</span><span class="p">):</span>
            <span class="n">where</span> <span class="o">=</span> <span class="n">Index</span><span class="p">(</span><span class="n">where</span><span class="p">)</span> <span class="k">if</span> <span class="n">is_list</span> <span class="k">else</span> <span class="n">Index</span><span class="p">([</span><span class="n">where</span><span class="p">])</span>

        <span class="n">nulls</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">isna</span><span class="p">()</span> <span class="k">if</span> <span class="n">is_series</span> <span class="k">else</span> <span class="bp">self</span><span class="p">[</span><span class="n">subset</span><span class="p">]</span><span class="o">.</span><span class="n">isna</span><span class="p">()</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">nulls</span><span class="o">.</span><span class="n">all</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">is_series</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_constructor</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="n">where</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">is_list</span><span class="p">:</span>
                <span class="kn">from</span> <span class="nn">pandas</span> <span class="k">import</span> <span class="n">DataFrame</span>

                <span class="k">return</span> <span class="n">DataFrame</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="n">where</span><span class="p">,</span> <span class="n">columns</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">columns</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="kn">from</span> <span class="nn">pandas</span> <span class="k">import</span> <span class="n">Series</span>

                <span class="k">return</span> <span class="n">Series</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">columns</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">where</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

        <span class="n">locs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">asof_locs</span><span class="p">(</span><span class="n">where</span><span class="p">,</span> <span class="o">~</span><span class="p">(</span><span class="n">nulls</span><span class="o">.</span><span class="n">values</span><span class="p">))</span>

        <span class="c1"># mask the missing</span>
        <span class="n">missing</span> <span class="o">=</span> <span class="n">locs</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span>
        <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">take</span><span class="p">(</span><span class="n">locs</span><span class="p">,</span> <span class="n">is_copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">data</span><span class="o">.</span><span class="n">index</span> <span class="o">=</span> <span class="n">where</span>
        <span class="n">data</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">missing</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
        <span class="k">return</span> <span class="n">data</span> <span class="k">if</span> <span class="n">is_list</span> <span class="k">else</span> <span class="n">data</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

    <span class="c1"># ----------------------------------------------------------------------</span>
    <span class="c1"># Action Methods</span>

    <span class="n">_shared_docs</span><span class="p">[</span>
        <span class="s2">&quot;isna&quot;</span>
    <span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;</span>
<span class="s2">        Detect missing values.</span>

<span class="s2">        Return a boolean same-sized object indicating if the values are NA.</span>
<span class="s2">        NA values, such as None or :attr:`numpy.NaN`, gets mapped to True</span>
<span class="s2">        values.</span>
<span class="s2">        Everything else gets mapped to False values. Characters such as empty</span>
<span class="s2">        strings ``&#39;&#39;`` or :attr:`numpy.inf` are not considered NA values</span>
<span class="s2">        (unless you set ``pandas.options.mode.use_inf_as_na = True``).</span>

<span class="s2">        Returns</span>
<span class="s2">        -------</span>
<span class="s2">        </span><span class="si">%(klass)s</span><span class="s2"></span>
<span class="s2">            Mask of bool values for each element in </span><span class="si">%(klass)s</span><span class="s2"> that</span>
<span class="s2">            indicates whether an element is not an NA value.</span>

<span class="s2">        See Also</span>
<span class="s2">        --------</span>
<span class="s2">        </span><span class="si">%(klass)s</span><span class="s2">.isnull : Alias of isna.</span>
<span class="s2">        </span><span class="si">%(klass)s</span><span class="s2">.notna : Boolean inverse of isna.</span>
<span class="s2">        </span><span class="si">%(klass)s</span><span class="s2">.dropna : Omit axes labels with missing values.</span>
<span class="s2">        isna : Top-level isna.</span>

<span class="s2">        Examples</span>
<span class="s2">        --------</span>
<span class="s2">        Show which entries in a DataFrame are NA.</span>

<span class="s2">        &gt;&gt;&gt; df = pd.DataFrame({&#39;age&#39;: [5, 6, np.NaN],</span>
<span class="s2">        ...                    &#39;born&#39;: [pd.NaT, pd.Timestamp(&#39;1939-05-27&#39;),</span>
<span class="s2">        ...                             pd.Timestamp(&#39;1940-04-25&#39;)],</span>
<span class="s2">        ...                    &#39;name&#39;: [&#39;Alfred&#39;, &#39;Batman&#39;, &#39;&#39;],</span>
<span class="s2">        ...                    &#39;toy&#39;: [None, &#39;Batmobile&#39;, &#39;Joker&#39;]})</span>
<span class="s2">        &gt;&gt;&gt; df</span>
<span class="s2">           age       born    name        toy</span>
<span class="s2">        0  5.0        NaT  Alfred       None</span>
<span class="s2">        1  6.0 1939-05-27  Batman  Batmobile</span>
<span class="s2">        2  NaN 1940-04-25              Joker</span>

<span class="s2">        &gt;&gt;&gt; df.isna()</span>
<span class="s2">             age   born   name    toy</span>
<span class="s2">        0  False   True  False   True</span>
<span class="s2">        1  False  False  False  False</span>
<span class="s2">        2   True  False  False  False</span>

<span class="s2">        Show which entries in a Series are NA.</span>

<span class="s2">        &gt;&gt;&gt; ser = pd.Series([5, 6, np.NaN])</span>
<span class="s2">        &gt;&gt;&gt; ser</span>
<span class="s2">        0    5.0</span>
<span class="s2">        1    6.0</span>
<span class="s2">        2    NaN</span>
<span class="s2">        dtype: float64</span>

<span class="s2">        &gt;&gt;&gt; ser.isna()</span>
<span class="s2">        0    False</span>
<span class="s2">        1    False</span>
<span class="s2">        2     True</span>
<span class="s2">        dtype: bool</span>
<span class="s2">        &quot;&quot;&quot;</span>

    <span class="nd">@Appender</span><span class="p">(</span><span class="n">_shared_docs</span><span class="p">[</span><span class="s2">&quot;isna&quot;</span><span class="p">]</span> <span class="o">%</span> <span class="n">_shared_doc_kwargs</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">isna</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">isna</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">__finalize__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="nd">@Appender</span><span class="p">(</span><span class="n">_shared_docs</span><span class="p">[</span><span class="s2">&quot;isna&quot;</span><span class="p">]</span> <span class="o">%</span> <span class="n">_shared_doc_kwargs</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">isnull</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">isna</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">__finalize__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="n">_shared_docs</span><span class="p">[</span>
        <span class="s2">&quot;notna&quot;</span>
    <span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;</span>
<span class="s2">        Detect existing (non-missing) values.</span>

<span class="s2">        Return a boolean same-sized object indicating if the values are not NA.</span>
<span class="s2">        Non-missing values get mapped to True. Characters such as empty</span>
<span class="s2">        strings ``&#39;&#39;`` or :attr:`numpy.inf` are not considered NA values</span>
<span class="s2">        (unless you set ``pandas.options.mode.use_inf_as_na = True``).</span>
<span class="s2">        NA values, such as None or :attr:`numpy.NaN`, get mapped to False</span>
<span class="s2">        values.</span>

<span class="s2">        Returns</span>
<span class="s2">        -------</span>
<span class="s2">        </span><span class="si">%(klass)s</span><span class="s2"></span>
<span class="s2">            Mask of bool values for each element in </span><span class="si">%(klass)s</span><span class="s2"> that</span>
<span class="s2">            indicates whether an element is not an NA value.</span>

<span class="s2">        See Also</span>
<span class="s2">        --------</span>
<span class="s2">        </span><span class="si">%(klass)s</span><span class="s2">.notnull : Alias of notna.</span>
<span class="s2">        </span><span class="si">%(klass)s</span><span class="s2">.isna : Boolean inverse of notna.</span>
<span class="s2">        </span><span class="si">%(klass)s</span><span class="s2">.dropna : Omit axes labels with missing values.</span>
<span class="s2">        notna : Top-level notna.</span>

<span class="s2">        Examples</span>
<span class="s2">        --------</span>
<span class="s2">        Show which entries in a DataFrame are not NA.</span>

<span class="s2">        &gt;&gt;&gt; df = pd.DataFrame({&#39;age&#39;: [5, 6, np.NaN],</span>
<span class="s2">        ...                    &#39;born&#39;: [pd.NaT, pd.Timestamp(&#39;1939-05-27&#39;),</span>
<span class="s2">        ...                             pd.Timestamp(&#39;1940-04-25&#39;)],</span>
<span class="s2">        ...                    &#39;name&#39;: [&#39;Alfred&#39;, &#39;Batman&#39;, &#39;&#39;],</span>
<span class="s2">        ...                    &#39;toy&#39;: [None, &#39;Batmobile&#39;, &#39;Joker&#39;]})</span>
<span class="s2">        &gt;&gt;&gt; df</span>
<span class="s2">           age       born    name        toy</span>
<span class="s2">        0  5.0        NaT  Alfred       None</span>
<span class="s2">        1  6.0 1939-05-27  Batman  Batmobile</span>
<span class="s2">        2  NaN 1940-04-25              Joker</span>

<span class="s2">        &gt;&gt;&gt; df.notna()</span>
<span class="s2">             age   born  name    toy</span>
<span class="s2">        0   True  False  True  False</span>
<span class="s2">        1   True   True  True   True</span>
<span class="s2">        2  False   True  True   True</span>

<span class="s2">        Show which entries in a Series are not NA.</span>

<span class="s2">        &gt;&gt;&gt; ser = pd.Series([5, 6, np.NaN])</span>
<span class="s2">        &gt;&gt;&gt; ser</span>
<span class="s2">        0    5.0</span>
<span class="s2">        1    6.0</span>
<span class="s2">        2    NaN</span>
<span class="s2">        dtype: float64</span>

<span class="s2">        &gt;&gt;&gt; ser.notna()</span>
<span class="s2">        0     True</span>
<span class="s2">        1     True</span>
<span class="s2">        2    False</span>
<span class="s2">        dtype: bool</span>
<span class="s2">        &quot;&quot;&quot;</span>

    <span class="nd">@Appender</span><span class="p">(</span><span class="n">_shared_docs</span><span class="p">[</span><span class="s2">&quot;notna&quot;</span><span class="p">]</span> <span class="o">%</span> <span class="n">_shared_doc_kwargs</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">notna</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">notna</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">__finalize__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="nd">@Appender</span><span class="p">(</span><span class="n">_shared_docs</span><span class="p">[</span><span class="s2">&quot;notna&quot;</span><span class="p">]</span> <span class="o">%</span> <span class="n">_shared_doc_kwargs</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">notnull</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">notna</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">__finalize__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_clip_with_scalar</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lower</span><span class="p">,</span> <span class="n">upper</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">lower</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">isna</span><span class="p">(</span><span class="n">lower</span><span class="p">)))</span> <span class="ow">or</span> <span class="p">(</span>
            <span class="n">upper</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">isna</span><span class="p">(</span><span class="n">upper</span><span class="p">))</span>
        <span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Cannot use an NA value as a clip threshold&quot;</span><span class="p">)</span>

        <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="n">isna</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="p">)</span>

        <span class="k">with</span> <span class="n">np</span><span class="o">.</span><span class="n">errstate</span><span class="p">(</span><span class="nb">all</span><span class="o">=</span><span class="s2">&quot;ignore&quot;</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">upper</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">subset</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">()</span> <span class="o">&lt;=</span> <span class="n">upper</span>
                <span class="n">result</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">subset</span><span class="p">,</span> <span class="n">upper</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">lower</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">subset</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">()</span> <span class="o">&gt;=</span> <span class="n">lower</span>
                <span class="n">result</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">subset</span><span class="p">,</span> <span class="n">lower</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">mask</span><span class="p">):</span>
            <span class="n">result</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>

        <span class="k">if</span> <span class="n">inplace</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_update_inplace</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">result</span>

    <span class="k">def</span> <span class="nf">_clip_with_one_bound</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">threshold</span><span class="p">,</span> <span class="n">method</span><span class="p">,</span> <span class="n">axis</span><span class="p">,</span> <span class="n">inplace</span><span class="p">):</span>

        <span class="k">if</span> <span class="n">axis</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">axis</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_axis_number</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span>

        <span class="c1"># method is self.le for upper bound and self.ge for lower bound</span>
        <span class="k">if</span> <span class="n">is_scalar</span><span class="p">(</span><span class="n">threshold</span><span class="p">)</span> <span class="ow">and</span> <span class="n">is_number</span><span class="p">(</span><span class="n">threshold</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">method</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">==</span> <span class="s2">&quot;le&quot;</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_clip_with_scalar</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="n">threshold</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="n">inplace</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_clip_with_scalar</span><span class="p">(</span><span class="n">threshold</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="n">inplace</span><span class="p">)</span>

        <span class="n">subset</span> <span class="o">=</span> <span class="n">method</span><span class="p">(</span><span class="n">threshold</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span> <span class="o">|</span> <span class="n">isna</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

        <span class="c1"># GH #15390</span>
        <span class="c1"># In order for where method to work, the threshold must</span>
        <span class="c1"># be transformed to NDFrame from other array like structure.</span>
        <span class="k">if</span> <span class="p">(</span><span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">threshold</span><span class="p">,</span> <span class="n">ABCSeries</span><span class="p">))</span> <span class="ow">and</span> <span class="n">is_list_like</span><span class="p">(</span><span class="n">threshold</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ABCSeries</span><span class="p">):</span>
                <span class="n">threshold</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">threshold</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">threshold</span> <span class="o">=</span> <span class="n">_align_method_FRAME</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">threshold</span><span class="p">,</span> <span class="n">axis</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">subset</span><span class="p">,</span> <span class="n">threshold</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="n">inplace</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">clip</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lower</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">upper</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Trim values at input threshold(s).</span>

<span class="sd">        Assigns values outside boundary to boundary values. Thresholds</span>
<span class="sd">        can be singular values or array like, and in the latter case</span>
<span class="sd">        the clipping is performed element-wise in the specified axis.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        lower : float or array_like, default None</span>
<span class="sd">            Minimum threshold value. All values below this</span>
<span class="sd">            threshold will be set to it.</span>
<span class="sd">        upper : float or array_like, default None</span>
<span class="sd">            Maximum threshold value. All values above this</span>
<span class="sd">            threshold will be set to it.</span>
<span class="sd">        axis : int or str axis name, optional</span>
<span class="sd">            Align object with lower and upper along the given axis.</span>
<span class="sd">        inplace : bool, default False</span>
<span class="sd">            Whether to perform the operation in place on the data.</span>

<span class="sd">            .. versionadded:: 0.21.0</span>
<span class="sd">        *args, **kwargs</span>
<span class="sd">            Additional keywords have no effect but might be accepted</span>
<span class="sd">            for compatibility with numpy.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Series or DataFrame</span>
<span class="sd">            Same type as calling object with the values outside the</span>
<span class="sd">            clip boundaries replaced.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; data = {&#39;col_0&#39;: [9, -3, 0, -1, 5], &#39;col_1&#39;: [-2, -7, 6, 8, -5]}</span>
<span class="sd">        &gt;&gt;&gt; df = pd.DataFrame(data)</span>
<span class="sd">        &gt;&gt;&gt; df</span>
<span class="sd">           col_0  col_1</span>
<span class="sd">        0      9     -2</span>
<span class="sd">        1     -3     -7</span>
<span class="sd">        2      0      6</span>
<span class="sd">        3     -1      8</span>
<span class="sd">        4      5     -5</span>

<span class="sd">        Clips per column using lower and upper thresholds:</span>

<span class="sd">        &gt;&gt;&gt; df.clip(-4, 6)</span>
<span class="sd">           col_0  col_1</span>
<span class="sd">        0      6     -2</span>
<span class="sd">        1     -3     -4</span>
<span class="sd">        2      0      6</span>
<span class="sd">        3     -1      6</span>
<span class="sd">        4      5     -4</span>

<span class="sd">        Clips using specific lower and upper thresholds per column element:</span>

<span class="sd">        &gt;&gt;&gt; t = pd.Series([2, -4, -1, 6, 3])</span>
<span class="sd">        &gt;&gt;&gt; t</span>
<span class="sd">        0    2</span>
<span class="sd">        1   -4</span>
<span class="sd">        2   -1</span>
<span class="sd">        3    6</span>
<span class="sd">        4    3</span>
<span class="sd">        dtype: int64</span>

<span class="sd">        &gt;&gt;&gt; df.clip(t, t + 4, axis=0)</span>
<span class="sd">           col_0  col_1</span>
<span class="sd">        0      6      2</span>
<span class="sd">        1     -3     -4</span>
<span class="sd">        2      0      3</span>
<span class="sd">        3      6      8</span>
<span class="sd">        4      5      3</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">inplace</span> <span class="o">=</span> <span class="n">validate_bool_kwarg</span><span class="p">(</span><span class="n">inplace</span><span class="p">,</span> <span class="s2">&quot;inplace&quot;</span><span class="p">)</span>

        <span class="n">axis</span> <span class="o">=</span> <span class="n">nv</span><span class="o">.</span><span class="n">validate_clip_with_axis</span><span class="p">(</span><span class="n">axis</span><span class="p">,</span> <span class="n">args</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">axis</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">axis</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_axis_number</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span>

        <span class="c1"># GH 17276</span>
        <span class="c1"># numpy doesn&#39;t like NaN as a clip value</span>
        <span class="c1"># so ignore</span>
        <span class="c1"># GH 19992</span>
        <span class="c1"># numpy doesn&#39;t drop a list-like bound containing NaN</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">is_list_like</span><span class="p">(</span><span class="n">lower</span><span class="p">)</span> <span class="ow">and</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">pd</span><span class="o">.</span><span class="n">isnull</span><span class="p">(</span><span class="n">lower</span><span class="p">)):</span>
            <span class="n">lower</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">is_list_like</span><span class="p">(</span><span class="n">upper</span><span class="p">)</span> <span class="ow">and</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">pd</span><span class="o">.</span><span class="n">isnull</span><span class="p">(</span><span class="n">upper</span><span class="p">)):</span>
            <span class="n">upper</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="c1"># GH 2747 (arguments were reversed)</span>
        <span class="k">if</span> <span class="n">lower</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">upper</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">is_scalar</span><span class="p">(</span><span class="n">lower</span><span class="p">)</span> <span class="ow">and</span> <span class="n">is_scalar</span><span class="p">(</span><span class="n">upper</span><span class="p">):</span>
                <span class="n">lower</span><span class="p">,</span> <span class="n">upper</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">lower</span><span class="p">,</span> <span class="n">upper</span><span class="p">),</span> <span class="nb">max</span><span class="p">(</span><span class="n">lower</span><span class="p">,</span> <span class="n">upper</span><span class="p">)</span>

        <span class="c1"># fast-path for scalars</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">lower</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="p">(</span><span class="n">is_scalar</span><span class="p">(</span><span class="n">lower</span><span class="p">)</span> <span class="ow">and</span> <span class="n">is_number</span><span class="p">(</span><span class="n">lower</span><span class="p">)))</span> <span class="ow">and</span> <span class="p">(</span>
            <span class="n">upper</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="p">(</span><span class="n">is_scalar</span><span class="p">(</span><span class="n">upper</span><span class="p">)</span> <span class="ow">and</span> <span class="n">is_number</span><span class="p">(</span><span class="n">upper</span><span class="p">))</span>
        <span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_clip_with_scalar</span><span class="p">(</span><span class="n">lower</span><span class="p">,</span> <span class="n">upper</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="n">inplace</span><span class="p">)</span>

        <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="k">if</span> <span class="n">lower</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">_clip_with_one_bound</span><span class="p">(</span>
                <span class="n">lower</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">ge</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="n">inplace</span>
            <span class="p">)</span>
        <span class="k">if</span> <span class="n">upper</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">inplace</span><span class="p">:</span>
                <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">_clip_with_one_bound</span><span class="p">(</span>
                <span class="n">upper</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">le</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="n">inplace</span>
            <span class="p">)</span>

        <span class="k">return</span> <span class="n">result</span>

    <span class="k">def</span> <span class="nf">clip_upper</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">threshold</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Trim values above a given threshold.</span>

<span class="sd">        .. deprecated:: 0.24.0</span>
<span class="sd">            Use clip(upper=threshold) instead.</span>

<span class="sd">        Elements above the `threshold` will be changed to match the</span>
<span class="sd">        `threshold` value(s). Threshold can be a single value or an array,</span>
<span class="sd">        in the latter case it performs the truncation element-wise.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        threshold : numeric or array-like</span>
<span class="sd">            Maximum value allowed. All values above threshold will be set to</span>
<span class="sd">            this value.</span>

<span class="sd">            * float : every value is compared to `threshold`.</span>
<span class="sd">            * array-like : The shape of `threshold` should match the object</span>
<span class="sd">              it&#39;s compared to. When `self` is a Series, `threshold` should be</span>
<span class="sd">              the length. When `self` is a DataFrame, `threshold` should 2-D</span>
<span class="sd">              and the same shape as `self` for ``axis=None``, or 1-D and the</span>
<span class="sd">              same length as the axis being compared.</span>

<span class="sd">        axis : {0 or &#39;index&#39;, 1 or &#39;columns&#39;}, default 0</span>
<span class="sd">            Align object with `threshold` along the given axis.</span>
<span class="sd">        inplace : bool, default False</span>
<span class="sd">            Whether to perform the operation in place on the data.</span>

<span class="sd">            .. versionadded:: 0.21.0</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Series or DataFrame</span>
<span class="sd">            Original data with values trimmed.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        Series.clip : General purpose method to trim Series values to given</span>
<span class="sd">            threshold(s).</span>
<span class="sd">        DataFrame.clip : General purpose method to trim DataFrame values to</span>
<span class="sd">            given threshold(s).</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; s = pd.Series([1, 2, 3, 4, 5])</span>
<span class="sd">        &gt;&gt;&gt; s</span>
<span class="sd">        0    1</span>
<span class="sd">        1    2</span>
<span class="sd">        2    3</span>
<span class="sd">        3    4</span>
<span class="sd">        4    5</span>
<span class="sd">        dtype: int64</span>

<span class="sd">        &gt;&gt;&gt; s.clip(upper=3)</span>
<span class="sd">        0    1</span>
<span class="sd">        1    2</span>
<span class="sd">        2    3</span>
<span class="sd">        3    3</span>
<span class="sd">        4    3</span>
<span class="sd">        dtype: int64</span>

<span class="sd">        &gt;&gt;&gt; elemwise_thresholds = [5, 4, 3, 2, 1]</span>
<span class="sd">        &gt;&gt;&gt; elemwise_thresholds</span>
<span class="sd">        [5, 4, 3, 2, 1]</span>

<span class="sd">        &gt;&gt;&gt; s.clip(upper=elemwise_thresholds)</span>
<span class="sd">        0    1</span>
<span class="sd">        1    2</span>
<span class="sd">        2    3</span>
<span class="sd">        3    2</span>
<span class="sd">        4    1</span>
<span class="sd">        dtype: int64</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
            <span class="s2">&quot;clip_upper(threshold) is deprecated, &quot;</span> <span class="s2">&quot;use clip(upper=threshold) instead&quot;</span><span class="p">,</span>
            <span class="ne">FutureWarning</span><span class="p">,</span>
            <span class="n">stacklevel</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_clip_with_one_bound</span><span class="p">(</span>
            <span class="n">threshold</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">le</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="n">inplace</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">clip_lower</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">threshold</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Trim values below a given threshold.</span>

<span class="sd">        .. deprecated:: 0.24.0</span>
<span class="sd">            Use clip(lower=threshold) instead.</span>

<span class="sd">        Elements below the `threshold` will be changed to match the</span>
<span class="sd">        `threshold` value(s). Threshold can be a single value or an array,</span>
<span class="sd">        in the latter case it performs the truncation element-wise.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        threshold : numeric or array-like</span>
<span class="sd">            Minimum value allowed. All values below threshold will be set to</span>
<span class="sd">            this value.</span>

<span class="sd">            * float : every value is compared to `threshold`.</span>
<span class="sd">            * array-like : The shape of `threshold` should match the object</span>
<span class="sd">              it&#39;s compared to. When `self` is a Series, `threshold` should be</span>
<span class="sd">              the length. When `self` is a DataFrame, `threshold` should 2-D</span>
<span class="sd">              and the same shape as `self` for ``axis=None``, or 1-D and the</span>
<span class="sd">              same length as the axis being compared.</span>

<span class="sd">        axis : {0 or &#39;index&#39;, 1 or &#39;columns&#39;}, default 0</span>
<span class="sd">            Align `self` with `threshold` along the given axis.</span>

<span class="sd">        inplace : bool, default False</span>
<span class="sd">            Whether to perform the operation in place on the data.</span>

<span class="sd">            .. versionadded:: 0.21.0</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Series or DataFrame</span>
<span class="sd">            Original data with values trimmed.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        Series.clip : General purpose method to trim Series values to given</span>
<span class="sd">            threshold(s).</span>
<span class="sd">        DataFrame.clip : General purpose method to trim DataFrame values to</span>
<span class="sd">            given threshold(s).</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>

<span class="sd">        Series single threshold clipping:</span>

<span class="sd">        &gt;&gt;&gt; s = pd.Series([5, 6, 7, 8, 9])</span>
<span class="sd">        &gt;&gt;&gt; s.clip(lower=8)</span>
<span class="sd">        0    8</span>
<span class="sd">        1    8</span>
<span class="sd">        2    8</span>
<span class="sd">        3    8</span>
<span class="sd">        4    9</span>
<span class="sd">        dtype: int64</span>

<span class="sd">        Series clipping element-wise using an array of thresholds. `threshold`</span>
<span class="sd">        should be the same length as the Series.</span>

<span class="sd">        &gt;&gt;&gt; elemwise_thresholds = [4, 8, 7, 2, 5]</span>
<span class="sd">        &gt;&gt;&gt; s.clip(lower=elemwise_thresholds)</span>
<span class="sd">        0    5</span>
<span class="sd">        1    8</span>
<span class="sd">        2    7</span>
<span class="sd">        3    8</span>
<span class="sd">        4    9</span>
<span class="sd">        dtype: int64</span>

<span class="sd">        DataFrames can be compared to a scalar.</span>

<span class="sd">        &gt;&gt;&gt; df = pd.DataFrame({&quot;A&quot;: [1, 3, 5], &quot;B&quot;: [2, 4, 6]})</span>
<span class="sd">        &gt;&gt;&gt; df</span>
<span class="sd">           A  B</span>
<span class="sd">        0  1  2</span>
<span class="sd">        1  3  4</span>
<span class="sd">        2  5  6</span>

<span class="sd">        &gt;&gt;&gt; df.clip(lower=3)</span>
<span class="sd">           A  B</span>
<span class="sd">        0  3  3</span>
<span class="sd">        1  3  4</span>
<span class="sd">        2  5  6</span>

<span class="sd">        Or to an array of values. By default, `threshold` should be the same</span>
<span class="sd">        shape as the DataFrame.</span>

<span class="sd">        &gt;&gt;&gt; df.clip(lower=np.array([[3, 4], [2, 2], [6, 2]]))</span>
<span class="sd">           A  B</span>
<span class="sd">        0  3  4</span>
<span class="sd">        1  3  4</span>
<span class="sd">        2  6  6</span>

<span class="sd">        Control how `threshold` is broadcast with `axis`. In this case</span>
<span class="sd">        `threshold` should be the same length as the axis specified by</span>
<span class="sd">        `axis`.</span>

<span class="sd">        &gt;&gt;&gt; df.clip(lower=[3, 3, 5], axis=&#39;index&#39;)</span>
<span class="sd">           A  B</span>
<span class="sd">        0  3  3</span>
<span class="sd">        1  3  4</span>
<span class="sd">        2  5  6</span>

<span class="sd">        &gt;&gt;&gt; df.clip(lower=[4, 5], axis=&#39;columns&#39;)</span>
<span class="sd">           A  B</span>
<span class="sd">        0  4  5</span>
<span class="sd">        1  4  5</span>
<span class="sd">        2  5  6</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
            <span class="s2">&quot;clip_lower(threshold) is deprecated, &quot;</span> <span class="s2">&quot;use clip(lower=threshold) instead&quot;</span><span class="p">,</span>
            <span class="ne">FutureWarning</span><span class="p">,</span>
            <span class="n">stacklevel</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_clip_with_one_bound</span><span class="p">(</span>
            <span class="n">threshold</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">ge</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="n">inplace</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">groupby</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">by</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
        <span class="n">level</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">as_index</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">sort</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">group_keys</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">squeeze</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">observed</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Group DataFrame or Series using a mapper or by a Series of columns.</span>

<span class="sd">        A groupby operation involves some combination of splitting the</span>
<span class="sd">        object, applying a function, and combining the results. This can be</span>
<span class="sd">        used to group large amounts of data and compute operations on these</span>
<span class="sd">        groups.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        by : mapping, function, label, or list of labels</span>
<span class="sd">            Used to determine the groups for the groupby.</span>
<span class="sd">            If ``by`` is a function, it&#39;s called on each value of the object&#39;s</span>
<span class="sd">            index. If a dict or Series is passed, the Series or dict VALUES</span>
<span class="sd">            will be used to determine the groups (the Series&#39; values are first</span>
<span class="sd">            aligned; see ``.align()`` method). If an ndarray is passed, the</span>
<span class="sd">            values are used as-is determine the groups. A label or list of</span>
<span class="sd">            labels may be passed to group by the columns in ``self``. Notice</span>
<span class="sd">            that a tuple is interpreted as a (single) key.</span>
<span class="sd">        axis : {0 or &#39;index&#39;, 1 or &#39;columns&#39;}, default 0</span>
<span class="sd">            Split along rows (0) or columns (1).</span>
<span class="sd">        level : int, level name, or sequence of such, default None</span>
<span class="sd">            If the axis is a MultiIndex (hierarchical), group by a particular</span>
<span class="sd">            level or levels.</span>
<span class="sd">        as_index : bool, default True</span>
<span class="sd">            For aggregated output, return object with group labels as the</span>
<span class="sd">            index. Only relevant for DataFrame input. as_index=False is</span>
<span class="sd">            effectively &quot;SQL-style&quot; grouped output.</span>
<span class="sd">        sort : bool, default True</span>
<span class="sd">            Sort group keys. Get better performance by turning this off.</span>
<span class="sd">            Note this does not influence the order of observations within each</span>
<span class="sd">            group. Groupby preserves the order of rows within each group.</span>
<span class="sd">        group_keys : bool, default True</span>
<span class="sd">            When calling apply, add group keys to index to identify pieces.</span>
<span class="sd">        squeeze : bool, default False</span>
<span class="sd">            Reduce the dimensionality of the return type if possible,</span>
<span class="sd">            otherwise return a consistent type.</span>
<span class="sd">        observed : bool, default False</span>
<span class="sd">            This only applies if any of the groupers are Categoricals.</span>
<span class="sd">            If True: only show observed values for categorical groupers.</span>
<span class="sd">            If False: show all values for categorical groupers.</span>

<span class="sd">            .. versionadded:: 0.23.0</span>

<span class="sd">        **kwargs</span>
<span class="sd">            Optional, only accepts keyword argument &#39;mutated&#39; and is passed</span>
<span class="sd">            to groupby.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        DataFrameGroupBy or SeriesGroupBy</span>
<span class="sd">            Depends on the calling object and returns groupby object that</span>
<span class="sd">            contains information about the groups.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        resample : Convenience method for frequency conversion and resampling</span>
<span class="sd">            of time series.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        See the `user guide</span>
<span class="sd">        &lt;http://pandas.pydata.org/pandas-docs/stable/groupby.html&gt;`_ for more.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; df = pd.DataFrame({&#39;Animal&#39;: [&#39;Falcon&#39;, &#39;Falcon&#39;,</span>
<span class="sd">        ...                               &#39;Parrot&#39;, &#39;Parrot&#39;],</span>
<span class="sd">        ...                    &#39;Max Speed&#39;: [380., 370., 24., 26.]})</span>
<span class="sd">        &gt;&gt;&gt; df</span>
<span class="sd">           Animal  Max Speed</span>
<span class="sd">        0  Falcon      380.0</span>
<span class="sd">        1  Falcon      370.0</span>
<span class="sd">        2  Parrot       24.0</span>
<span class="sd">        3  Parrot       26.0</span>
<span class="sd">        &gt;&gt;&gt; df.groupby([&#39;Animal&#39;]).mean()</span>
<span class="sd">                Max Speed</span>
<span class="sd">        Animal</span>
<span class="sd">        Falcon      375.0</span>
<span class="sd">        Parrot       25.0</span>

<span class="sd">        **Hierarchical Indexes**</span>

<span class="sd">        We can groupby different levels of a hierarchical index</span>
<span class="sd">        using the `level` parameter:</span>

<span class="sd">        &gt;&gt;&gt; arrays = [[&#39;Falcon&#39;, &#39;Falcon&#39;, &#39;Parrot&#39;, &#39;Parrot&#39;],</span>
<span class="sd">        ...           [&#39;Captive&#39;, &#39;Wild&#39;, &#39;Captive&#39;, &#39;Wild&#39;]]</span>
<span class="sd">        &gt;&gt;&gt; index = pd.MultiIndex.from_arrays(arrays, names=(&#39;Animal&#39;, &#39;Type&#39;))</span>
<span class="sd">        &gt;&gt;&gt; df = pd.DataFrame({&#39;Max Speed&#39;: [390., 350., 30., 20.]},</span>
<span class="sd">        ...                   index=index)</span>
<span class="sd">        &gt;&gt;&gt; df</span>
<span class="sd">                        Max Speed</span>
<span class="sd">        Animal Type</span>
<span class="sd">        Falcon Captive      390.0</span>
<span class="sd">               Wild         350.0</span>
<span class="sd">        Parrot Captive       30.0</span>
<span class="sd">               Wild          20.0</span>
<span class="sd">        &gt;&gt;&gt; df.groupby(level=0).mean()</span>
<span class="sd">                Max Speed</span>
<span class="sd">        Animal</span>
<span class="sd">        Falcon      370.0</span>
<span class="sd">        Parrot       25.0</span>
<span class="sd">        &gt;&gt;&gt; df.groupby(level=1).mean()</span>
<span class="sd">                 Max Speed</span>
<span class="sd">        Type</span>
<span class="sd">        Captive      210.0</span>
<span class="sd">        Wild         185.0</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">pandas.core.groupby.groupby</span> <span class="k">import</span> <span class="n">groupby</span>

        <span class="k">if</span> <span class="n">level</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">by</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;You have to supply one of &#39;by&#39; and &#39;level&#39;&quot;</span><span class="p">)</span>
        <span class="n">axis</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_axis_number</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">groupby</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">by</span><span class="o">=</span><span class="n">by</span><span class="p">,</span>
            <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span>
            <span class="n">level</span><span class="o">=</span><span class="n">level</span><span class="p">,</span>
            <span class="n">as_index</span><span class="o">=</span><span class="n">as_index</span><span class="p">,</span>
            <span class="n">sort</span><span class="o">=</span><span class="n">sort</span><span class="p">,</span>
            <span class="n">group_keys</span><span class="o">=</span><span class="n">group_keys</span><span class="p">,</span>
            <span class="n">squeeze</span><span class="o">=</span><span class="n">squeeze</span><span class="p">,</span>
            <span class="n">observed</span><span class="o">=</span><span class="n">observed</span><span class="p">,</span>
            <span class="o">**</span><span class="n">kwargs</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">asfreq</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">freq</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">how</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">normalize</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Convert TimeSeries to specified frequency.</span>

<span class="sd">        Optionally provide filling method to pad/backfill missing values.</span>

<span class="sd">        Returns the original data conformed to a new index with the specified</span>
<span class="sd">        frequency. ``resample`` is more appropriate if an operation, such as</span>
<span class="sd">        summarization, is necessary to represent the data at the new frequency.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        freq : DateOffset object, or string</span>
<span class="sd">        method : {&#39;backfill&#39;/&#39;bfill&#39;, &#39;pad&#39;/&#39;ffill&#39;}, default None</span>
<span class="sd">            Method to use for filling holes in reindexed Series (note this</span>
<span class="sd">            does not fill NaNs that already were present):</span>

<span class="sd">            * &#39;pad&#39; / &#39;ffill&#39;: propagate last valid observation forward to next</span>
<span class="sd">              valid</span>
<span class="sd">            * &#39;backfill&#39; / &#39;bfill&#39;: use NEXT valid observation to fill</span>
<span class="sd">        how : {&#39;start&#39;, &#39;end&#39;}, default end</span>
<span class="sd">            For PeriodIndex only, see PeriodIndex.asfreq</span>
<span class="sd">        normalize : bool, default False</span>
<span class="sd">            Whether to reset output index to midnight</span>
<span class="sd">        fill_value : scalar, optional</span>
<span class="sd">            Value to use for missing values, applied during upsampling (note</span>
<span class="sd">            this does not fill NaNs that already were present).</span>

<span class="sd">            .. versionadded:: 0.20.0</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        converted : same type as caller</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        reindex</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        To learn more about the frequency strings, please see `this link</span>
<span class="sd">        &lt;http://pandas.pydata.org/pandas-docs/stable/user_guide/timeseries.html#offset-aliases&gt;`__.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>

<span class="sd">        Start by creating a series with 4 one minute timestamps.</span>

<span class="sd">        &gt;&gt;&gt; index = pd.date_range(&#39;1/1/2000&#39;, periods=4, freq=&#39;T&#39;)</span>
<span class="sd">        &gt;&gt;&gt; series = pd.Series([0.0, None, 2.0, 3.0], index=index)</span>
<span class="sd">        &gt;&gt;&gt; df = pd.DataFrame({&#39;s&#39;:series})</span>
<span class="sd">        &gt;&gt;&gt; df</span>
<span class="sd">                               s</span>
<span class="sd">        2000-01-01 00:00:00    0.0</span>
<span class="sd">        2000-01-01 00:01:00    NaN</span>
<span class="sd">        2000-01-01 00:02:00    2.0</span>
<span class="sd">        2000-01-01 00:03:00    3.0</span>

<span class="sd">        Upsample the series into 30 second bins.</span>

<span class="sd">        &gt;&gt;&gt; df.asfreq(freq=&#39;30S&#39;)</span>
<span class="sd">                               s</span>
<span class="sd">        2000-01-01 00:00:00    0.0</span>
<span class="sd">        2000-01-01 00:00:30    NaN</span>
<span class="sd">        2000-01-01 00:01:00    NaN</span>
<span class="sd">        2000-01-01 00:01:30    NaN</span>
<span class="sd">        2000-01-01 00:02:00    2.0</span>
<span class="sd">        2000-01-01 00:02:30    NaN</span>
<span class="sd">        2000-01-01 00:03:00    3.0</span>

<span class="sd">        Upsample again, providing a ``fill value``.</span>

<span class="sd">        &gt;&gt;&gt; df.asfreq(freq=&#39;30S&#39;, fill_value=9.0)</span>
<span class="sd">                               s</span>
<span class="sd">        2000-01-01 00:00:00    0.0</span>
<span class="sd">        2000-01-01 00:00:30    9.0</span>
<span class="sd">        2000-01-01 00:01:00    NaN</span>
<span class="sd">        2000-01-01 00:01:30    9.0</span>
<span class="sd">        2000-01-01 00:02:00    2.0</span>
<span class="sd">        2000-01-01 00:02:30    9.0</span>
<span class="sd">        2000-01-01 00:03:00    3.0</span>

<span class="sd">        Upsample again, providing a ``method``.</span>

<span class="sd">        &gt;&gt;&gt; df.asfreq(freq=&#39;30S&#39;, method=&#39;bfill&#39;)</span>
<span class="sd">                               s</span>
<span class="sd">        2000-01-01 00:00:00    0.0</span>
<span class="sd">        2000-01-01 00:00:30    NaN</span>
<span class="sd">        2000-01-01 00:01:00    NaN</span>
<span class="sd">        2000-01-01 00:01:30    2.0</span>
<span class="sd">        2000-01-01 00:02:00    2.0</span>
<span class="sd">        2000-01-01 00:02:30    3.0</span>
<span class="sd">        2000-01-01 00:03:00    3.0</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">pandas.core.resample</span> <span class="k">import</span> <span class="n">asfreq</span>

        <span class="k">return</span> <span class="n">asfreq</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">freq</span><span class="p">,</span>
            <span class="n">method</span><span class="o">=</span><span class="n">method</span><span class="p">,</span>
            <span class="n">how</span><span class="o">=</span><span class="n">how</span><span class="p">,</span>
            <span class="n">normalize</span><span class="o">=</span><span class="n">normalize</span><span class="p">,</span>
            <span class="n">fill_value</span><span class="o">=</span><span class="n">fill_value</span><span class="p">,</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">at_time</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">time</span><span class="p">,</span> <span class="n">asof</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Select values at particular time of day (e.g. 9:30AM).</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        time : datetime.time or str</span>
<span class="sd">        axis : {0 or &#39;index&#39;, 1 or &#39;columns&#39;}, default 0</span>

<span class="sd">            .. versionadded:: 0.24.0</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Series or DataFrame</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        TypeError</span>
<span class="sd">            If the index is not  a :class:`DatetimeIndex`</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        between_time : Select values between particular times of the day.</span>
<span class="sd">        first : Select initial periods of time series based on a date offset.</span>
<span class="sd">        last : Select final periods of time series based on a date offset.</span>
<span class="sd">        DatetimeIndex.indexer_at_time : Get just the index locations for</span>
<span class="sd">            values at particular time of the day.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; i = pd.date_range(&#39;2018-04-09&#39;, periods=4, freq=&#39;12H&#39;)</span>
<span class="sd">        &gt;&gt;&gt; ts = pd.DataFrame({&#39;A&#39;: [1, 2, 3, 4]}, index=i)</span>
<span class="sd">        &gt;&gt;&gt; ts</span>
<span class="sd">                             A</span>
<span class="sd">        2018-04-09 00:00:00  1</span>
<span class="sd">        2018-04-09 12:00:00  2</span>
<span class="sd">        2018-04-10 00:00:00  3</span>
<span class="sd">        2018-04-10 12:00:00  4</span>

<span class="sd">        &gt;&gt;&gt; ts.at_time(&#39;12:00&#39;)</span>
<span class="sd">                             A</span>
<span class="sd">        2018-04-09 12:00:00  2</span>
<span class="sd">        2018-04-10 12:00:00  4</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">axis</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">axis</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_stat_axis_number</span>
        <span class="n">axis</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_axis_number</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span>

        <span class="n">index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_axis</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">indexer</span> <span class="o">=</span> <span class="n">index</span><span class="o">.</span><span class="n">indexer_at_time</span><span class="p">(</span><span class="n">time</span><span class="p">,</span> <span class="n">asof</span><span class="o">=</span><span class="n">asof</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Index must be DatetimeIndex&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">take</span><span class="p">(</span><span class="n">indexer</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">between_time</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">start_time</span><span class="p">,</span> <span class="n">end_time</span><span class="p">,</span> <span class="n">include_start</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">include_end</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="kc">None</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Select values between particular times of the day (e.g., 9:00-9:30 AM).</span>

<span class="sd">        By setting ``start_time`` to be later than ``end_time``,</span>
<span class="sd">        you can get the times that are *not* between the two times.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        start_time : datetime.time or str</span>
<span class="sd">        end_time : datetime.time or str</span>
<span class="sd">        include_start : bool, default True</span>
<span class="sd">        include_end : bool, default True</span>
<span class="sd">        axis : {0 or &#39;index&#39;, 1 or &#39;columns&#39;}, default 0</span>

<span class="sd">            .. versionadded:: 0.24.0</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Series or DataFrame</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        TypeError</span>
<span class="sd">            If the index is not  a :class:`DatetimeIndex`</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        at_time : Select values at a particular time of the day.</span>
<span class="sd">        first : Select initial periods of time series based on a date offset.</span>
<span class="sd">        last : Select final periods of time series based on a date offset.</span>
<span class="sd">        DatetimeIndex.indexer_between_time : Get just the index locations for</span>
<span class="sd">            values between particular times of the day.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; i = pd.date_range(&#39;2018-04-09&#39;, periods=4, freq=&#39;1D20min&#39;)</span>
<span class="sd">        &gt;&gt;&gt; ts = pd.DataFrame({&#39;A&#39;: [1, 2, 3, 4]}, index=i)</span>
<span class="sd">        &gt;&gt;&gt; ts</span>
<span class="sd">                             A</span>
<span class="sd">        2018-04-09 00:00:00  1</span>
<span class="sd">        2018-04-10 00:20:00  2</span>
<span class="sd">        2018-04-11 00:40:00  3</span>
<span class="sd">        2018-04-12 01:00:00  4</span>

<span class="sd">        &gt;&gt;&gt; ts.between_time(&#39;0:15&#39;, &#39;0:45&#39;)</span>
<span class="sd">                             A</span>
<span class="sd">        2018-04-10 00:20:00  2</span>
<span class="sd">        2018-04-11 00:40:00  3</span>

<span class="sd">        You get the times that are *not* between two times by setting</span>
<span class="sd">        ``start_time`` later than ``end_time``:</span>

<span class="sd">        &gt;&gt;&gt; ts.between_time(&#39;0:45&#39;, &#39;0:15&#39;)</span>
<span class="sd">                             A</span>
<span class="sd">        2018-04-09 00:00:00  1</span>
<span class="sd">        2018-04-12 01:00:00  4</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">axis</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">axis</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_stat_axis_number</span>
        <span class="n">axis</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_axis_number</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span>

        <span class="n">index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_axis</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">indexer</span> <span class="o">=</span> <span class="n">index</span><span class="o">.</span><span class="n">indexer_between_time</span><span class="p">(</span>
                <span class="n">start_time</span><span class="p">,</span>
                <span class="n">end_time</span><span class="p">,</span>
                <span class="n">include_start</span><span class="o">=</span><span class="n">include_start</span><span class="p">,</span>
                <span class="n">include_end</span><span class="o">=</span><span class="n">include_end</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Index must be DatetimeIndex&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">take</span><span class="p">(</span><span class="n">indexer</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">resample</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">rule</span><span class="p">,</span>
        <span class="n">how</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
        <span class="n">fill_method</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">closed</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">label</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">convention</span><span class="o">=</span><span class="s2">&quot;start&quot;</span><span class="p">,</span>
        <span class="n">kind</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">loffset</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">limit</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">base</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
        <span class="n">on</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">level</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Resample time-series data.</span>

<span class="sd">        Convenience method for frequency conversion and resampling of time</span>
<span class="sd">        series. Object must have a datetime-like index (`DatetimeIndex`,</span>
<span class="sd">        `PeriodIndex`, or `TimedeltaIndex`), or pass datetime-like values</span>
<span class="sd">        to the `on` or `level` keyword.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        rule : DateOffset, Timedelta or str</span>
<span class="sd">            The offset string or object representing target conversion.</span>
<span class="sd">        how : str</span>
<span class="sd">            Method for down/re-sampling, default to &#39;mean&#39; for downsampling.</span>

<span class="sd">            .. deprecated:: 0.18.0</span>
<span class="sd">               The new syntax is ``.resample(...).mean()``, or</span>
<span class="sd">               ``.resample(...).apply(&lt;func&gt;)``</span>
<span class="sd">        axis : {0 or &#39;index&#39;, 1 or &#39;columns&#39;}, default 0</span>
<span class="sd">            Which axis to use for up- or down-sampling. For `Series` this</span>
<span class="sd">            will default to 0, i.e. along the rows. Must be</span>
<span class="sd">            `DatetimeIndex`, `TimedeltaIndex` or `PeriodIndex`.</span>
<span class="sd">        fill_method : str, default None</span>
<span class="sd">            Filling method for upsampling.</span>

<span class="sd">            .. deprecated:: 0.18.0</span>
<span class="sd">               The new syntax is ``.resample(...).&lt;func&gt;()``,</span>
<span class="sd">               e.g. ``.resample(...).pad()``</span>
<span class="sd">        closed : {&#39;right&#39;, &#39;left&#39;}, default None</span>
<span class="sd">            Which side of bin interval is closed. The default is &#39;left&#39;</span>
<span class="sd">            for all frequency offsets except for &#39;M&#39;, &#39;A&#39;, &#39;Q&#39;, &#39;BM&#39;,</span>
<span class="sd">            &#39;BA&#39;, &#39;BQ&#39;, and &#39;W&#39; which all have a default of &#39;right&#39;.</span>
<span class="sd">        label : {&#39;right&#39;, &#39;left&#39;}, default None</span>
<span class="sd">            Which bin edge label to label bucket with. The default is &#39;left&#39;</span>
<span class="sd">            for all frequency offsets except for &#39;M&#39;, &#39;A&#39;, &#39;Q&#39;, &#39;BM&#39;,</span>
<span class="sd">            &#39;BA&#39;, &#39;BQ&#39;, and &#39;W&#39; which all have a default of &#39;right&#39;.</span>
<span class="sd">        convention : {&#39;start&#39;, &#39;end&#39;, &#39;s&#39;, &#39;e&#39;}, default &#39;start&#39;</span>
<span class="sd">            For `PeriodIndex` only, controls whether to use the start or</span>
<span class="sd">            end of `rule`.</span>
<span class="sd">        kind : {&#39;timestamp&#39;, &#39;period&#39;}, optional, default None</span>
<span class="sd">            Pass &#39;timestamp&#39; to convert the resulting index to a</span>
<span class="sd">            `DateTimeIndex` or &#39;period&#39; to convert it to a `PeriodIndex`.</span>
<span class="sd">            By default the input representation is retained.</span>
<span class="sd">        loffset : timedelta, default None</span>
<span class="sd">            Adjust the resampled time labels.</span>
<span class="sd">        limit : int, default None</span>
<span class="sd">            Maximum size gap when reindexing with `fill_method`.</span>

<span class="sd">            .. deprecated:: 0.18.0</span>
<span class="sd">        base : int, default 0</span>
<span class="sd">            For frequencies that evenly subdivide 1 day, the &quot;origin&quot; of the</span>
<span class="sd">            aggregated intervals. For example, for &#39;5min&#39; frequency, base could</span>
<span class="sd">            range from 0 through 4. Defaults to 0.</span>
<span class="sd">        on : str, optional</span>
<span class="sd">            For a DataFrame, column to use instead of index for resampling.</span>
<span class="sd">            Column must be datetime-like.</span>

<span class="sd">            .. versionadded:: 0.19.0</span>

<span class="sd">        level : str or int, optional</span>
<span class="sd">            For a MultiIndex, level (name or number) to use for</span>
<span class="sd">            resampling. `level` must be datetime-like.</span>

<span class="sd">            .. versionadded:: 0.19.0</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Resampler object</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        groupby : Group by mapping, function, label, or list of labels.</span>
<span class="sd">        Series.resample : Resample a Series.</span>
<span class="sd">        DataFrame.resample: Resample a DataFrame.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        See the `user guide</span>
<span class="sd">        &lt;https://pandas.pydata.org/pandas-docs/stable/user_guide/timeseries.html#resampling&gt;`_</span>
<span class="sd">        for more.</span>

<span class="sd">        To learn more about the offset strings, please see `this link</span>
<span class="sd">        &lt;http://pandas.pydata.org/pandas-docs/stable/user_guide/timeseries.html#dateoffset-objects&gt;`__.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>

<span class="sd">        Start by creating a series with 9 one minute timestamps.</span>

<span class="sd">        &gt;&gt;&gt; index = pd.date_range(&#39;1/1/2000&#39;, periods=9, freq=&#39;T&#39;)</span>
<span class="sd">        &gt;&gt;&gt; series = pd.Series(range(9), index=index)</span>
<span class="sd">        &gt;&gt;&gt; series</span>
<span class="sd">        2000-01-01 00:00:00    0</span>
<span class="sd">        2000-01-01 00:01:00    1</span>
<span class="sd">        2000-01-01 00:02:00    2</span>
<span class="sd">        2000-01-01 00:03:00    3</span>
<span class="sd">        2000-01-01 00:04:00    4</span>
<span class="sd">        2000-01-01 00:05:00    5</span>
<span class="sd">        2000-01-01 00:06:00    6</span>
<span class="sd">        2000-01-01 00:07:00    7</span>
<span class="sd">        2000-01-01 00:08:00    8</span>
<span class="sd">        Freq: T, dtype: int64</span>

<span class="sd">        Downsample the series into 3 minute bins and sum the values</span>
<span class="sd">        of the timestamps falling into a bin.</span>

<span class="sd">        &gt;&gt;&gt; series.resample(&#39;3T&#39;).sum()</span>
<span class="sd">        2000-01-01 00:00:00     3</span>
<span class="sd">        2000-01-01 00:03:00    12</span>
<span class="sd">        2000-01-01 00:06:00    21</span>
<span class="sd">        Freq: 3T, dtype: int64</span>

<span class="sd">        Downsample the series into 3 minute bins as above, but label each</span>
<span class="sd">        bin using the right edge instead of the left. Please note that the</span>
<span class="sd">        value in the bucket used as the label is not included in the bucket,</span>
<span class="sd">        which it labels. For example, in the original series the</span>
<span class="sd">        bucket ``2000-01-01 00:03:00`` contains the value 3, but the summed</span>
<span class="sd">        value in the resampled bucket with the label ``2000-01-01 00:03:00``</span>
<span class="sd">        does not include 3 (if it did, the summed value would be 6, not 3).</span>
<span class="sd">        To include this value close the right side of the bin interval as</span>
<span class="sd">        illustrated in the example below this one.</span>

<span class="sd">        &gt;&gt;&gt; series.resample(&#39;3T&#39;, label=&#39;right&#39;).sum()</span>
<span class="sd">        2000-01-01 00:03:00     3</span>
<span class="sd">        2000-01-01 00:06:00    12</span>
<span class="sd">        2000-01-01 00:09:00    21</span>
<span class="sd">        Freq: 3T, dtype: int64</span>

<span class="sd">        Downsample the series into 3 minute bins as above, but close the right</span>
<span class="sd">        side of the bin interval.</span>

<span class="sd">        &gt;&gt;&gt; series.resample(&#39;3T&#39;, label=&#39;right&#39;, closed=&#39;right&#39;).sum()</span>
<span class="sd">        2000-01-01 00:00:00     0</span>
<span class="sd">        2000-01-01 00:03:00     6</span>
<span class="sd">        2000-01-01 00:06:00    15</span>
<span class="sd">        2000-01-01 00:09:00    15</span>
<span class="sd">        Freq: 3T, dtype: int64</span>

<span class="sd">        Upsample the series into 30 second bins.</span>

<span class="sd">        &gt;&gt;&gt; series.resample(&#39;30S&#39;).asfreq()[0:5]   # Select first 5 rows</span>
<span class="sd">        2000-01-01 00:00:00   0.0</span>
<span class="sd">        2000-01-01 00:00:30   NaN</span>
<span class="sd">        2000-01-01 00:01:00   1.0</span>
<span class="sd">        2000-01-01 00:01:30   NaN</span>
<span class="sd">        2000-01-01 00:02:00   2.0</span>
<span class="sd">        Freq: 30S, dtype: float64</span>

<span class="sd">        Upsample the series into 30 second bins and fill the ``NaN``</span>
<span class="sd">        values using the ``pad`` method.</span>

<span class="sd">        &gt;&gt;&gt; series.resample(&#39;30S&#39;).pad()[0:5]</span>
<span class="sd">        2000-01-01 00:00:00    0</span>
<span class="sd">        2000-01-01 00:00:30    0</span>
<span class="sd">        2000-01-01 00:01:00    1</span>
<span class="sd">        2000-01-01 00:01:30    1</span>
<span class="sd">        2000-01-01 00:02:00    2</span>
<span class="sd">        Freq: 30S, dtype: int64</span>

<span class="sd">        Upsample the series into 30 second bins and fill the</span>
<span class="sd">        ``NaN`` values using the ``bfill`` method.</span>

<span class="sd">        &gt;&gt;&gt; series.resample(&#39;30S&#39;).bfill()[0:5]</span>
<span class="sd">        2000-01-01 00:00:00    0</span>
<span class="sd">        2000-01-01 00:00:30    1</span>
<span class="sd">        2000-01-01 00:01:00    1</span>
<span class="sd">        2000-01-01 00:01:30    2</span>
<span class="sd">        2000-01-01 00:02:00    2</span>
<span class="sd">        Freq: 30S, dtype: int64</span>

<span class="sd">        Pass a custom function via ``apply``</span>

<span class="sd">        &gt;&gt;&gt; def custom_resampler(array_like):</span>
<span class="sd">        ...     return np.sum(array_like) + 5</span>
<span class="sd">        ...</span>
<span class="sd">        &gt;&gt;&gt; series.resample(&#39;3T&#39;).apply(custom_resampler)</span>
<span class="sd">        2000-01-01 00:00:00     8</span>
<span class="sd">        2000-01-01 00:03:00    17</span>
<span class="sd">        2000-01-01 00:06:00    26</span>
<span class="sd">        Freq: 3T, dtype: int64</span>

<span class="sd">        For a Series with a PeriodIndex, the keyword `convention` can be</span>
<span class="sd">        used to control whether to use the start or end of `rule`.</span>

<span class="sd">        Resample a year by quarter using &#39;start&#39; `convention`. Values are</span>
<span class="sd">        assigned to the first quarter of the period.</span>

<span class="sd">        &gt;&gt;&gt; s = pd.Series([1, 2], index=pd.period_range(&#39;2012-01-01&#39;,</span>
<span class="sd">        ...                                             freq=&#39;A&#39;,</span>
<span class="sd">        ...                                             periods=2))</span>
<span class="sd">        &gt;&gt;&gt; s</span>
<span class="sd">        2012    1</span>
<span class="sd">        2013    2</span>
<span class="sd">        Freq: A-DEC, dtype: int64</span>
<span class="sd">        &gt;&gt;&gt; s.resample(&#39;Q&#39;, convention=&#39;start&#39;).asfreq()</span>
<span class="sd">        2012Q1    1.0</span>
<span class="sd">        2012Q2    NaN</span>
<span class="sd">        2012Q3    NaN</span>
<span class="sd">        2012Q4    NaN</span>
<span class="sd">        2013Q1    2.0</span>
<span class="sd">        2013Q2    NaN</span>
<span class="sd">        2013Q3    NaN</span>
<span class="sd">        2013Q4    NaN</span>
<span class="sd">        Freq: Q-DEC, dtype: float64</span>

<span class="sd">        Resample quarters by month using &#39;end&#39; `convention`. Values are</span>
<span class="sd">        assigned to the last month of the period.</span>

<span class="sd">        &gt;&gt;&gt; q = pd.Series([1, 2, 3, 4], index=pd.period_range(&#39;2018-01-01&#39;,</span>
<span class="sd">        ...                                                   freq=&#39;Q&#39;,</span>
<span class="sd">        ...                                                   periods=4))</span>
<span class="sd">        &gt;&gt;&gt; q</span>
<span class="sd">        2018Q1    1</span>
<span class="sd">        2018Q2    2</span>
<span class="sd">        2018Q3    3</span>
<span class="sd">        2018Q4    4</span>
<span class="sd">        Freq: Q-DEC, dtype: int64</span>
<span class="sd">        &gt;&gt;&gt; q.resample(&#39;M&#39;, convention=&#39;end&#39;).asfreq()</span>
<span class="sd">        2018-03    1.0</span>
<span class="sd">        2018-04    NaN</span>
<span class="sd">        2018-05    NaN</span>
<span class="sd">        2018-06    2.0</span>
<span class="sd">        2018-07    NaN</span>
<span class="sd">        2018-08    NaN</span>
<span class="sd">        2018-09    3.0</span>
<span class="sd">        2018-10    NaN</span>
<span class="sd">        2018-11    NaN</span>
<span class="sd">        2018-12    4.0</span>
<span class="sd">        Freq: M, dtype: float64</span>

<span class="sd">        For DataFrame objects, the keyword `on` can be used to specify the</span>
<span class="sd">        column instead of the index for resampling.</span>

<span class="sd">        &gt;&gt;&gt; d = dict({&#39;price&#39;: [10, 11, 9, 13, 14, 18, 17, 19],</span>
<span class="sd">        ...           &#39;volume&#39;: [50, 60, 40, 100, 50, 100, 40, 50]})</span>
<span class="sd">        &gt;&gt;&gt; df = pd.DataFrame(d)</span>
<span class="sd">        &gt;&gt;&gt; df[&#39;week_starting&#39;] = pd.date_range(&#39;01/01/2018&#39;,</span>
<span class="sd">        ...                                     periods=8,</span>
<span class="sd">        ...                                     freq=&#39;W&#39;)</span>
<span class="sd">        &gt;&gt;&gt; df</span>
<span class="sd">           price  volume week_starting</span>
<span class="sd">        0     10      50    2018-01-07</span>
<span class="sd">        1     11      60    2018-01-14</span>
<span class="sd">        2      9      40    2018-01-21</span>
<span class="sd">        3     13     100    2018-01-28</span>
<span class="sd">        4     14      50    2018-02-04</span>
<span class="sd">        5     18     100    2018-02-11</span>
<span class="sd">        6     17      40    2018-02-18</span>
<span class="sd">        7     19      50    2018-02-25</span>
<span class="sd">        &gt;&gt;&gt; df.resample(&#39;M&#39;, on=&#39;week_starting&#39;).mean()</span>
<span class="sd">                       price  volume</span>
<span class="sd">        week_starting</span>
<span class="sd">        2018-01-31     10.75    62.5</span>
<span class="sd">        2018-02-28     17.00    60.0</span>

<span class="sd">        For a DataFrame with MultiIndex, the keyword `level` can be used to</span>
<span class="sd">        specify on which level the resampling needs to take place.</span>

<span class="sd">        &gt;&gt;&gt; days = pd.date_range(&#39;1/1/2000&#39;, periods=4, freq=&#39;D&#39;)</span>
<span class="sd">        &gt;&gt;&gt; d2 = dict({&#39;price&#39;: [10, 11, 9, 13, 14, 18, 17, 19],</span>
<span class="sd">        ...            &#39;volume&#39;: [50, 60, 40, 100, 50, 100, 40, 50]})</span>
<span class="sd">        &gt;&gt;&gt; df2 = pd.DataFrame(d2,</span>
<span class="sd">        ...                    index=pd.MultiIndex.from_product([days,</span>
<span class="sd">        ...                                                     [&#39;morning&#39;,</span>
<span class="sd">        ...                                                      &#39;afternoon&#39;]]</span>
<span class="sd">        ...                                                     ))</span>
<span class="sd">        &gt;&gt;&gt; df2</span>
<span class="sd">                              price  volume</span>
<span class="sd">        2000-01-01 morning       10      50</span>
<span class="sd">                   afternoon     11      60</span>
<span class="sd">        2000-01-02 morning        9      40</span>
<span class="sd">                   afternoon     13     100</span>
<span class="sd">        2000-01-03 morning       14      50</span>
<span class="sd">                   afternoon     18     100</span>
<span class="sd">        2000-01-04 morning       17      40</span>
<span class="sd">                   afternoon     19      50</span>
<span class="sd">        &gt;&gt;&gt; df2.resample(&#39;D&#39;, level=0).sum()</span>
<span class="sd">                    price  volume</span>
<span class="sd">        2000-01-01     21     110</span>
<span class="sd">        2000-01-02     22     140</span>
<span class="sd">        2000-01-03     32     150</span>
<span class="sd">        2000-01-04     36      90</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="kn">from</span> <span class="nn">pandas.core.resample</span> <span class="k">import</span> <span class="n">resample</span><span class="p">,</span> <span class="n">_maybe_process_deprecations</span>

        <span class="n">axis</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_axis_number</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span>
        <span class="n">r</span> <span class="o">=</span> <span class="n">resample</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">freq</span><span class="o">=</span><span class="n">rule</span><span class="p">,</span>
            <span class="n">label</span><span class="o">=</span><span class="n">label</span><span class="p">,</span>
            <span class="n">closed</span><span class="o">=</span><span class="n">closed</span><span class="p">,</span>
            <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span>
            <span class="n">kind</span><span class="o">=</span><span class="n">kind</span><span class="p">,</span>
            <span class="n">loffset</span><span class="o">=</span><span class="n">loffset</span><span class="p">,</span>
            <span class="n">convention</span><span class="o">=</span><span class="n">convention</span><span class="p">,</span>
            <span class="n">base</span><span class="o">=</span><span class="n">base</span><span class="p">,</span>
            <span class="n">key</span><span class="o">=</span><span class="n">on</span><span class="p">,</span>
            <span class="n">level</span><span class="o">=</span><span class="n">level</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">_maybe_process_deprecations</span><span class="p">(</span>
            <span class="n">r</span><span class="p">,</span> <span class="n">how</span><span class="o">=</span><span class="n">how</span><span class="p">,</span> <span class="n">fill_method</span><span class="o">=</span><span class="n">fill_method</span><span class="p">,</span> <span class="n">limit</span><span class="o">=</span><span class="n">limit</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">first</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">offset</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Convenience method for subsetting initial periods of time series data</span>
<span class="sd">        based on a date offset.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        offset : string, DateOffset, dateutil.relativedelta</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        subset : same type as caller</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        TypeError</span>
<span class="sd">            If the index is not  a :class:`DatetimeIndex`</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        last : Select final periods of time series based on a date offset.</span>
<span class="sd">        at_time : Select values at a particular time of the day.</span>
<span class="sd">        between_time : Select values between particular times of the day.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; i = pd.date_range(&#39;2018-04-09&#39;, periods=4, freq=&#39;2D&#39;)</span>
<span class="sd">        &gt;&gt;&gt; ts = pd.DataFrame({&#39;A&#39;: [1,2,3,4]}, index=i)</span>
<span class="sd">        &gt;&gt;&gt; ts</span>
<span class="sd">                    A</span>
<span class="sd">        2018-04-09  1</span>
<span class="sd">        2018-04-11  2</span>
<span class="sd">        2018-04-13  3</span>
<span class="sd">        2018-04-15  4</span>

<span class="sd">        Get the rows for the first 3 days:</span>

<span class="sd">        &gt;&gt;&gt; ts.first(&#39;3D&#39;)</span>
<span class="sd">                    A</span>
<span class="sd">        2018-04-09  1</span>
<span class="sd">        2018-04-11  2</span>

<span class="sd">        Notice the data for 3 first calender days were returned, not the first</span>
<span class="sd">        3 days observed in the dataset, and therefore data for 2018-04-13 was</span>
<span class="sd">        not returned.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="n">DatetimeIndex</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;&#39;first&#39; only supports a DatetimeIndex index&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span>

        <span class="n">offset</span> <span class="o">=</span> <span class="n">to_offset</span><span class="p">(</span><span class="n">offset</span><span class="p">)</span>
        <span class="n">end_date</span> <span class="o">=</span> <span class="n">end</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">offset</span>

        <span class="c1"># Tick-like, e.g. 3 weeks</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">offset</span><span class="o">.</span><span class="n">isAnchored</span><span class="p">()</span> <span class="ow">and</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">offset</span><span class="p">,</span> <span class="s2">&quot;_inc&quot;</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">end_date</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="p">:</span>
                <span class="n">end</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">searchsorted</span><span class="p">(</span><span class="n">end_date</span><span class="p">,</span> <span class="n">side</span><span class="o">=</span><span class="s2">&quot;left&quot;</span><span class="p">)</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">iloc</span><span class="p">[:</span><span class="n">end</span><span class="p">]</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">loc</span><span class="p">[:</span><span class="n">end</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">last</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">offset</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Convenience method for subsetting final periods of time series data</span>
<span class="sd">        based on a date offset.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        offset : string, DateOffset, dateutil.relativedelta</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        subset : same type as caller</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        TypeError</span>
<span class="sd">            If the index is not  a :class:`DatetimeIndex`</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        first : Select initial periods of time series based on a date offset.</span>
<span class="sd">        at_time : Select values at a particular time of the day.</span>
<span class="sd">        between_time : Select values between particular times of the day.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; i = pd.date_range(&#39;2018-04-09&#39;, periods=4, freq=&#39;2D&#39;)</span>
<span class="sd">        &gt;&gt;&gt; ts = pd.DataFrame({&#39;A&#39;: [1,2,3,4]}, index=i)</span>
<span class="sd">        &gt;&gt;&gt; ts</span>
<span class="sd">                    A</span>
<span class="sd">        2018-04-09  1</span>
<span class="sd">        2018-04-11  2</span>
<span class="sd">        2018-04-13  3</span>
<span class="sd">        2018-04-15  4</span>

<span class="sd">        Get the rows for the last 3 days:</span>

<span class="sd">        &gt;&gt;&gt; ts.last(&#39;3D&#39;)</span>
<span class="sd">                    A</span>
<span class="sd">        2018-04-13  3</span>
<span class="sd">        2018-04-15  4</span>

<span class="sd">        Notice the data for 3 last calender days were returned, not the last</span>
<span class="sd">        3 observed days in the dataset, and therefore data for 2018-04-11 was</span>
<span class="sd">        not returned.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="n">DatetimeIndex</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;&#39;last&#39; only supports a DatetimeIndex index&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span>

        <span class="n">offset</span> <span class="o">=</span> <span class="n">to_offset</span><span class="p">(</span><span class="n">offset</span><span class="p">)</span>

        <span class="n">start_date</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">offset</span>
        <span class="n">start</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">searchsorted</span><span class="p">(</span><span class="n">start_date</span><span class="p">,</span> <span class="n">side</span><span class="o">=</span><span class="s2">&quot;right&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">start</span><span class="p">:]</span>

    <span class="k">def</span> <span class="nf">rank</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
        <span class="n">method</span><span class="o">=</span><span class="s2">&quot;average&quot;</span><span class="p">,</span>
        <span class="n">numeric_only</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">na_option</span><span class="o">=</span><span class="s2">&quot;keep&quot;</span><span class="p">,</span>
        <span class="n">ascending</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">pct</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute numerical data ranks (1 through n) along axis.</span>

<span class="sd">        By default, equal values are assigned a rank that is the average of the</span>
<span class="sd">        ranks of those values.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        axis : {0 or &#39;index&#39;, 1 or &#39;columns&#39;}, default 0</span>
<span class="sd">            Index to direct ranking.</span>
<span class="sd">        method : {&#39;average&#39;, &#39;min&#39;, &#39;max&#39;, &#39;first&#39;, &#39;dense&#39;}, default &#39;average&#39;</span>
<span class="sd">            How to rank the group of records that have the same value</span>
<span class="sd">            (i.e. ties):</span>

<span class="sd">            * average: average rank of the group</span>
<span class="sd">            * min: lowest rank in the group</span>
<span class="sd">            * max: highest rank in the group</span>
<span class="sd">            * first: ranks assigned in order they appear in the array</span>
<span class="sd">            * dense: like &#39;min&#39;, but rank always increases by 1 between groups</span>
<span class="sd">        numeric_only : bool, optional</span>
<span class="sd">            For DataFrame objects, rank only numeric columns if set to True.</span>
<span class="sd">        na_option : {&#39;keep&#39;, &#39;top&#39;, &#39;bottom&#39;}, default &#39;keep&#39;</span>
<span class="sd">            How to rank NaN values:</span>

<span class="sd">            * keep: assign NaN rank to NaN values</span>
<span class="sd">            * top: assign smallest rank to NaN values if ascending</span>
<span class="sd">            * bottom: assign highest rank to NaN values if ascending</span>
<span class="sd">        ascending : bool, default True</span>
<span class="sd">            Whether or not the elements should be ranked in ascending order.</span>
<span class="sd">        pct : bool, default False</span>
<span class="sd">            Whether or not to display the returned rankings in percentile</span>
<span class="sd">            form.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        same type as caller</span>
<span class="sd">            Return a Series or DataFrame with data ranks as values.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        core.groupby.GroupBy.rank : Rank of values within each group.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>

<span class="sd">        &gt;&gt;&gt; df = pd.DataFrame(data={&#39;Animal&#39;: [&#39;cat&#39;, &#39;penguin&#39;, &#39;dog&#39;,</span>
<span class="sd">        ...                                    &#39;spider&#39;, &#39;snake&#39;],</span>
<span class="sd">        ...                         &#39;Number_legs&#39;: [4, 2, 4, 8, np.nan]})</span>
<span class="sd">        &gt;&gt;&gt; df</span>
<span class="sd">            Animal  Number_legs</span>
<span class="sd">        0      cat          4.0</span>
<span class="sd">        1  penguin          2.0</span>
<span class="sd">        2      dog          4.0</span>
<span class="sd">        3   spider          8.0</span>
<span class="sd">        4    snake          NaN</span>

<span class="sd">        The following example shows how the method behaves with the above</span>
<span class="sd">        parameters:</span>

<span class="sd">        * default_rank: this is the default behaviour obtained without using</span>
<span class="sd">          any parameter.</span>
<span class="sd">        * max_rank: setting ``method = &#39;max&#39;`` the records that have the</span>
<span class="sd">          same values are ranked using the highest rank (e.g.: since &#39;cat&#39;</span>
<span class="sd">          and &#39;dog&#39; are both in the 2nd and 3rd position, rank 3 is assigned.)</span>
<span class="sd">        * NA_bottom: choosing ``na_option = &#39;bottom&#39;``, if there are records</span>
<span class="sd">          with NaN values they are placed at the bottom of the ranking.</span>
<span class="sd">        * pct_rank: when setting ``pct = True``, the ranking is expressed as</span>
<span class="sd">          percentile rank.</span>

<span class="sd">        &gt;&gt;&gt; df[&#39;default_rank&#39;] = df[&#39;Number_legs&#39;].rank()</span>
<span class="sd">        &gt;&gt;&gt; df[&#39;max_rank&#39;] = df[&#39;Number_legs&#39;].rank(method=&#39;max&#39;)</span>
<span class="sd">        &gt;&gt;&gt; df[&#39;NA_bottom&#39;] = df[&#39;Number_legs&#39;].rank(na_option=&#39;bottom&#39;)</span>
<span class="sd">        &gt;&gt;&gt; df[&#39;pct_rank&#39;] = df[&#39;Number_legs&#39;].rank(pct=True)</span>
<span class="sd">        &gt;&gt;&gt; df</span>
<span class="sd">            Animal  Number_legs  default_rank  max_rank  NA_bottom  pct_rank</span>
<span class="sd">        0      cat          4.0           2.5       3.0        2.5     0.625</span>
<span class="sd">        1  penguin          2.0           1.0       1.0        1.0     0.250</span>
<span class="sd">        2      dog          4.0           2.5       3.0        2.5     0.625</span>
<span class="sd">        3   spider          8.0           4.0       4.0        4.0     1.000</span>
<span class="sd">        4    snake          NaN           NaN       NaN        5.0       NaN</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">axis</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_axis_number</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">na_option</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">{</span><span class="s2">&quot;keep&quot;</span><span class="p">,</span> <span class="s2">&quot;top&quot;</span><span class="p">,</span> <span class="s2">&quot;bottom&quot;</span><span class="p">}:</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;na_option must be one of &#39;keep&#39;, &#39;top&#39;, or &#39;bottom&#39;&quot;</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>

        <span class="k">def</span> <span class="nf">ranker</span><span class="p">(</span><span class="n">data</span><span class="p">):</span>
            <span class="n">ranks</span> <span class="o">=</span> <span class="n">algos</span><span class="o">.</span><span class="n">rank</span><span class="p">(</span>
                <span class="n">data</span><span class="o">.</span><span class="n">values</span><span class="p">,</span>
                <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span>
                <span class="n">method</span><span class="o">=</span><span class="n">method</span><span class="p">,</span>
                <span class="n">ascending</span><span class="o">=</span><span class="n">ascending</span><span class="p">,</span>
                <span class="n">na_option</span><span class="o">=</span><span class="n">na_option</span><span class="p">,</span>
                <span class="n">pct</span><span class="o">=</span><span class="n">pct</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="n">ranks</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_constructor</span><span class="p">(</span><span class="n">ranks</span><span class="p">,</span> <span class="o">**</span><span class="n">data</span><span class="o">.</span><span class="n">_construct_axes_dict</span><span class="p">())</span>
            <span class="k">return</span> <span class="n">ranks</span><span class="o">.</span><span class="n">__finalize__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

        <span class="c1"># if numeric_only is None, and we can&#39;t get anything, we try with</span>
        <span class="c1"># numeric_only=True</span>
        <span class="k">if</span> <span class="n">numeric_only</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">ranker</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
                <span class="n">numeric_only</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="k">if</span> <span class="n">numeric_only</span><span class="p">:</span>
            <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_numeric_data</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span>

        <span class="k">return</span> <span class="n">ranker</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>

    <span class="n">_shared_docs</span><span class="p">[</span>
        <span class="s2">&quot;align&quot;</span>
    <span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;</span>
<span class="s2">        Align two objects on their axes with the</span>
<span class="s2">        specified join method for each axis Index.</span>

<span class="s2">        Parameters</span>
<span class="s2">        ----------</span>
<span class="s2">        other : DataFrame or Series</span>
<span class="s2">        join : {&#39;outer&#39;, &#39;inner&#39;, &#39;left&#39;, &#39;right&#39;}, default &#39;outer&#39;</span>
<span class="s2">        axis : allowed axis of the other object, default None</span>
<span class="s2">            Align on index (0), columns (1), or both (None)</span>
<span class="s2">        level : int or level name, default None</span>
<span class="s2">            Broadcast across a level, matching Index values on the</span>
<span class="s2">            passed MultiIndex level</span>
<span class="s2">        copy : boolean, default True</span>
<span class="s2">            Always returns new objects. If copy=False and no reindexing is</span>
<span class="s2">            required then original objects are returned.</span>
<span class="s2">        fill_value : scalar, default np.NaN</span>
<span class="s2">            Value to use for missing values. Defaults to NaN, but can be any</span>
<span class="s2">            &quot;compatible&quot; value</span>
<span class="s2">        method : {&#39;backfill&#39;, &#39;bfill&#39;, &#39;pad&#39;, &#39;ffill&#39;, None}, default None</span>
<span class="s2">            Method to use for filling holes in reindexed Series</span>
<span class="s2">            pad / ffill: propagate last valid observation forward to next valid</span>
<span class="s2">            backfill / bfill: use NEXT valid observation to fill gap</span>
<span class="s2">        limit : int, default None</span>
<span class="s2">            If method is specified, this is the maximum number of consecutive</span>
<span class="s2">            NaN values to forward/backward fill. In other words, if there is</span>
<span class="s2">            a gap with more than this number of consecutive NaNs, it will only</span>
<span class="s2">            be partially filled. If method is not specified, this is the</span>
<span class="s2">            maximum number of entries along the entire axis where NaNs will be</span>
<span class="s2">            filled. Must be greater than 0 if not None.</span>
<span class="s2">        fill_axis : </span><span class="si">%(axes_single_arg)s</span><span class="s2">, default 0</span>
<span class="s2">            Filling axis, method and limit</span>
<span class="s2">        broadcast_axis : </span><span class="si">%(axes_single_arg)s</span><span class="s2">, default None</span>
<span class="s2">            Broadcast values along this axis, if aligning two objects of</span>
<span class="s2">            different dimensions</span>

<span class="s2">        Returns</span>
<span class="s2">        -------</span>
<span class="s2">        (left, right) : (</span><span class="si">%(klass)s</span><span class="s2">, type of other)</span>
<span class="s2">            Aligned objects.</span>
<span class="s2">        &quot;&quot;&quot;</span>

    <span class="nd">@Appender</span><span class="p">(</span><span class="n">_shared_docs</span><span class="p">[</span><span class="s2">&quot;align&quot;</span><span class="p">]</span> <span class="o">%</span> <span class="n">_shared_doc_kwargs</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">align</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">other</span><span class="p">,</span>
        <span class="n">join</span><span class="o">=</span><span class="s2">&quot;outer&quot;</span><span class="p">,</span>
        <span class="n">axis</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">level</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">copy</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">fill_value</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">method</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">limit</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">fill_axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
        <span class="n">broadcast_axis</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="kn">from</span> <span class="nn">pandas</span> <span class="k">import</span> <span class="n">DataFrame</span><span class="p">,</span> <span class="n">Series</span>

        <span class="n">method</span> <span class="o">=</span> <span class="n">missing</span><span class="o">.</span><span class="n">clean_fill_method</span><span class="p">(</span><span class="n">method</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">broadcast_axis</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="n">other</span><span class="o">.</span><span class="n">ndim</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">Series</span><span class="p">):</span>
                <span class="c1"># this means other is a DataFrame, and we need to broadcast</span>
                <span class="c1"># self</span>
                <span class="n">cons</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_constructor_expanddim</span>
                <span class="n">df</span> <span class="o">=</span> <span class="n">cons</span><span class="p">(</span>
                    <span class="p">{</span><span class="n">c</span><span class="p">:</span> <span class="bp">self</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">other</span><span class="o">.</span><span class="n">columns</span><span class="p">},</span> <span class="o">**</span><span class="n">other</span><span class="o">.</span><span class="n">_construct_axes_dict</span><span class="p">()</span>
                <span class="p">)</span>
                <span class="k">return</span> <span class="n">df</span><span class="o">.</span><span class="n">_align_frame</span><span class="p">(</span>
                    <span class="n">other</span><span class="p">,</span>
                    <span class="n">join</span><span class="o">=</span><span class="n">join</span><span class="p">,</span>
                    <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span>
                    <span class="n">level</span><span class="o">=</span><span class="n">level</span><span class="p">,</span>
                    <span class="n">copy</span><span class="o">=</span><span class="n">copy</span><span class="p">,</span>
                    <span class="n">fill_value</span><span class="o">=</span><span class="n">fill_value</span><span class="p">,</span>
                    <span class="n">method</span><span class="o">=</span><span class="n">method</span><span class="p">,</span>
                    <span class="n">limit</span><span class="o">=</span><span class="n">limit</span><span class="p">,</span>
                    <span class="n">fill_axis</span><span class="o">=</span><span class="n">fill_axis</span><span class="p">,</span>
                <span class="p">)</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">Series</span><span class="p">):</span>
                <span class="c1"># this means self is a DataFrame, and we need to broadcast</span>
                <span class="c1"># other</span>
                <span class="n">cons</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">_constructor_expanddim</span>
                <span class="n">df</span> <span class="o">=</span> <span class="n">cons</span><span class="p">(</span>
                    <span class="p">{</span><span class="n">c</span><span class="p">:</span> <span class="n">other</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">columns</span><span class="p">},</span> <span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">_construct_axes_dict</span><span class="p">()</span>
                <span class="p">)</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_align_frame</span><span class="p">(</span>
                    <span class="n">df</span><span class="p">,</span>
                    <span class="n">join</span><span class="o">=</span><span class="n">join</span><span class="p">,</span>
                    <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span>
                    <span class="n">level</span><span class="o">=</span><span class="n">level</span><span class="p">,</span>
                    <span class="n">copy</span><span class="o">=</span><span class="n">copy</span><span class="p">,</span>
                    <span class="n">fill_value</span><span class="o">=</span><span class="n">fill_value</span><span class="p">,</span>
                    <span class="n">method</span><span class="o">=</span><span class="n">method</span><span class="p">,</span>
                    <span class="n">limit</span><span class="o">=</span><span class="n">limit</span><span class="p">,</span>
                    <span class="n">fill_axis</span><span class="o">=</span><span class="n">fill_axis</span><span class="p">,</span>
                <span class="p">)</span>

        <span class="k">if</span> <span class="n">axis</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">axis</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_axis_number</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">DataFrame</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_align_frame</span><span class="p">(</span>
                <span class="n">other</span><span class="p">,</span>
                <span class="n">join</span><span class="o">=</span><span class="n">join</span><span class="p">,</span>
                <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span>
                <span class="n">level</span><span class="o">=</span><span class="n">level</span><span class="p">,</span>
                <span class="n">copy</span><span class="o">=</span><span class="n">copy</span><span class="p">,</span>
                <span class="n">fill_value</span><span class="o">=</span><span class="n">fill_value</span><span class="p">,</span>
                <span class="n">method</span><span class="o">=</span><span class="n">method</span><span class="p">,</span>
                <span class="n">limit</span><span class="o">=</span><span class="n">limit</span><span class="p">,</span>
                <span class="n">fill_axis</span><span class="o">=</span><span class="n">fill_axis</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">Series</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_align_series</span><span class="p">(</span>
                <span class="n">other</span><span class="p">,</span>
                <span class="n">join</span><span class="o">=</span><span class="n">join</span><span class="p">,</span>
                <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span>
                <span class="n">level</span><span class="o">=</span><span class="n">level</span><span class="p">,</span>
                <span class="n">copy</span><span class="o">=</span><span class="n">copy</span><span class="p">,</span>
                <span class="n">fill_value</span><span class="o">=</span><span class="n">fill_value</span><span class="p">,</span>
                <span class="n">method</span><span class="o">=</span><span class="n">method</span><span class="p">,</span>
                <span class="n">limit</span><span class="o">=</span><span class="n">limit</span><span class="p">,</span>
                <span class="n">fill_axis</span><span class="o">=</span><span class="n">fill_axis</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>  <span class="c1"># pragma: no cover</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;unsupported type: </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="nb">type</span><span class="p">(</span><span class="n">other</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">_align_frame</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">other</span><span class="p">,</span>
        <span class="n">join</span><span class="o">=</span><span class="s2">&quot;outer&quot;</span><span class="p">,</span>
        <span class="n">axis</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">level</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">copy</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">fill_value</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">method</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">limit</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">fill_axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="c1"># defaults</span>
        <span class="n">join_index</span><span class="p">,</span> <span class="n">join_columns</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span>
        <span class="n">ilidx</span><span class="p">,</span> <span class="n">iridx</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span>
        <span class="n">clidx</span><span class="p">,</span> <span class="n">cridx</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span>

        <span class="n">is_series</span> <span class="o">=</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ABCSeries</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">axis</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">axis</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">equals</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">index</span><span class="p">):</span>
                <span class="n">join_index</span><span class="p">,</span> <span class="n">ilidx</span><span class="p">,</span> <span class="n">iridx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">join</span><span class="p">(</span>
                    <span class="n">other</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="n">how</span><span class="o">=</span><span class="n">join</span><span class="p">,</span> <span class="n">level</span><span class="o">=</span><span class="n">level</span><span class="p">,</span> <span class="n">return_indexers</span><span class="o">=</span><span class="kc">True</span>
                <span class="p">)</span>

        <span class="k">if</span> <span class="n">axis</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">axis</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">is_series</span> <span class="ow">and</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">equals</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">columns</span><span class="p">):</span>
                <span class="n">join_columns</span><span class="p">,</span> <span class="n">clidx</span><span class="p">,</span> <span class="n">cridx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">join</span><span class="p">(</span>
                    <span class="n">other</span><span class="o">.</span><span class="n">columns</span><span class="p">,</span> <span class="n">how</span><span class="o">=</span><span class="n">join</span><span class="p">,</span> <span class="n">level</span><span class="o">=</span><span class="n">level</span><span class="p">,</span> <span class="n">return_indexers</span><span class="o">=</span><span class="kc">True</span>
                <span class="p">)</span>

        <span class="k">if</span> <span class="n">is_series</span><span class="p">:</span>
            <span class="n">reindexers</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">:</span> <span class="p">[</span><span class="n">join_index</span><span class="p">,</span> <span class="n">ilidx</span><span class="p">]}</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">reindexers</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">:</span> <span class="p">[</span><span class="n">join_index</span><span class="p">,</span> <span class="n">ilidx</span><span class="p">],</span> <span class="mi">1</span><span class="p">:</span> <span class="p">[</span><span class="n">join_columns</span><span class="p">,</span> <span class="n">clidx</span><span class="p">]}</span>

        <span class="n">left</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_reindex_with_indexers</span><span class="p">(</span>
            <span class="n">reindexers</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="n">copy</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=</span><span class="n">fill_value</span><span class="p">,</span> <span class="n">allow_dups</span><span class="o">=</span><span class="kc">True</span>
        <span class="p">)</span>
        <span class="c1"># other must be always DataFrame</span>
        <span class="n">right</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">_reindex_with_indexers</span><span class="p">(</span>
            <span class="p">{</span><span class="mi">0</span><span class="p">:</span> <span class="p">[</span><span class="n">join_index</span><span class="p">,</span> <span class="n">iridx</span><span class="p">],</span> <span class="mi">1</span><span class="p">:</span> <span class="p">[</span><span class="n">join_columns</span><span class="p">,</span> <span class="n">cridx</span><span class="p">]},</span>
            <span class="n">copy</span><span class="o">=</span><span class="n">copy</span><span class="p">,</span>
            <span class="n">fill_value</span><span class="o">=</span><span class="n">fill_value</span><span class="p">,</span>
            <span class="n">allow_dups</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="k">if</span> <span class="n">method</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">left</span> <span class="o">=</span> <span class="n">left</span><span class="o">.</span><span class="n">fillna</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="n">fill_axis</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="n">method</span><span class="p">,</span> <span class="n">limit</span><span class="o">=</span><span class="n">limit</span><span class="p">)</span>
            <span class="n">right</span> <span class="o">=</span> <span class="n">right</span><span class="o">.</span><span class="n">fillna</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="n">fill_axis</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="n">method</span><span class="p">,</span> <span class="n">limit</span><span class="o">=</span><span class="n">limit</span><span class="p">)</span>

        <span class="c1"># if DatetimeIndex have different tz, convert to UTC</span>
        <span class="k">if</span> <span class="n">is_datetime64tz_dtype</span><span class="p">(</span><span class="n">left</span><span class="o">.</span><span class="n">index</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">left</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">tz</span> <span class="o">!=</span> <span class="n">right</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">tz</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">join_index</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">left</span><span class="o">.</span><span class="n">index</span> <span class="o">=</span> <span class="n">join_index</span>
                    <span class="n">right</span><span class="o">.</span><span class="n">index</span> <span class="o">=</span> <span class="n">join_index</span>

        <span class="k">return</span> <span class="n">left</span><span class="o">.</span><span class="n">__finalize__</span><span class="p">(</span><span class="bp">self</span><span class="p">),</span> <span class="n">right</span><span class="o">.</span><span class="n">__finalize__</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_align_series</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">other</span><span class="p">,</span>
        <span class="n">join</span><span class="o">=</span><span class="s2">&quot;outer&quot;</span><span class="p">,</span>
        <span class="n">axis</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">level</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">copy</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">fill_value</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">method</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">limit</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">fill_axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
    <span class="p">):</span>

        <span class="n">is_series</span> <span class="o">=</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ABCSeries</span><span class="p">)</span>

        <span class="c1"># series/series compat, other must always be a Series</span>
        <span class="k">if</span> <span class="n">is_series</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">axis</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;cannot align series to a series other than &quot;</span> <span class="s2">&quot;axis 0&quot;</span><span class="p">)</span>

            <span class="c1"># equal</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">equals</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">index</span><span class="p">):</span>
                <span class="n">join_index</span><span class="p">,</span> <span class="n">lidx</span><span class="p">,</span> <span class="n">ridx</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">join_index</span><span class="p">,</span> <span class="n">lidx</span><span class="p">,</span> <span class="n">ridx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">join</span><span class="p">(</span>
                    <span class="n">other</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="n">how</span><span class="o">=</span><span class="n">join</span><span class="p">,</span> <span class="n">level</span><span class="o">=</span><span class="n">level</span><span class="p">,</span> <span class="n">return_indexers</span><span class="o">=</span><span class="kc">True</span>
                <span class="p">)</span>

            <span class="n">left</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_reindex_indexer</span><span class="p">(</span><span class="n">join_index</span><span class="p">,</span> <span class="n">lidx</span><span class="p">,</span> <span class="n">copy</span><span class="p">)</span>
            <span class="n">right</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">_reindex_indexer</span><span class="p">(</span><span class="n">join_index</span><span class="p">,</span> <span class="n">ridx</span><span class="p">,</span> <span class="n">copy</span><span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># one has &gt; 1 ndim</span>
            <span class="n">fdata</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span>
            <span class="k">if</span> <span class="n">axis</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">join_index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">index</span>
                <span class="n">lidx</span><span class="p">,</span> <span class="n">ridx</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">equals</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">index</span><span class="p">):</span>
                    <span class="n">join_index</span><span class="p">,</span> <span class="n">lidx</span><span class="p">,</span> <span class="n">ridx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">join</span><span class="p">(</span>
                        <span class="n">other</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="n">how</span><span class="o">=</span><span class="n">join</span><span class="p">,</span> <span class="n">level</span><span class="o">=</span><span class="n">level</span><span class="p">,</span> <span class="n">return_indexers</span><span class="o">=</span><span class="kc">True</span>
                    <span class="p">)</span>

                <span class="k">if</span> <span class="n">lidx</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">fdata</span> <span class="o">=</span> <span class="n">fdata</span><span class="o">.</span><span class="n">reindex_indexer</span><span class="p">(</span><span class="n">join_index</span><span class="p">,</span> <span class="n">lidx</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

            <span class="k">elif</span> <span class="n">axis</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">join_index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">columns</span>
                <span class="n">lidx</span><span class="p">,</span> <span class="n">ridx</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">equals</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">index</span><span class="p">):</span>
                    <span class="n">join_index</span><span class="p">,</span> <span class="n">lidx</span><span class="p">,</span> <span class="n">ridx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">join</span><span class="p">(</span>
                        <span class="n">other</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="n">how</span><span class="o">=</span><span class="n">join</span><span class="p">,</span> <span class="n">level</span><span class="o">=</span><span class="n">level</span><span class="p">,</span> <span class="n">return_indexers</span><span class="o">=</span><span class="kc">True</span>
                    <span class="p">)</span>

                <span class="k">if</span> <span class="n">lidx</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">fdata</span> <span class="o">=</span> <span class="n">fdata</span><span class="o">.</span><span class="n">reindex_indexer</span><span class="p">(</span><span class="n">join_index</span><span class="p">,</span> <span class="n">lidx</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Must specify axis=0 or 1&quot;</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">copy</span> <span class="ow">and</span> <span class="n">fdata</span> <span class="ow">is</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">:</span>
                <span class="n">fdata</span> <span class="o">=</span> <span class="n">fdata</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

            <span class="n">left</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_constructor</span><span class="p">(</span><span class="n">fdata</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">ridx</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">right</span> <span class="o">=</span> <span class="n">other</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">right</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">reindex</span><span class="p">(</span><span class="n">join_index</span><span class="p">,</span> <span class="n">level</span><span class="o">=</span><span class="n">level</span><span class="p">)</span>

        <span class="c1"># fill</span>
        <span class="n">fill_na</span> <span class="o">=</span> <span class="n">notna</span><span class="p">(</span><span class="n">fill_value</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">method</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">fill_na</span><span class="p">:</span>
            <span class="n">left</span> <span class="o">=</span> <span class="n">left</span><span class="o">.</span><span class="n">fillna</span><span class="p">(</span><span class="n">fill_value</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="n">method</span><span class="p">,</span> <span class="n">limit</span><span class="o">=</span><span class="n">limit</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">fill_axis</span><span class="p">)</span>
            <span class="n">right</span> <span class="o">=</span> <span class="n">right</span><span class="o">.</span><span class="n">fillna</span><span class="p">(</span><span class="n">fill_value</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="n">method</span><span class="p">,</span> <span class="n">limit</span><span class="o">=</span><span class="n">limit</span><span class="p">)</span>

        <span class="c1"># if DatetimeIndex have different tz, convert to UTC</span>
        <span class="k">if</span> <span class="n">is_series</span> <span class="ow">or</span> <span class="p">(</span><span class="ow">not</span> <span class="n">is_series</span> <span class="ow">and</span> <span class="n">axis</span> <span class="o">==</span> <span class="mi">0</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">is_datetime64tz_dtype</span><span class="p">(</span><span class="n">left</span><span class="o">.</span><span class="n">index</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">left</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">tz</span> <span class="o">!=</span> <span class="n">right</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">tz</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">join_index</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="n">left</span><span class="o">.</span><span class="n">index</span> <span class="o">=</span> <span class="n">join_index</span>
                        <span class="n">right</span><span class="o">.</span><span class="n">index</span> <span class="o">=</span> <span class="n">join_index</span>

        <span class="k">return</span> <span class="n">left</span><span class="o">.</span><span class="n">__finalize__</span><span class="p">(</span><span class="bp">self</span><span class="p">),</span> <span class="n">right</span><span class="o">.</span><span class="n">__finalize__</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_where</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">cond</span><span class="p">,</span>
        <span class="n">other</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span>
        <span class="n">inplace</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">axis</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">level</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">errors</span><span class="o">=</span><span class="s2">&quot;raise&quot;</span><span class="p">,</span>
        <span class="n">try_cast</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Equivalent to public method `where`, except that `other` is not</span>
<span class="sd">        applied as a function even if callable. Used in __setitem__.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">inplace</span> <span class="o">=</span> <span class="n">validate_bool_kwarg</span><span class="p">(</span><span class="n">inplace</span><span class="p">,</span> <span class="s2">&quot;inplace&quot;</span><span class="p">)</span>

        <span class="c1"># align the cond to same shape as myself</span>
        <span class="n">cond</span> <span class="o">=</span> <span class="n">com</span><span class="o">.</span><span class="n">apply_if_callable</span><span class="p">(</span><span class="n">cond</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">cond</span><span class="p">,</span> <span class="n">NDFrame</span><span class="p">):</span>
            <span class="n">cond</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">cond</span><span class="o">.</span><span class="n">align</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">join</span><span class="o">=</span><span class="s2">&quot;right&quot;</span><span class="p">,</span> <span class="n">broadcast_axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">cond</span><span class="p">,</span> <span class="s2">&quot;shape&quot;</span><span class="p">):</span>
                <span class="n">cond</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asanyarray</span><span class="p">(</span><span class="n">cond</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">cond</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Array conditional must be same shape as &quot;</span> <span class="s2">&quot;self&quot;</span><span class="p">)</span>
            <span class="n">cond</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_constructor</span><span class="p">(</span><span class="n">cond</span><span class="p">,</span> <span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">_construct_axes_dict</span><span class="p">())</span>

        <span class="c1"># make sure we are boolean</span>
        <span class="n">fill_value</span> <span class="o">=</span> <span class="nb">bool</span><span class="p">(</span><span class="n">inplace</span><span class="p">)</span>
        <span class="n">cond</span> <span class="o">=</span> <span class="n">cond</span><span class="o">.</span><span class="n">fillna</span><span class="p">(</span><span class="n">fill_value</span><span class="p">)</span>

        <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;Boolean array expected for the condition, not </span><span class="si">{dtype}</span><span class="s2">&quot;</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">cond</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">):</span>
            <span class="c1"># This is a single-dimensional object.</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">is_bool_dtype</span><span class="p">(</span><span class="n">cond</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">dtype</span><span class="o">=</span><span class="n">cond</span><span class="o">.</span><span class="n">dtype</span><span class="p">))</span>
        <span class="k">elif</span> <span class="ow">not</span> <span class="n">cond</span><span class="o">.</span><span class="n">empty</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">dt</span> <span class="ow">in</span> <span class="n">cond</span><span class="o">.</span><span class="n">dtypes</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">is_bool_dtype</span><span class="p">(</span><span class="n">dt</span><span class="p">):</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">dtype</span><span class="o">=</span><span class="n">dt</span><span class="p">))</span>

        <span class="n">cond</span> <span class="o">=</span> <span class="o">-</span><span class="n">cond</span> <span class="k">if</span> <span class="n">inplace</span> <span class="k">else</span> <span class="n">cond</span>

        <span class="c1"># try to align with other</span>
        <span class="n">try_quick</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="s2">&quot;align&quot;</span><span class="p">):</span>

            <span class="c1"># align with me</span>
            <span class="k">if</span> <span class="n">other</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ndim</span><span class="p">:</span>

                <span class="n">_</span><span class="p">,</span> <span class="n">other</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">align</span><span class="p">(</span>
                    <span class="n">other</span><span class="p">,</span> <span class="n">join</span><span class="o">=</span><span class="s2">&quot;left&quot;</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">level</span><span class="o">=</span><span class="n">level</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span>
                <span class="p">)</span>

                <span class="c1"># if we are NOT aligned, raise as we cannot where index</span>
                <span class="k">if</span> <span class="n">axis</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">all</span><span class="p">(</span>
                    <span class="n">other</span><span class="o">.</span><span class="n">_get_axis</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="o">.</span><span class="n">equals</span><span class="p">(</span><span class="n">ax</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">ax</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">axes</span><span class="p">)</span>
                <span class="p">):</span>
                    <span class="k">raise</span> <span class="n">InvalidIndexError</span>

            <span class="c1"># slice me out of the other</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span>
                    <span class="s2">&quot;cannot align with a higher &quot;</span> <span class="s2">&quot;dimensional NDFrame&quot;</span>
                <span class="p">)</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>

            <span class="k">if</span> <span class="n">other</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">:</span>

                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>

                    <span class="n">icond</span> <span class="o">=</span> <span class="n">cond</span><span class="o">.</span><span class="n">values</span>

                    <span class="c1"># GH 2745 / GH 4192</span>
                    <span class="c1"># treat like a scalar</span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">other</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                        <span class="n">other</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">other</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

                    <span class="c1"># GH 3235</span>
                    <span class="c1"># match True cond to other</span>
                    <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">cond</span><span class="p">[</span><span class="n">icond</span><span class="p">])</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">other</span><span class="p">):</span>

                        <span class="c1"># try to not change dtype at first (if try_quick)</span>
                        <span class="k">if</span> <span class="n">try_quick</span><span class="p">:</span>

                            <span class="k">try</span><span class="p">:</span>
                                <span class="n">new_other</span> <span class="o">=</span> <span class="n">com</span><span class="o">.</span><span class="n">values_from_object</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
                                <span class="n">new_other</span> <span class="o">=</span> <span class="n">new_other</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
                                <span class="n">new_other</span><span class="p">[</span><span class="n">icond</span><span class="p">]</span> <span class="o">=</span> <span class="n">other</span>
                                <span class="n">other</span> <span class="o">=</span> <span class="n">new_other</span>
                            <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
                                <span class="n">try_quick</span> <span class="o">=</span> <span class="kc">False</span>

                        <span class="c1"># let&#39;s create a new (if we failed at the above</span>
                        <span class="c1"># or not try_quick</span>
                        <span class="k">if</span> <span class="ow">not</span> <span class="n">try_quick</span><span class="p">:</span>

                            <span class="n">dtype</span><span class="p">,</span> <span class="n">fill_value</span> <span class="o">=</span> <span class="n">maybe_promote</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
                            <span class="n">new_other</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">icond</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>
                            <span class="n">new_other</span><span class="o">.</span><span class="n">fill</span><span class="p">(</span><span class="n">fill_value</span><span class="p">)</span>
                            <span class="n">maybe_upcast_putmask</span><span class="p">(</span><span class="n">new_other</span><span class="p">,</span> <span class="n">icond</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>
                            <span class="n">other</span> <span class="o">=</span> <span class="n">new_other</span>

                    <span class="k">else</span><span class="p">:</span>
                        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                            <span class="s2">&quot;Length of replacements must equal &quot;</span> <span class="s2">&quot;series length&quot;</span>
                        <span class="p">)</span>

                <span class="k">else</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                        <span class="s2">&quot;other must be the same shape as self &quot;</span> <span class="s2">&quot;when an ndarray&quot;</span>
                    <span class="p">)</span>

            <span class="c1"># we are the same shape, so create an actual object for alignment</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">other</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_constructor</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">_construct_axes_dict</span><span class="p">())</span>

        <span class="k">if</span> <span class="n">axis</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">axis</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="s2">&quot;ndim&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">):</span>
            <span class="n">align</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">align</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_axis_number</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span>

        <span class="n">block_axis</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_block_manager_axis</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">inplace</span><span class="p">:</span>
            <span class="c1"># we may have different type blocks come out of putmask, so</span>
            <span class="c1"># reconstruct the block manager</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">_check_inplace_setting</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
            <span class="n">new_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">putmask</span><span class="p">(</span>
                <span class="n">mask</span><span class="o">=</span><span class="n">cond</span><span class="p">,</span>
                <span class="n">new</span><span class="o">=</span><span class="n">other</span><span class="p">,</span>
                <span class="n">align</span><span class="o">=</span><span class="n">align</span><span class="p">,</span>
                <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">axis</span><span class="o">=</span><span class="n">block_axis</span><span class="p">,</span>
                <span class="n">transpose</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_AXIS_REVERSED</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_update_inplace</span><span class="p">(</span><span class="n">new_data</span><span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="n">new_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">where</span><span class="p">(</span>
                <span class="n">other</span><span class="o">=</span><span class="n">other</span><span class="p">,</span>
                <span class="n">cond</span><span class="o">=</span><span class="n">cond</span><span class="p">,</span>
                <span class="n">align</span><span class="o">=</span><span class="n">align</span><span class="p">,</span>
                <span class="n">errors</span><span class="o">=</span><span class="n">errors</span><span class="p">,</span>
                <span class="n">try_cast</span><span class="o">=</span><span class="n">try_cast</span><span class="p">,</span>
                <span class="n">axis</span><span class="o">=</span><span class="n">block_axis</span><span class="p">,</span>
            <span class="p">)</span>

            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_constructor</span><span class="p">(</span><span class="n">new_data</span><span class="p">)</span><span class="o">.</span><span class="n">__finalize__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="n">_shared_docs</span><span class="p">[</span>
        <span class="s2">&quot;where&quot;</span>
    <span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;</span>
<span class="s2">        Replace values where the condition is </span><span class="si">%(cond_rev)s</span><span class="s2">.</span>

<span class="s2">        Parameters</span>
<span class="s2">        ----------</span>
<span class="s2">        cond : boolean </span><span class="si">%(klass)s</span><span class="s2">, array-like, or callable</span>
<span class="s2">            Where `cond` is </span><span class="si">%(cond)s</span><span class="s2">, keep the original value. Where</span>
<span class="s2">            </span><span class="si">%(cond_rev)s</span><span class="s2">, replace with corresponding value from `other`.</span>
<span class="s2">            If `cond` is callable, it is computed on the </span><span class="si">%(klass)s</span><span class="s2"> and</span>
<span class="s2">            should return boolean </span><span class="si">%(klass)s</span><span class="s2"> or array. The callable must</span>
<span class="s2">            not change input </span><span class="si">%(klass)s</span><span class="s2"> (though pandas doesn&#39;t check it).</span>

<span class="s2">            .. versionadded:: 0.18.1</span>
<span class="s2">                A callable can be used as cond.</span>

<span class="s2">        other : scalar, </span><span class="si">%(klass)s</span><span class="s2">, or callable</span>
<span class="s2">            Entries where `cond` is </span><span class="si">%(cond_rev)s</span><span class="s2"> are replaced with</span>
<span class="s2">            corresponding value from `other`.</span>
<span class="s2">            If other is callable, it is computed on the </span><span class="si">%(klass)s</span><span class="s2"> and</span>
<span class="s2">            should return scalar or </span><span class="si">%(klass)s</span><span class="s2">. The callable must not</span>
<span class="s2">            change input </span><span class="si">%(klass)s</span><span class="s2"> (though pandas doesn&#39;t check it).</span>

<span class="s2">            .. versionadded:: 0.18.1</span>
<span class="s2">                A callable can be used as other.</span>

<span class="s2">        inplace : bool, default False</span>
<span class="s2">            Whether to perform the operation in place on the data.</span>
<span class="s2">        axis : int, default None</span>
<span class="s2">            Alignment axis if needed.</span>
<span class="s2">        level : int, default None</span>
<span class="s2">            Alignment level if needed.</span>
<span class="s2">        errors : str, {&#39;raise&#39;, &#39;ignore&#39;}, default &#39;raise&#39;</span>
<span class="s2">            Note that currently this parameter won&#39;t affect</span>
<span class="s2">            the results and will always coerce to a suitable dtype.</span>

<span class="s2">            - &#39;raise&#39; : allow exceptions to be raised.</span>
<span class="s2">            - &#39;ignore&#39; : suppress exceptions. On error return original object.</span>

<span class="s2">        try_cast : bool, default False</span>
<span class="s2">            Try to cast the result back to the input type (if possible).</span>

<span class="s2">        Returns</span>
<span class="s2">        -------</span>
<span class="s2">        Same type as caller</span>

<span class="s2">        See Also</span>
<span class="s2">        --------</span>
<span class="s2">        :func:`DataFrame.</span><span class="si">%(name_other)s</span><span class="s2">` : Return an object of same shape as</span>
<span class="s2">            self.</span>

<span class="s2">        Notes</span>
<span class="s2">        -----</span>
<span class="s2">        The </span><span class="si">%(name)s</span><span class="s2"> method is an application of the if-then idiom. For each</span>
<span class="s2">        element in the calling DataFrame, if ``cond`` is ``</span><span class="si">%(cond)s</span><span class="s2">`` the</span>
<span class="s2">        element is used; otherwise the corresponding element from the DataFrame</span>
<span class="s2">        ``other`` is used.</span>

<span class="s2">        The signature for :func:`DataFrame.where` differs from</span>
<span class="s2">        :func:`numpy.where`. Roughly ``df1.where(m, df2)`` is equivalent to</span>
<span class="s2">        ``np.where(m, df1, df2)``.</span>

<span class="s2">        For further details and examples see the ``</span><span class="si">%(name)s</span><span class="s2">`` documentation in</span>
<span class="s2">        :ref:`indexing &lt;indexing.where_mask&gt;`.</span>

<span class="s2">        Examples</span>
<span class="s2">        --------</span>
<span class="s2">        &gt;&gt;&gt; s = pd.Series(range(5))</span>
<span class="s2">        &gt;&gt;&gt; s.where(s &gt; 0)</span>
<span class="s2">        0    NaN</span>
<span class="s2">        1    1.0</span>
<span class="s2">        2    2.0</span>
<span class="s2">        3    3.0</span>
<span class="s2">        4    4.0</span>
<span class="s2">        dtype: float64</span>

<span class="s2">        &gt;&gt;&gt; s.mask(s &gt; 0)</span>
<span class="s2">        0    0.0</span>
<span class="s2">        1    NaN</span>
<span class="s2">        2    NaN</span>
<span class="s2">        3    NaN</span>
<span class="s2">        4    NaN</span>
<span class="s2">        dtype: float64</span>

<span class="s2">        &gt;&gt;&gt; s.where(s &gt; 1, 10)</span>
<span class="s2">        0    10</span>
<span class="s2">        1    10</span>
<span class="s2">        2    2</span>
<span class="s2">        3    3</span>
<span class="s2">        4    4</span>
<span class="s2">        dtype: int64</span>

<span class="s2">        &gt;&gt;&gt; df = pd.DataFrame(np.arange(10).reshape(-1, 2), columns=[&#39;A&#39;, &#39;B&#39;])</span>
<span class="s2">        &gt;&gt;&gt; df</span>
<span class="s2">           A  B</span>
<span class="s2">        0  0  1</span>
<span class="s2">        1  2  3</span>
<span class="s2">        2  4  5</span>
<span class="s2">        3  6  7</span>
<span class="s2">        4  8  9</span>
<span class="s2">        &gt;&gt;&gt; m = df </span><span class="si">%%</span><span class="s2"> 3 == 0</span>
<span class="s2">        &gt;&gt;&gt; df.where(m, -df)</span>
<span class="s2">           A  B</span>
<span class="s2">        0  0 -1</span>
<span class="s2">        1 -2  3</span>
<span class="s2">        2 -4 -5</span>
<span class="s2">        3  6 -7</span>
<span class="s2">        4 -8  9</span>
<span class="s2">        &gt;&gt;&gt; df.where(m, -df) == np.where(m, df, -df)</span>
<span class="s2">              A     B</span>
<span class="s2">        0  True  True</span>
<span class="s2">        1  True  True</span>
<span class="s2">        2  True  True</span>
<span class="s2">        3  True  True</span>
<span class="s2">        4  True  True</span>
<span class="s2">        &gt;&gt;&gt; df.where(m, -df) == df.mask(~m, -df)</span>
<span class="s2">              A     B</span>
<span class="s2">        0  True  True</span>
<span class="s2">        1  True  True</span>
<span class="s2">        2  True  True</span>
<span class="s2">        3  True  True</span>
<span class="s2">        4  True  True</span>
<span class="s2">        &quot;&quot;&quot;</span>

    <span class="nd">@Appender</span><span class="p">(</span>
        <span class="n">_shared_docs</span><span class="p">[</span><span class="s2">&quot;where&quot;</span><span class="p">]</span>
        <span class="o">%</span> <span class="nb">dict</span><span class="p">(</span>
            <span class="n">_shared_doc_kwargs</span><span class="p">,</span>
            <span class="n">cond</span><span class="o">=</span><span class="s2">&quot;True&quot;</span><span class="p">,</span>
            <span class="n">cond_rev</span><span class="o">=</span><span class="s2">&quot;False&quot;</span><span class="p">,</span>
            <span class="n">name</span><span class="o">=</span><span class="s2">&quot;where&quot;</span><span class="p">,</span>
            <span class="n">name_other</span><span class="o">=</span><span class="s2">&quot;mask&quot;</span><span class="p">,</span>
        <span class="p">)</span>
    <span class="p">)</span>
    <span class="k">def</span> <span class="nf">where</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">cond</span><span class="p">,</span>
        <span class="n">other</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span>
        <span class="n">inplace</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">axis</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">level</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">errors</span><span class="o">=</span><span class="s2">&quot;raise&quot;</span><span class="p">,</span>
        <span class="n">try_cast</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="p">):</span>

        <span class="n">other</span> <span class="o">=</span> <span class="n">com</span><span class="o">.</span><span class="n">apply_if_callable</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_where</span><span class="p">(</span>
            <span class="n">cond</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">inplace</span><span class="p">,</span> <span class="n">axis</span><span class="p">,</span> <span class="n">level</span><span class="p">,</span> <span class="n">errors</span><span class="o">=</span><span class="n">errors</span><span class="p">,</span> <span class="n">try_cast</span><span class="o">=</span><span class="n">try_cast</span>
        <span class="p">)</span>

    <span class="nd">@Appender</span><span class="p">(</span>
        <span class="n">_shared_docs</span><span class="p">[</span><span class="s2">&quot;where&quot;</span><span class="p">]</span>
        <span class="o">%</span> <span class="nb">dict</span><span class="p">(</span>
            <span class="n">_shared_doc_kwargs</span><span class="p">,</span>
            <span class="n">cond</span><span class="o">=</span><span class="s2">&quot;False&quot;</span><span class="p">,</span>
            <span class="n">cond_rev</span><span class="o">=</span><span class="s2">&quot;True&quot;</span><span class="p">,</span>
            <span class="n">name</span><span class="o">=</span><span class="s2">&quot;mask&quot;</span><span class="p">,</span>
            <span class="n">name_other</span><span class="o">=</span><span class="s2">&quot;where&quot;</span><span class="p">,</span>
        <span class="p">)</span>
    <span class="p">)</span>
    <span class="k">def</span> <span class="nf">mask</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">cond</span><span class="p">,</span>
        <span class="n">other</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span>
        <span class="n">inplace</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">axis</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">level</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">errors</span><span class="o">=</span><span class="s2">&quot;raise&quot;</span><span class="p">,</span>
        <span class="n">try_cast</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="p">):</span>

        <span class="n">inplace</span> <span class="o">=</span> <span class="n">validate_bool_kwarg</span><span class="p">(</span><span class="n">inplace</span><span class="p">,</span> <span class="s2">&quot;inplace&quot;</span><span class="p">)</span>
        <span class="n">cond</span> <span class="o">=</span> <span class="n">com</span><span class="o">.</span><span class="n">apply_if_callable</span><span class="p">(</span><span class="n">cond</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>

        <span class="c1"># see gh-21891</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">cond</span><span class="p">,</span> <span class="s2">&quot;__invert__&quot;</span><span class="p">):</span>
            <span class="n">cond</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">cond</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">where</span><span class="p">(</span>
            <span class="o">~</span><span class="n">cond</span><span class="p">,</span>
            <span class="n">other</span><span class="o">=</span><span class="n">other</span><span class="p">,</span>
            <span class="n">inplace</span><span class="o">=</span><span class="n">inplace</span><span class="p">,</span>
            <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span>
            <span class="n">level</span><span class="o">=</span><span class="n">level</span><span class="p">,</span>
            <span class="n">try_cast</span><span class="o">=</span><span class="n">try_cast</span><span class="p">,</span>
            <span class="n">errors</span><span class="o">=</span><span class="n">errors</span><span class="p">,</span>
        <span class="p">)</span>

    <span class="n">_shared_docs</span><span class="p">[</span>
        <span class="s2">&quot;shift&quot;</span>
    <span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;</span>
<span class="s2">        Shift index by desired number of periods with an optional time `freq`.</span>

<span class="s2">        When `freq` is not passed, shift the index without realigning the data.</span>
<span class="s2">        If `freq` is passed (in this case, the index must be date or datetime,</span>
<span class="s2">        or it will raise a `NotImplementedError`), the index will be</span>
<span class="s2">        increased using the periods and the `freq`.</span>

<span class="s2">        Parameters</span>
<span class="s2">        ----------</span>
<span class="s2">        periods : int</span>
<span class="s2">            Number of periods to shift. Can be positive or negative.</span>
<span class="s2">        freq : DateOffset, tseries.offsets, timedelta, or str, optional</span>
<span class="s2">            Offset to use from the tseries module or time rule (e.g. &#39;EOM&#39;).</span>
<span class="s2">            If `freq` is specified then the index values are shifted but the</span>
<span class="s2">            data is not realigned. That is, use `freq` if you would like to</span>
<span class="s2">            extend the index when shifting and preserve the original data.</span>
<span class="s2">        axis : {0 or &#39;index&#39;, 1 or &#39;columns&#39;, None}, default None</span>
<span class="s2">            Shift direction.</span>
<span class="s2">        fill_value : object, optional</span>
<span class="s2">            The scalar value to use for newly introduced missing values.</span>
<span class="s2">            the default depends on the dtype of `self`.</span>
<span class="s2">            For numeric data, ``np.nan`` is used.</span>
<span class="s2">            For datetime, timedelta, or period data, etc. :attr:`NaT` is used.</span>
<span class="s2">            For extension dtypes, ``self.dtype.na_value`` is used.</span>

<span class="s2">            .. versionchanged:: 0.24.0</span>

<span class="s2">        Returns</span>
<span class="s2">        -------</span>
<span class="s2">        </span><span class="si">%(klass)s</span><span class="s2"></span>
<span class="s2">            Copy of input object, shifted.</span>

<span class="s2">        See Also</span>
<span class="s2">        --------</span>
<span class="s2">        Index.shift : Shift values of Index.</span>
<span class="s2">        DatetimeIndex.shift : Shift values of DatetimeIndex.</span>
<span class="s2">        PeriodIndex.shift : Shift values of PeriodIndex.</span>
<span class="s2">        tshift : Shift the time index, using the index&#39;s frequency if</span>
<span class="s2">            available.</span>

<span class="s2">        Examples</span>
<span class="s2">        --------</span>
<span class="s2">        &gt;&gt;&gt; df = pd.DataFrame({&#39;Col1&#39;: [10, 20, 15, 30, 45],</span>
<span class="s2">        ...                    &#39;Col2&#39;: [13, 23, 18, 33, 48],</span>
<span class="s2">        ...                    &#39;Col3&#39;: [17, 27, 22, 37, 52]})</span>

<span class="s2">        &gt;&gt;&gt; df.shift(periods=3)</span>
<span class="s2">           Col1  Col2  Col3</span>
<span class="s2">        0   NaN   NaN   NaN</span>
<span class="s2">        1   NaN   NaN   NaN</span>
<span class="s2">        2   NaN   NaN   NaN</span>
<span class="s2">        3  10.0  13.0  17.0</span>
<span class="s2">        4  20.0  23.0  27.0</span>

<span class="s2">        &gt;&gt;&gt; df.shift(periods=1, axis=&#39;columns&#39;)</span>
<span class="s2">           Col1  Col2  Col3</span>
<span class="s2">        0   NaN  10.0  13.0</span>
<span class="s2">        1   NaN  20.0  23.0</span>
<span class="s2">        2   NaN  15.0  18.0</span>
<span class="s2">        3   NaN  30.0  33.0</span>
<span class="s2">        4   NaN  45.0  48.0</span>

<span class="s2">        &gt;&gt;&gt; df.shift(periods=3, fill_value=0)</span>
<span class="s2">           Col1  Col2  Col3</span>
<span class="s2">        0     0     0     0</span>
<span class="s2">        1     0     0     0</span>
<span class="s2">        2     0     0     0</span>
<span class="s2">        3    10    13    17</span>
<span class="s2">        4    20    23    27</span>
<span class="s2">    &quot;&quot;&quot;</span>

    <span class="nd">@Appender</span><span class="p">(</span><span class="n">_shared_docs</span><span class="p">[</span><span class="s2">&quot;shift&quot;</span><span class="p">]</span> <span class="o">%</span> <span class="n">_shared_doc_kwargs</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">shift</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">periods</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">freq</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">periods</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

        <span class="n">block_axis</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_block_manager_axis</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">freq</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">new_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">shift</span><span class="p">(</span>
                <span class="n">periods</span><span class="o">=</span><span class="n">periods</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">block_axis</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=</span><span class="n">fill_value</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">tshift</span><span class="p">(</span><span class="n">periods</span><span class="p">,</span> <span class="n">freq</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_constructor</span><span class="p">(</span><span class="n">new_data</span><span class="p">)</span><span class="o">.</span><span class="n">__finalize__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">slice_shift</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">periods</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Equivalent to `shift` without copying data. The shifted data will</span>
<span class="sd">        not include the dropped periods and the shifted axis will be smaller</span>
<span class="sd">        than the original.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        periods : int</span>
<span class="sd">            Number of periods to move, can be positive or negative</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        shifted : same type as caller</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        While the `slice_shift` is faster than `shift`, you may pay for it</span>
<span class="sd">        later during alignment.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">periods</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span>

        <span class="k">if</span> <span class="n">periods</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">vslicer</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="o">-</span><span class="n">periods</span><span class="p">)</span>
            <span class="n">islicer</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="n">periods</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">vslicer</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="o">-</span><span class="n">periods</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
            <span class="n">islicer</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="n">periods</span><span class="p">)</span>

        <span class="n">new_obj</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_slice</span><span class="p">(</span><span class="n">vslicer</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span>
        <span class="n">shifted_axis</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_axis</span><span class="p">(</span><span class="n">axis</span><span class="p">)[</span><span class="n">islicer</span><span class="p">]</span>
        <span class="n">new_obj</span><span class="o">.</span><span class="n">set_axis</span><span class="p">(</span><span class="n">shifted_axis</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">new_obj</span><span class="o">.</span><span class="n">__finalize__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">tshift</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">periods</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">freq</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Shift the time index, using the index&#39;s frequency if available.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        periods : int</span>
<span class="sd">            Number of periods to move, can be positive or negative</span>
<span class="sd">        freq : DateOffset, timedelta, or time rule string, default None</span>
<span class="sd">            Increment to use from the tseries module or time rule (e.g. &#39;EOM&#39;)</span>
<span class="sd">        axis : int or basestring</span>
<span class="sd">            Corresponds to the axis that contains the Index</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        shifted : Series/DataFrame</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        If freq is not specified then tries to use the freq or inferred_freq</span>
<span class="sd">        attributes of the index. If neither of those attributes exist, a</span>
<span class="sd">        ValueError is thrown</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_axis</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">freq</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">freq</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="s2">&quot;freq&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">freq</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">freq</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="s2">&quot;inferred_freq&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">freq</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;Freq was not given and was not set in the index&quot;</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">periods</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">freq</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="n">freq</span> <span class="o">=</span> <span class="n">to_offset</span><span class="p">(</span><span class="n">freq</span><span class="p">)</span>

        <span class="n">block_axis</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_block_manager_axis</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">PeriodIndex</span><span class="p">):</span>
            <span class="n">orig_freq</span> <span class="o">=</span> <span class="n">to_offset</span><span class="p">(</span><span class="n">index</span><span class="o">.</span><span class="n">freq</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">freq</span> <span class="o">==</span> <span class="n">orig_freq</span><span class="p">:</span>
                <span class="n">new_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
                <span class="n">new_data</span><span class="o">.</span><span class="n">axes</span><span class="p">[</span><span class="n">block_axis</span><span class="p">]</span> <span class="o">=</span> <span class="n">index</span><span class="o">.</span><span class="n">shift</span><span class="p">(</span><span class="n">periods</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;Given freq </span><span class="si">%s</span><span class="s2"> does not match PeriodIndex freq </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span>
                    <span class="n">freq</span><span class="o">.</span><span class="n">rule_code</span><span class="p">,</span>
                    <span class="n">orig_freq</span><span class="o">.</span><span class="n">rule_code</span><span class="p">,</span>
                <span class="p">)</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">new_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">new_data</span><span class="o">.</span><span class="n">axes</span><span class="p">[</span><span class="n">block_axis</span><span class="p">]</span> <span class="o">=</span> <span class="n">index</span><span class="o">.</span><span class="n">shift</span><span class="p">(</span><span class="n">periods</span><span class="p">,</span> <span class="n">freq</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_constructor</span><span class="p">(</span><span class="n">new_data</span><span class="p">)</span><span class="o">.</span><span class="n">__finalize__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">truncate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">before</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">after</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Truncate a Series or DataFrame before and after some index value.</span>

<span class="sd">        This is a useful shorthand for boolean indexing based on index</span>
<span class="sd">        values above or below certain thresholds.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        before : date, string, int</span>
<span class="sd">            Truncate all rows before this index value.</span>
<span class="sd">        after : date, string, int</span>
<span class="sd">            Truncate all rows after this index value.</span>
<span class="sd">        axis : {0 or &#39;index&#39;, 1 or &#39;columns&#39;}, optional</span>
<span class="sd">            Axis to truncate. Truncates the index (rows) by default.</span>
<span class="sd">        copy : boolean, default is True,</span>
<span class="sd">            Return a copy of the truncated section.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        type of caller</span>
<span class="sd">            The truncated Series or DataFrame.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        DataFrame.loc : Select a subset of a DataFrame by label.</span>
<span class="sd">        DataFrame.iloc : Select a subset of a DataFrame by position.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        If the index being truncated contains only datetime values,</span>
<span class="sd">        `before` and `after` may be specified as strings instead of</span>
<span class="sd">        Timestamps.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; df = pd.DataFrame({&#39;A&#39;: [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39;],</span>
<span class="sd">        ...                    &#39;B&#39;: [&#39;f&#39;, &#39;g&#39;, &#39;h&#39;, &#39;i&#39;, &#39;j&#39;],</span>
<span class="sd">        ...                    &#39;C&#39;: [&#39;k&#39;, &#39;l&#39;, &#39;m&#39;, &#39;n&#39;, &#39;o&#39;]},</span>
<span class="sd">        ...                    index=[1, 2, 3, 4, 5])</span>
<span class="sd">        &gt;&gt;&gt; df</span>
<span class="sd">           A  B  C</span>
<span class="sd">        1  a  f  k</span>
<span class="sd">        2  b  g  l</span>
<span class="sd">        3  c  h  m</span>
<span class="sd">        4  d  i  n</span>
<span class="sd">        5  e  j  o</span>

<span class="sd">        &gt;&gt;&gt; df.truncate(before=2, after=4)</span>
<span class="sd">           A  B  C</span>
<span class="sd">        2  b  g  l</span>
<span class="sd">        3  c  h  m</span>
<span class="sd">        4  d  i  n</span>

<span class="sd">        The columns of a DataFrame can be truncated.</span>

<span class="sd">        &gt;&gt;&gt; df.truncate(before=&quot;A&quot;, after=&quot;B&quot;, axis=&quot;columns&quot;)</span>
<span class="sd">           A  B</span>
<span class="sd">        1  a  f</span>
<span class="sd">        2  b  g</span>
<span class="sd">        3  c  h</span>
<span class="sd">        4  d  i</span>
<span class="sd">        5  e  j</span>

<span class="sd">        For Series, only rows can be truncated.</span>

<span class="sd">        &gt;&gt;&gt; df[&#39;A&#39;].truncate(before=2, after=4)</span>
<span class="sd">        2    b</span>
<span class="sd">        3    c</span>
<span class="sd">        4    d</span>
<span class="sd">        Name: A, dtype: object</span>

<span class="sd">        The index values in ``truncate`` can be datetimes or string</span>
<span class="sd">        dates.</span>

<span class="sd">        &gt;&gt;&gt; dates = pd.date_range(&#39;2016-01-01&#39;, &#39;2016-02-01&#39;, freq=&#39;s&#39;)</span>
<span class="sd">        &gt;&gt;&gt; df = pd.DataFrame(index=dates, data={&#39;A&#39;: 1})</span>
<span class="sd">        &gt;&gt;&gt; df.tail()</span>
<span class="sd">                             A</span>
<span class="sd">        2016-01-31 23:59:56  1</span>
<span class="sd">        2016-01-31 23:59:57  1</span>
<span class="sd">        2016-01-31 23:59:58  1</span>
<span class="sd">        2016-01-31 23:59:59  1</span>
<span class="sd">        2016-02-01 00:00:00  1</span>

<span class="sd">        &gt;&gt;&gt; df.truncate(before=pd.Timestamp(&#39;2016-01-05&#39;),</span>
<span class="sd">        ...             after=pd.Timestamp(&#39;2016-01-10&#39;)).tail()</span>
<span class="sd">                             A</span>
<span class="sd">        2016-01-09 23:59:56  1</span>
<span class="sd">        2016-01-09 23:59:57  1</span>
<span class="sd">        2016-01-09 23:59:58  1</span>
<span class="sd">        2016-01-09 23:59:59  1</span>
<span class="sd">        2016-01-10 00:00:00  1</span>

<span class="sd">        Because the index is a DatetimeIndex containing only dates, we can</span>
<span class="sd">        specify `before` and `after` as strings. They will be coerced to</span>
<span class="sd">        Timestamps before truncation.</span>

<span class="sd">        &gt;&gt;&gt; df.truncate(&#39;2016-01-05&#39;, &#39;2016-01-10&#39;).tail()</span>
<span class="sd">                             A</span>
<span class="sd">        2016-01-09 23:59:56  1</span>
<span class="sd">        2016-01-09 23:59:57  1</span>
<span class="sd">        2016-01-09 23:59:58  1</span>
<span class="sd">        2016-01-09 23:59:59  1</span>
<span class="sd">        2016-01-10 00:00:00  1</span>

<span class="sd">        Note that ``truncate`` assumes a 0 value for any unspecified time</span>
<span class="sd">        component (midnight). This differs from partial string slicing, which</span>
<span class="sd">        returns any partially matching dates.</span>

<span class="sd">        &gt;&gt;&gt; df.loc[&#39;2016-01-05&#39;:&#39;2016-01-10&#39;, :].tail()</span>
<span class="sd">                             A</span>
<span class="sd">        2016-01-10 23:59:55  1</span>
<span class="sd">        2016-01-10 23:59:56  1</span>
<span class="sd">        2016-01-10 23:59:57  1</span>
<span class="sd">        2016-01-10 23:59:58  1</span>
<span class="sd">        2016-01-10 23:59:59  1</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">axis</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">axis</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_stat_axis_number</span>
        <span class="n">axis</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_axis_number</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span>
        <span class="n">ax</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_axis</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span>

        <span class="c1"># GH 17935</span>
        <span class="c1"># Check that index is sorted</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">ax</span><span class="o">.</span><span class="n">is_monotonic_increasing</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">ax</span><span class="o">.</span><span class="n">is_monotonic_decreasing</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;truncate requires a sorted index&quot;</span><span class="p">)</span>

        <span class="c1"># if we have a date index, convert to dates, otherwise</span>
        <span class="c1"># treat like a slice</span>
        <span class="k">if</span> <span class="n">ax</span><span class="o">.</span><span class="n">is_all_dates</span><span class="p">:</span>
            <span class="kn">from</span> <span class="nn">pandas.core.tools.datetimes</span> <span class="k">import</span> <span class="n">to_datetime</span>

            <span class="n">before</span> <span class="o">=</span> <span class="n">to_datetime</span><span class="p">(</span><span class="n">before</span><span class="p">)</span>
            <span class="n">after</span> <span class="o">=</span> <span class="n">to_datetime</span><span class="p">(</span><span class="n">after</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">before</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">after</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">before</span> <span class="o">&gt;</span> <span class="n">after</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Truncate: </span><span class="si">%s</span><span class="s2"> must be after </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">after</span><span class="p">,</span> <span class="n">before</span><span class="p">))</span>

        <span class="n">slicer</span> <span class="o">=</span> <span class="p">[</span><span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">)]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">_AXIS_LEN</span>
        <span class="n">slicer</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="n">before</span><span class="p">,</span> <span class="n">after</span><span class="p">)</span>
        <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">slicer</span><span class="p">)]</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ax</span><span class="p">,</span> <span class="n">MultiIndex</span><span class="p">):</span>
            <span class="nb">setattr</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_axis_name</span><span class="p">(</span><span class="n">axis</span><span class="p">),</span> <span class="n">ax</span><span class="o">.</span><span class="n">truncate</span><span class="p">(</span><span class="n">before</span><span class="p">,</span> <span class="n">after</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">copy</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

        <span class="k">return</span> <span class="n">result</span>

    <span class="k">def</span> <span class="nf">tz_convert</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tz</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">level</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Convert tz-aware axis to target time zone.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        tz : string or pytz.timezone object</span>
<span class="sd">        axis : the axis to convert</span>
<span class="sd">        level : int, str, default None</span>
<span class="sd">            If axis ia a MultiIndex, convert a specific level. Otherwise</span>
<span class="sd">            must be None</span>
<span class="sd">        copy : boolean, default True</span>
<span class="sd">            Also make a copy of the underlying data</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        %(klass)s</span>
<span class="sd">            Object with time zone converted axis.</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        TypeError</span>
<span class="sd">            If the axis is tz-naive.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">axis</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_axis_number</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span>
        <span class="n">ax</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_axis</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span>

        <span class="k">def</span> <span class="nf">_tz_convert</span><span class="p">(</span><span class="n">ax</span><span class="p">,</span> <span class="n">tz</span><span class="p">):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">ax</span><span class="p">,</span> <span class="s2">&quot;tz_convert&quot;</span><span class="p">):</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">ax</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">ax_name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_axis_name</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span>
                    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                        <span class="s2">&quot;</span><span class="si">%s</span><span class="s2"> is not a valid DatetimeIndex or &quot;</span> <span class="s2">&quot;PeriodIndex&quot;</span> <span class="o">%</span> <span class="n">ax_name</span>
                    <span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">ax</span> <span class="o">=</span> <span class="n">DatetimeIndex</span><span class="p">([],</span> <span class="n">tz</span><span class="o">=</span><span class="n">tz</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">ax</span> <span class="o">=</span> <span class="n">ax</span><span class="o">.</span><span class="n">tz_convert</span><span class="p">(</span><span class="n">tz</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">ax</span>

        <span class="c1"># if a level is given it must be a MultiIndex level or</span>
        <span class="c1"># equivalent to the axis name</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ax</span><span class="p">,</span> <span class="n">MultiIndex</span><span class="p">):</span>
            <span class="n">level</span> <span class="o">=</span> <span class="n">ax</span><span class="o">.</span><span class="n">_get_level_number</span><span class="p">(</span><span class="n">level</span><span class="p">)</span>
            <span class="n">new_level</span> <span class="o">=</span> <span class="n">_tz_convert</span><span class="p">(</span><span class="n">ax</span><span class="o">.</span><span class="n">levels</span><span class="p">[</span><span class="n">level</span><span class="p">],</span> <span class="n">tz</span><span class="p">)</span>
            <span class="n">ax</span> <span class="o">=</span> <span class="n">ax</span><span class="o">.</span><span class="n">set_levels</span><span class="p">(</span><span class="n">new_level</span><span class="p">,</span> <span class="n">level</span><span class="o">=</span><span class="n">level</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">level</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">ax</span><span class="o">.</span><span class="n">name</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;The level </span><span class="si">{0}</span><span class="s2"> is not valid&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">level</span><span class="p">))</span>
            <span class="n">ax</span> <span class="o">=</span> <span class="n">_tz_convert</span><span class="p">(</span><span class="n">ax</span><span class="p">,</span> <span class="n">tz</span><span class="p">)</span>

        <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_constructor</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="n">copy</span><span class="p">)</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">set_axis</span><span class="p">(</span><span class="n">ax</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">result</span><span class="o">.</span><span class="n">__finalize__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">tz_localize</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">tz</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">level</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">ambiguous</span><span class="o">=</span><span class="s2">&quot;raise&quot;</span><span class="p">,</span> <span class="n">nonexistent</span><span class="o">=</span><span class="s2">&quot;raise&quot;</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Localize tz-naive index of a Series or DataFrame to target time zone.</span>

<span class="sd">        This operation localizes the Index. To localize the values in a</span>
<span class="sd">        timezone-naive Series, use :meth:`Series.dt.tz_localize`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        tz : string or pytz.timezone object</span>
<span class="sd">        axis : the axis to localize</span>
<span class="sd">        level : int, str, default None</span>
<span class="sd">            If axis ia a MultiIndex, localize a specific level. Otherwise</span>
<span class="sd">            must be None</span>
<span class="sd">        copy : boolean, default True</span>
<span class="sd">            Also make a copy of the underlying data</span>
<span class="sd">        ambiguous : &#39;infer&#39;, bool-ndarray, &#39;NaT&#39;, default &#39;raise&#39;</span>
<span class="sd">            When clocks moved backward due to DST, ambiguous times may arise.</span>
<span class="sd">            For example in Central European Time (UTC+01), when going from</span>
<span class="sd">            03:00 DST to 02:00 non-DST, 02:30:00 local time occurs both at</span>
<span class="sd">            00:30:00 UTC and at 01:30:00 UTC. In such a situation, the</span>
<span class="sd">            `ambiguous` parameter dictates how ambiguous times should be</span>
<span class="sd">            handled.</span>

<span class="sd">            - &#39;infer&#39; will attempt to infer fall dst-transition hours based on</span>
<span class="sd">              order</span>
<span class="sd">            - bool-ndarray where True signifies a DST time, False designates</span>
<span class="sd">              a non-DST time (note that this flag is only applicable for</span>
<span class="sd">              ambiguous times)</span>
<span class="sd">            - &#39;NaT&#39; will return NaT where there are ambiguous times</span>
<span class="sd">            - &#39;raise&#39; will raise an AmbiguousTimeError if there are ambiguous</span>
<span class="sd">              times</span>
<span class="sd">        nonexistent : str, default &#39;raise&#39;</span>
<span class="sd">            A nonexistent time does not exist in a particular timezone</span>
<span class="sd">            where clocks moved forward due to DST. Valid values are:</span>

<span class="sd">            - &#39;shift_forward&#39; will shift the nonexistent time forward to the</span>
<span class="sd">              closest existing time</span>
<span class="sd">            - &#39;shift_backward&#39; will shift the nonexistent time backward to the</span>
<span class="sd">              closest existing time</span>
<span class="sd">            - &#39;NaT&#39; will return NaT where there are nonexistent times</span>
<span class="sd">            - timedelta objects will shift nonexistent times by the timedelta</span>
<span class="sd">            - &#39;raise&#39; will raise an NonExistentTimeError if there are</span>
<span class="sd">              nonexistent times</span>

<span class="sd">            .. versionadded:: 0.24.0</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Series or DataFrame</span>
<span class="sd">            Same type as the input.</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        TypeError</span>
<span class="sd">            If the TimeSeries is tz-aware and tz is not None.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>

<span class="sd">        Localize local times:</span>

<span class="sd">        &gt;&gt;&gt; s = pd.Series([1],</span>
<span class="sd">        ... index=pd.DatetimeIndex([&#39;2018-09-15 01:30:00&#39;]))</span>
<span class="sd">        &gt;&gt;&gt; s.tz_localize(&#39;CET&#39;)</span>
<span class="sd">        2018-09-15 01:30:00+02:00    1</span>
<span class="sd">        dtype: int64</span>

<span class="sd">        Be careful with DST changes. When there is sequential data, pandas</span>
<span class="sd">        can infer the DST time:</span>

<span class="sd">        &gt;&gt;&gt; s = pd.Series(range(7), index=pd.DatetimeIndex([</span>
<span class="sd">        ... &#39;2018-10-28 01:30:00&#39;,</span>
<span class="sd">        ... &#39;2018-10-28 02:00:00&#39;,</span>
<span class="sd">        ... &#39;2018-10-28 02:30:00&#39;,</span>
<span class="sd">        ... &#39;2018-10-28 02:00:00&#39;,</span>
<span class="sd">        ... &#39;2018-10-28 02:30:00&#39;,</span>
<span class="sd">        ... &#39;2018-10-28 03:00:00&#39;,</span>
<span class="sd">        ... &#39;2018-10-28 03:30:00&#39;]))</span>
<span class="sd">        &gt;&gt;&gt; s.tz_localize(&#39;CET&#39;, ambiguous=&#39;infer&#39;)</span>
<span class="sd">        2018-10-28 01:30:00+02:00    0</span>
<span class="sd">        2018-10-28 02:00:00+02:00    1</span>
<span class="sd">        2018-10-28 02:30:00+02:00    2</span>
<span class="sd">        2018-10-28 02:00:00+01:00    3</span>
<span class="sd">        2018-10-28 02:30:00+01:00    4</span>
<span class="sd">        2018-10-28 03:00:00+01:00    5</span>
<span class="sd">        2018-10-28 03:30:00+01:00    6</span>
<span class="sd">        dtype: int64</span>

<span class="sd">        In some cases, inferring the DST is impossible. In such cases, you can</span>
<span class="sd">        pass an ndarray to the ambiguous parameter to set the DST explicitly</span>

<span class="sd">        &gt;&gt;&gt; s = pd.Series(range(3), index=pd.DatetimeIndex([</span>
<span class="sd">        ... &#39;2018-10-28 01:20:00&#39;,</span>
<span class="sd">        ... &#39;2018-10-28 02:36:00&#39;,</span>
<span class="sd">        ... &#39;2018-10-28 03:46:00&#39;]))</span>
<span class="sd">        &gt;&gt;&gt; s.tz_localize(&#39;CET&#39;, ambiguous=np.array([True, True, False]))</span>
<span class="sd">        2018-10-28 01:20:00+02:00    0</span>
<span class="sd">        2018-10-28 02:36:00+02:00    1</span>
<span class="sd">        2018-10-28 03:46:00+01:00    2</span>
<span class="sd">        dtype: int64</span>

<span class="sd">        If the DST transition causes nonexistent times, you can shift these</span>
<span class="sd">        dates forward or backwards with a timedelta object or `&#39;shift_forward&#39;`</span>
<span class="sd">        or `&#39;shift_backwards&#39;`.</span>
<span class="sd">        &gt;&gt;&gt; s = pd.Series(range(2), index=pd.DatetimeIndex([</span>
<span class="sd">        ... &#39;2015-03-29 02:30:00&#39;,</span>
<span class="sd">        ... &#39;2015-03-29 03:30:00&#39;]))</span>
<span class="sd">        &gt;&gt;&gt; s.tz_localize(&#39;Europe/Warsaw&#39;, nonexistent=&#39;shift_forward&#39;)</span>
<span class="sd">        2015-03-29 03:00:00+02:00    0</span>
<span class="sd">        2015-03-29 03:30:00+02:00    1</span>
<span class="sd">        dtype: int64</span>
<span class="sd">        &gt;&gt;&gt; s.tz_localize(&#39;Europe/Warsaw&#39;, nonexistent=&#39;shift_backward&#39;)</span>
<span class="sd">        2015-03-29 01:59:59.999999999+01:00    0</span>
<span class="sd">        2015-03-29 03:30:00+02:00              1</span>
<span class="sd">        dtype: int64</span>
<span class="sd">        &gt;&gt;&gt; s.tz_localize(&#39;Europe/Warsaw&#39;, nonexistent=pd.Timedelta(&#39;1H&#39;))</span>
<span class="sd">        2015-03-29 03:30:00+02:00    0</span>
<span class="sd">        2015-03-29 03:30:00+02:00    1</span>
<span class="sd">        dtype: int64</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">nonexistent_options</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;raise&quot;</span><span class="p">,</span> <span class="s2">&quot;NaT&quot;</span><span class="p">,</span> <span class="s2">&quot;shift_forward&quot;</span><span class="p">,</span> <span class="s2">&quot;shift_backward&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">nonexistent</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">nonexistent_options</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span>
            <span class="n">nonexistent</span><span class="p">,</span> <span class="n">timedelta</span>
        <span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;The nonexistent argument must be one of &#39;raise&#39;,&quot;</span>
                <span class="s2">&quot; &#39;NaT&#39;, &#39;shift_forward&#39;, &#39;shift_backward&#39; or&quot;</span>
                <span class="s2">&quot; a timedelta object&quot;</span>
            <span class="p">)</span>

        <span class="n">axis</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_axis_number</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span>
        <span class="n">ax</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_axis</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span>

        <span class="k">def</span> <span class="nf">_tz_localize</span><span class="p">(</span><span class="n">ax</span><span class="p">,</span> <span class="n">tz</span><span class="p">,</span> <span class="n">ambiguous</span><span class="p">,</span> <span class="n">nonexistent</span><span class="p">):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">ax</span><span class="p">,</span> <span class="s2">&quot;tz_localize&quot;</span><span class="p">):</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">ax</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">ax_name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_axis_name</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span>
                    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                        <span class="s2">&quot;</span><span class="si">%s</span><span class="s2"> is not a valid DatetimeIndex or &quot;</span> <span class="s2">&quot;PeriodIndex&quot;</span> <span class="o">%</span> <span class="n">ax_name</span>
                    <span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">ax</span> <span class="o">=</span> <span class="n">DatetimeIndex</span><span class="p">([],</span> <span class="n">tz</span><span class="o">=</span><span class="n">tz</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">ax</span> <span class="o">=</span> <span class="n">ax</span><span class="o">.</span><span class="n">tz_localize</span><span class="p">(</span><span class="n">tz</span><span class="p">,</span> <span class="n">ambiguous</span><span class="o">=</span><span class="n">ambiguous</span><span class="p">,</span> <span class="n">nonexistent</span><span class="o">=</span><span class="n">nonexistent</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">ax</span>

        <span class="c1"># if a level is given it must be a MultiIndex level or</span>
        <span class="c1"># equivalent to the axis name</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ax</span><span class="p">,</span> <span class="n">MultiIndex</span><span class="p">):</span>
            <span class="n">level</span> <span class="o">=</span> <span class="n">ax</span><span class="o">.</span><span class="n">_get_level_number</span><span class="p">(</span><span class="n">level</span><span class="p">)</span>
            <span class="n">new_level</span> <span class="o">=</span> <span class="n">_tz_localize</span><span class="p">(</span><span class="n">ax</span><span class="o">.</span><span class="n">levels</span><span class="p">[</span><span class="n">level</span><span class="p">],</span> <span class="n">tz</span><span class="p">,</span> <span class="n">ambiguous</span><span class="p">,</span> <span class="n">nonexistent</span><span class="p">)</span>
            <span class="n">ax</span> <span class="o">=</span> <span class="n">ax</span><span class="o">.</span><span class="n">set_levels</span><span class="p">(</span><span class="n">new_level</span><span class="p">,</span> <span class="n">level</span><span class="o">=</span><span class="n">level</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">level</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">ax</span><span class="o">.</span><span class="n">name</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;The level </span><span class="si">{0}</span><span class="s2"> is not valid&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">level</span><span class="p">))</span>
            <span class="n">ax</span> <span class="o">=</span> <span class="n">_tz_localize</span><span class="p">(</span><span class="n">ax</span><span class="p">,</span> <span class="n">tz</span><span class="p">,</span> <span class="n">ambiguous</span><span class="p">,</span> <span class="n">nonexistent</span><span class="p">)</span>

        <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_constructor</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="n">copy</span><span class="p">)</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">set_axis</span><span class="p">(</span><span class="n">ax</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">result</span><span class="o">.</span><span class="n">__finalize__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="c1"># ----------------------------------------------------------------------</span>
    <span class="c1"># Numeric Methods</span>
    <span class="k">def</span> <span class="nf">abs</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a Series/DataFrame with absolute numeric value of each element.</span>

<span class="sd">        This function only applies to elements that are all numeric.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        abs</span>
<span class="sd">            Series/DataFrame containing the absolute value of each element.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        numpy.absolute : Calculate the absolute value element-wise.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        For ``complex`` inputs, ``1.2 + 1j``, the absolute value is</span>
<span class="sd">        :math:`\\sqrt{ a^2 + b^2 }`.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        Absolute numeric values in a Series.</span>

<span class="sd">        &gt;&gt;&gt; s = pd.Series([-1.10, 2, -3.33, 4])</span>
<span class="sd">        &gt;&gt;&gt; s.abs()</span>
<span class="sd">        0    1.10</span>
<span class="sd">        1    2.00</span>
<span class="sd">        2    3.33</span>
<span class="sd">        3    4.00</span>
<span class="sd">        dtype: float64</span>

<span class="sd">        Absolute numeric values in a Series with complex numbers.</span>

<span class="sd">        &gt;&gt;&gt; s = pd.Series([1.2 + 1j])</span>
<span class="sd">        &gt;&gt;&gt; s.abs()</span>
<span class="sd">        0    1.56205</span>
<span class="sd">        dtype: float64</span>

<span class="sd">        Absolute numeric values in a Series with a Timedelta element.</span>

<span class="sd">        &gt;&gt;&gt; s = pd.Series([pd.Timedelta(&#39;1 days&#39;)])</span>
<span class="sd">        &gt;&gt;&gt; s.abs()</span>
<span class="sd">        0   1 days</span>
<span class="sd">        dtype: timedelta64[ns]</span>

<span class="sd">        Select rows with data closest to certain value using argsort (from</span>
<span class="sd">        `StackOverflow &lt;https://stackoverflow.com/a/17758115&gt;`__).</span>

<span class="sd">        &gt;&gt;&gt; df = pd.DataFrame({</span>
<span class="sd">        ...     &#39;a&#39;: [4, 5, 6, 7],</span>
<span class="sd">        ...     &#39;b&#39;: [10, 20, 30, 40],</span>
<span class="sd">        ...     &#39;c&#39;: [100, 50, -30, -50]</span>
<span class="sd">        ... })</span>
<span class="sd">        &gt;&gt;&gt; df</span>
<span class="sd">             a    b    c</span>
<span class="sd">        0    4   10  100</span>
<span class="sd">        1    5   20   50</span>
<span class="sd">        2    6   30  -30</span>
<span class="sd">        3    7   40  -50</span>
<span class="sd">        &gt;&gt;&gt; df.loc[(df.c - 43).abs().argsort()]</span>
<span class="sd">             a    b    c</span>
<span class="sd">        1    5   20   50</span>
<span class="sd">        0    4   10  100</span>
<span class="sd">        2    6   30  -30</span>
<span class="sd">        3    7   40  -50</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">describe</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">percentiles</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">include</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">exclude</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generate descriptive statistics that summarize the central tendency,</span>
<span class="sd">        dispersion and shape of a dataset&#39;s distribution, excluding</span>
<span class="sd">        ``NaN`` values.</span>

<span class="sd">        Analyzes both numeric and object series, as well</span>
<span class="sd">        as ``DataFrame`` column sets of mixed data types. The output</span>
<span class="sd">        will vary depending on what is provided. Refer to the notes</span>
<span class="sd">        below for more detail.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        percentiles : list-like of numbers, optional</span>
<span class="sd">            The percentiles to include in the output. All should</span>
<span class="sd">            fall between 0 and 1. The default is</span>
<span class="sd">            ``[.25, .5, .75]``, which returns the 25th, 50th, and</span>
<span class="sd">            75th percentiles.</span>
<span class="sd">        include : &#39;all&#39;, list-like of dtypes or None (default), optional</span>
<span class="sd">            A white list of data types to include in the result. Ignored</span>
<span class="sd">            for ``Series``. Here are the options:</span>

<span class="sd">            - &#39;all&#39; : All columns of the input will be included in the output.</span>
<span class="sd">            - A list-like of dtypes : Limits the results to the</span>
<span class="sd">              provided data types.</span>
<span class="sd">              To limit the result to numeric types submit</span>
<span class="sd">              ``numpy.number``. To limit it instead to object columns submit</span>
<span class="sd">              the ``numpy.object`` data type. Strings</span>
<span class="sd">              can also be used in the style of</span>
<span class="sd">              ``select_dtypes`` (e.g. ``df.describe(include=[&#39;O&#39;])``). To</span>
<span class="sd">              select pandas categorical columns, use ``&#39;category&#39;``</span>
<span class="sd">            - None (default) : The result will include all numeric columns.</span>
<span class="sd">        exclude : list-like of dtypes or None (default), optional,</span>
<span class="sd">            A black list of data types to omit from the result. Ignored</span>
<span class="sd">            for ``Series``. Here are the options:</span>

<span class="sd">            - A list-like of dtypes : Excludes the provided data types</span>
<span class="sd">              from the result. To exclude numeric types submit</span>
<span class="sd">              ``numpy.number``. To exclude object columns submit the data</span>
<span class="sd">              type ``numpy.object``. Strings can also be used in the style of</span>
<span class="sd">              ``select_dtypes`` (e.g. ``df.describe(include=[&#39;O&#39;])``). To</span>
<span class="sd">              exclude pandas categorical columns, use ``&#39;category&#39;``</span>
<span class="sd">            - None (default) : The result will exclude nothing.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Series or DataFrame</span>
<span class="sd">            Summary statistics of the Series or Dataframe provided.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        DataFrame.count: Count number of non-NA/null observations.</span>
<span class="sd">        DataFrame.max: Maximum of the values in the object.</span>
<span class="sd">        DataFrame.min: Minimum of the values in the object.</span>
<span class="sd">        DataFrame.mean: Mean of the values.</span>
<span class="sd">        DataFrame.std: Standard deviation of the observations.</span>
<span class="sd">        DataFrame.select_dtypes: Subset of a DataFrame including/excluding</span>
<span class="sd">            columns based on their dtype.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        For numeric data, the result&#39;s index will include ``count``,</span>
<span class="sd">        ``mean``, ``std``, ``min``, ``max`` as well as lower, ``50`` and</span>
<span class="sd">        upper percentiles. By default the lower percentile is ``25`` and the</span>
<span class="sd">        upper percentile is ``75``. The ``50`` percentile is the</span>
<span class="sd">        same as the median.</span>

<span class="sd">        For object data (e.g. strings or timestamps), the result&#39;s index</span>
<span class="sd">        will include ``count``, ``unique``, ``top``, and ``freq``. The ``top``</span>
<span class="sd">        is the most common value. The ``freq`` is the most common value&#39;s</span>
<span class="sd">        frequency. Timestamps also include the ``first`` and ``last`` items.</span>

<span class="sd">        If multiple object values have the highest count, then the</span>
<span class="sd">        ``count`` and ``top`` results will be arbitrarily chosen from</span>
<span class="sd">        among those with the highest count.</span>

<span class="sd">        For mixed data types provided via a ``DataFrame``, the default is to</span>
<span class="sd">        return only an analysis of numeric columns. If the dataframe consists</span>
<span class="sd">        only of object and categorical data without any numeric columns, the</span>
<span class="sd">        default is to return an analysis of both the object and categorical</span>
<span class="sd">        columns. If ``include=&#39;all&#39;`` is provided as an option, the result</span>
<span class="sd">        will include a union of attributes of each type.</span>

<span class="sd">        The `include` and `exclude` parameters can be used to limit</span>
<span class="sd">        which columns in a ``DataFrame`` are analyzed for the output.</span>
<span class="sd">        The parameters are ignored when analyzing a ``Series``.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        Describing a numeric ``Series``.</span>

<span class="sd">        &gt;&gt;&gt; s = pd.Series([1, 2, 3])</span>
<span class="sd">        &gt;&gt;&gt; s.describe()</span>
<span class="sd">        count    3.0</span>
<span class="sd">        mean     2.0</span>
<span class="sd">        std      1.0</span>
<span class="sd">        min      1.0</span>
<span class="sd">        25%      1.5</span>
<span class="sd">        50%      2.0</span>
<span class="sd">        75%      2.5</span>
<span class="sd">        max      3.0</span>
<span class="sd">        dtype: float64</span>

<span class="sd">        Describing a categorical ``Series``.</span>

<span class="sd">        &gt;&gt;&gt; s = pd.Series([&#39;a&#39;, &#39;a&#39;, &#39;b&#39;, &#39;c&#39;])</span>
<span class="sd">        &gt;&gt;&gt; s.describe()</span>
<span class="sd">        count     4</span>
<span class="sd">        unique    3</span>
<span class="sd">        top       a</span>
<span class="sd">        freq      2</span>
<span class="sd">        dtype: object</span>

<span class="sd">        Describing a timestamp ``Series``.</span>

<span class="sd">        &gt;&gt;&gt; s = pd.Series([</span>
<span class="sd">        ...   np.datetime64(&quot;2000-01-01&quot;),</span>
<span class="sd">        ...   np.datetime64(&quot;2010-01-01&quot;),</span>
<span class="sd">        ...   np.datetime64(&quot;2010-01-01&quot;)</span>
<span class="sd">        ... ])</span>
<span class="sd">        &gt;&gt;&gt; s.describe()</span>
<span class="sd">        count                       3</span>
<span class="sd">        unique                      2</span>
<span class="sd">        top       2010-01-01 00:00:00</span>
<span class="sd">        freq                        2</span>
<span class="sd">        first     2000-01-01 00:00:00</span>
<span class="sd">        last      2010-01-01 00:00:00</span>
<span class="sd">        dtype: object</span>

<span class="sd">        Describing a ``DataFrame``. By default only numeric fields</span>
<span class="sd">        are returned.</span>

<span class="sd">        &gt;&gt;&gt; df = pd.DataFrame({&#39;categorical&#39;: pd.Categorical([&#39;d&#39;,&#39;e&#39;,&#39;f&#39;]),</span>
<span class="sd">        ...                    &#39;numeric&#39;: [1, 2, 3],</span>
<span class="sd">        ...                    &#39;object&#39;: [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]</span>
<span class="sd">        ...                   })</span>
<span class="sd">        &gt;&gt;&gt; df.describe()</span>
<span class="sd">               numeric</span>
<span class="sd">        count      3.0</span>
<span class="sd">        mean       2.0</span>
<span class="sd">        std        1.0</span>
<span class="sd">        min        1.0</span>
<span class="sd">        25%        1.5</span>
<span class="sd">        50%        2.0</span>
<span class="sd">        75%        2.5</span>
<span class="sd">        max        3.0</span>

<span class="sd">        Describing all columns of a ``DataFrame`` regardless of data type.</span>

<span class="sd">        &gt;&gt;&gt; df.describe(include=&#39;all&#39;)</span>
<span class="sd">                categorical  numeric object</span>
<span class="sd">        count            3      3.0      3</span>
<span class="sd">        unique           3      NaN      3</span>
<span class="sd">        top              f      NaN      c</span>
<span class="sd">        freq             1      NaN      1</span>
<span class="sd">        mean           NaN      2.0    NaN</span>
<span class="sd">        std            NaN      1.0    NaN</span>
<span class="sd">        min            NaN      1.0    NaN</span>
<span class="sd">        25%            NaN      1.5    NaN</span>
<span class="sd">        50%            NaN      2.0    NaN</span>
<span class="sd">        75%            NaN      2.5    NaN</span>
<span class="sd">        max            NaN      3.0    NaN</span>

<span class="sd">        Describing a column from a ``DataFrame`` by accessing it as</span>
<span class="sd">        an attribute.</span>

<span class="sd">        &gt;&gt;&gt; df.numeric.describe()</span>
<span class="sd">        count    3.0</span>
<span class="sd">        mean     2.0</span>
<span class="sd">        std      1.0</span>
<span class="sd">        min      1.0</span>
<span class="sd">        25%      1.5</span>
<span class="sd">        50%      2.0</span>
<span class="sd">        75%      2.5</span>
<span class="sd">        max      3.0</span>
<span class="sd">        Name: numeric, dtype: float64</span>

<span class="sd">        Including only numeric columns in a ``DataFrame`` description.</span>

<span class="sd">        &gt;&gt;&gt; df.describe(include=[np.number])</span>
<span class="sd">               numeric</span>
<span class="sd">        count      3.0</span>
<span class="sd">        mean       2.0</span>
<span class="sd">        std        1.0</span>
<span class="sd">        min        1.0</span>
<span class="sd">        25%        1.5</span>
<span class="sd">        50%        2.0</span>
<span class="sd">        75%        2.5</span>
<span class="sd">        max        3.0</span>

<span class="sd">        Including only string columns in a ``DataFrame`` description.</span>

<span class="sd">        &gt;&gt;&gt; df.describe(include=[np.object])</span>
<span class="sd">               object</span>
<span class="sd">        count       3</span>
<span class="sd">        unique      3</span>
<span class="sd">        top         c</span>
<span class="sd">        freq        1</span>

<span class="sd">        Including only categorical columns from a ``DataFrame`` description.</span>

<span class="sd">        &gt;&gt;&gt; df.describe(include=[&#39;category&#39;])</span>
<span class="sd">               categorical</span>
<span class="sd">        count            3</span>
<span class="sd">        unique           3</span>
<span class="sd">        top              f</span>
<span class="sd">        freq             1</span>

<span class="sd">        Excluding numeric columns from a ``DataFrame`` description.</span>

<span class="sd">        &gt;&gt;&gt; df.describe(exclude=[np.number])</span>
<span class="sd">               categorical object</span>
<span class="sd">        count            3      3</span>
<span class="sd">        unique           3      3</span>
<span class="sd">        top              f      c</span>
<span class="sd">        freq             1      1</span>

<span class="sd">        Excluding object columns from a ``DataFrame`` description.</span>

<span class="sd">        &gt;&gt;&gt; df.describe(exclude=[np.object])</span>
<span class="sd">               categorical  numeric</span>
<span class="sd">        count            3      3.0</span>
<span class="sd">        unique           3      NaN</span>
<span class="sd">        top              f      NaN</span>
<span class="sd">        freq             1      NaN</span>
<span class="sd">        mean           NaN      2.0</span>
<span class="sd">        std            NaN      1.0</span>
<span class="sd">        min            NaN      1.0</span>
<span class="sd">        25%            NaN      1.5</span>
<span class="sd">        50%            NaN      2.0</span>
<span class="sd">        75%            NaN      2.5</span>
<span class="sd">        max            NaN      3.0</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">2</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Cannot describe a DataFrame without columns&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">percentiles</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># explicit conversion of `percentiles` to list</span>
            <span class="n">percentiles</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">percentiles</span><span class="p">)</span>

            <span class="c1"># get them all to be in [0, 1]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_check_percentile</span><span class="p">(</span><span class="n">percentiles</span><span class="p">)</span>

            <span class="c1"># median should always be included</span>
            <span class="k">if</span> <span class="mf">0.5</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">percentiles</span><span class="p">:</span>
                <span class="n">percentiles</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mf">0.5</span><span class="p">)</span>
            <span class="n">percentiles</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">percentiles</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">percentiles</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">0.25</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.75</span><span class="p">])</span>

        <span class="c1"># sort and check for duplicates</span>
        <span class="n">unique_pcts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">percentiles</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">unique_pcts</span><span class="p">)</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">percentiles</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;percentiles cannot contain duplicates&quot;</span><span class="p">)</span>
        <span class="n">percentiles</span> <span class="o">=</span> <span class="n">unique_pcts</span>

        <span class="n">formatted_percentiles</span> <span class="o">=</span> <span class="n">format_percentiles</span><span class="p">(</span><span class="n">percentiles</span><span class="p">)</span>

        <span class="k">def</span> <span class="nf">describe_numeric_1d</span><span class="p">(</span><span class="n">series</span><span class="p">):</span>
            <span class="n">stat_index</span> <span class="o">=</span> <span class="p">(</span>
                <span class="p">[</span><span class="s2">&quot;count&quot;</span><span class="p">,</span> <span class="s2">&quot;mean&quot;</span><span class="p">,</span> <span class="s2">&quot;std&quot;</span><span class="p">,</span> <span class="s2">&quot;min&quot;</span><span class="p">]</span> <span class="o">+</span> <span class="n">formatted_percentiles</span> <span class="o">+</span> <span class="p">[</span><span class="s2">&quot;max&quot;</span><span class="p">]</span>
            <span class="p">)</span>
            <span class="n">d</span> <span class="o">=</span> <span class="p">(</span>
                <span class="p">[</span><span class="n">series</span><span class="o">.</span><span class="n">count</span><span class="p">(),</span> <span class="n">series</span><span class="o">.</span><span class="n">mean</span><span class="p">(),</span> <span class="n">series</span><span class="o">.</span><span class="n">std</span><span class="p">(),</span> <span class="n">series</span><span class="o">.</span><span class="n">min</span><span class="p">()]</span>
                <span class="o">+</span> <span class="n">series</span><span class="o">.</span><span class="n">quantile</span><span class="p">(</span><span class="n">percentiles</span><span class="p">)</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
                <span class="o">+</span> <span class="p">[</span><span class="n">series</span><span class="o">.</span><span class="n">max</span><span class="p">()]</span>
            <span class="p">)</span>
            <span class="k">return</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="n">stat_index</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">series</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>

        <span class="k">def</span> <span class="nf">describe_categorical_1d</span><span class="p">(</span><span class="n">data</span><span class="p">):</span>
            <span class="n">names</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;count&quot;</span><span class="p">,</span> <span class="s2">&quot;unique&quot;</span><span class="p">]</span>
            <span class="n">objcounts</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">value_counts</span><span class="p">()</span>
            <span class="n">count_unique</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">objcounts</span><span class="p">[</span><span class="n">objcounts</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">])</span>
            <span class="n">result</span> <span class="o">=</span> <span class="p">[</span><span class="n">data</span><span class="o">.</span><span class="n">count</span><span class="p">(),</span> <span class="n">count_unique</span><span class="p">]</span>
            <span class="n">dtype</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">if</span> <span class="n">result</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">top</span><span class="p">,</span> <span class="n">freq</span> <span class="o">=</span> <span class="n">objcounts</span><span class="o">.</span><span class="n">index</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">objcounts</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

                <span class="k">if</span> <span class="n">is_datetime64_any_dtype</span><span class="p">(</span><span class="n">data</span><span class="p">):</span>
                    <span class="n">tz</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">dt</span><span class="o">.</span><span class="n">tz</span>
                    <span class="n">asint</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">dropna</span><span class="p">()</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="s2">&quot;i8&quot;</span><span class="p">)</span>
                    <span class="n">top</span> <span class="o">=</span> <span class="n">Timestamp</span><span class="p">(</span><span class="n">top</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">top</span><span class="o">.</span><span class="n">tzinfo</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">tz</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="c1"># Don&#39;t tz_localize(None) if key is already tz-aware</span>
                        <span class="n">top</span> <span class="o">=</span> <span class="n">top</span><span class="o">.</span><span class="n">tz_convert</span><span class="p">(</span><span class="n">tz</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">top</span> <span class="o">=</span> <span class="n">top</span><span class="o">.</span><span class="n">tz_localize</span><span class="p">(</span><span class="n">tz</span><span class="p">)</span>
                    <span class="n">names</span> <span class="o">+=</span> <span class="p">[</span><span class="s2">&quot;top&quot;</span><span class="p">,</span> <span class="s2">&quot;freq&quot;</span><span class="p">,</span> <span class="s2">&quot;first&quot;</span><span class="p">,</span> <span class="s2">&quot;last&quot;</span><span class="p">]</span>
                    <span class="n">result</span> <span class="o">+=</span> <span class="p">[</span>
                        <span class="n">top</span><span class="p">,</span>
                        <span class="n">freq</span><span class="p">,</span>
                        <span class="n">Timestamp</span><span class="p">(</span><span class="n">asint</span><span class="o">.</span><span class="n">min</span><span class="p">(),</span> <span class="n">tz</span><span class="o">=</span><span class="n">tz</span><span class="p">),</span>
                        <span class="n">Timestamp</span><span class="p">(</span><span class="n">asint</span><span class="o">.</span><span class="n">max</span><span class="p">(),</span> <span class="n">tz</span><span class="o">=</span><span class="n">tz</span><span class="p">),</span>
                    <span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">names</span> <span class="o">+=</span> <span class="p">[</span><span class="s2">&quot;top&quot;</span><span class="p">,</span> <span class="s2">&quot;freq&quot;</span><span class="p">]</span>
                    <span class="n">result</span> <span class="o">+=</span> <span class="p">[</span><span class="n">top</span><span class="p">,</span> <span class="n">freq</span><span class="p">]</span>

            <span class="c1"># If the DataFrame is empty, set &#39;top&#39; and &#39;freq&#39; to None</span>
            <span class="c1"># to maintain output shape consistency</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">names</span> <span class="o">+=</span> <span class="p">[</span><span class="s2">&quot;top&quot;</span><span class="p">,</span> <span class="s2">&quot;freq&quot;</span><span class="p">]</span>
                <span class="n">result</span> <span class="o">+=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">]</span>
                <span class="n">dtype</span> <span class="o">=</span> <span class="s2">&quot;object&quot;</span>

            <span class="k">return</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="n">names</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">data</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>

        <span class="k">def</span> <span class="nf">describe_1d</span><span class="p">(</span><span class="n">data</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">is_bool_dtype</span><span class="p">(</span><span class="n">data</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">describe_categorical_1d</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">is_numeric_dtype</span><span class="p">(</span><span class="n">data</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">describe_numeric_1d</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">is_timedelta64_dtype</span><span class="p">(</span><span class="n">data</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">describe_numeric_1d</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">describe_categorical_1d</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">describe_1d</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">elif</span> <span class="p">(</span><span class="n">include</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">exclude</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">):</span>
            <span class="c1"># when some numerics are found, keep only numerics</span>
            <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">select_dtypes</span><span class="p">(</span><span class="n">include</span><span class="o">=</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">number</span><span class="p">])</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">columns</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="k">elif</span> <span class="n">include</span> <span class="o">==</span> <span class="s2">&quot;all&quot;</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">exclude</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;exclude must be None when include is &#39;all&#39;&quot;</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
            <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">select_dtypes</span><span class="p">(</span><span class="n">include</span><span class="o">=</span><span class="n">include</span><span class="p">,</span> <span class="n">exclude</span><span class="o">=</span><span class="n">exclude</span><span class="p">)</span>

        <span class="n">ldesc</span> <span class="o">=</span> <span class="p">[</span><span class="n">describe_1d</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">data</span><span class="o">.</span><span class="n">items</span><span class="p">()]</span>
        <span class="c1"># set a convenient order for rows</span>
        <span class="n">names</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">ldesc_indexes</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">((</span><span class="n">x</span><span class="o">.</span><span class="n">index</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">ldesc</span><span class="p">),</span> <span class="n">key</span><span class="o">=</span><span class="nb">len</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">idxnames</span> <span class="ow">in</span> <span class="n">ldesc_indexes</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">idxnames</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">names</span><span class="p">:</span>
                    <span class="n">names</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>

        <span class="n">d</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">([</span><span class="n">x</span><span class="o">.</span><span class="n">reindex</span><span class="p">(</span><span class="n">names</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">ldesc</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">sort</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">d</span><span class="o">.</span><span class="n">columns</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">d</span>

    <span class="k">def</span> <span class="nf">_check_percentile</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">q</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Validate percentiles (used by describe and quantile).</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;percentiles should all be in the interval [0, 1]. &quot;</span> <span class="s2">&quot;Try </span><span class="si">{0}</span><span class="s2"> instead.&quot;</span>
        <span class="n">q</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">q</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">q</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">q</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">q</span> <span class="o">/</span> <span class="mf">100.0</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">all</span><span class="p">(</span><span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">qs</span> <span class="o">&lt;=</span> <span class="mi">1</span> <span class="k">for</span> <span class="n">qs</span> <span class="ow">in</span> <span class="n">q</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">q</span> <span class="o">/</span> <span class="mf">100.0</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">q</span>

    <span class="n">_shared_docs</span><span class="p">[</span>
        <span class="s2">&quot;pct_change&quot;</span>
    <span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;</span>
<span class="s2">        Percentage change between the current and a prior element.</span>

<span class="s2">        Computes the percentage change from the immediately previous row by</span>
<span class="s2">        default. This is useful in comparing the percentage of change in a time</span>
<span class="s2">        series of elements.</span>

<span class="s2">        Parameters</span>
<span class="s2">        ----------</span>
<span class="s2">        periods : int, default 1</span>
<span class="s2">            Periods to shift for forming percent change.</span>
<span class="s2">        fill_method : str, default &#39;pad&#39;</span>
<span class="s2">            How to handle NAs before computing percent changes.</span>
<span class="s2">        limit : int, default None</span>
<span class="s2">            The number of consecutive NAs to fill before stopping.</span>
<span class="s2">        freq : DateOffset, timedelta, or offset alias string, optional</span>
<span class="s2">            Increment to use from time series API (e.g. &#39;M&#39; or BDay()).</span>
<span class="s2">        **kwargs</span>
<span class="s2">            Additional keyword arguments are passed into</span>
<span class="s2">            `DataFrame.shift` or `Series.shift`.</span>

<span class="s2">        Returns</span>
<span class="s2">        -------</span>
<span class="s2">        chg : Series or DataFrame</span>
<span class="s2">            The same type as the calling object.</span>

<span class="s2">        See Also</span>
<span class="s2">        --------</span>
<span class="s2">        Series.diff : Compute the difference of two elements in a Series.</span>
<span class="s2">        DataFrame.diff : Compute the difference of two elements in a DataFrame.</span>
<span class="s2">        Series.shift : Shift the index by some number of periods.</span>
<span class="s2">        DataFrame.shift : Shift the index by some number of periods.</span>

<span class="s2">        Examples</span>
<span class="s2">        --------</span>
<span class="s2">        **Series**</span>

<span class="s2">        &gt;&gt;&gt; s = pd.Series([90, 91, 85])</span>
<span class="s2">        &gt;&gt;&gt; s</span>
<span class="s2">        0    90</span>
<span class="s2">        1    91</span>
<span class="s2">        2    85</span>
<span class="s2">        dtype: int64</span>

<span class="s2">        &gt;&gt;&gt; s.pct_change()</span>
<span class="s2">        0         NaN</span>
<span class="s2">        1    0.011111</span>
<span class="s2">        2   -0.065934</span>
<span class="s2">        dtype: float64</span>

<span class="s2">        &gt;&gt;&gt; s.pct_change(periods=2)</span>
<span class="s2">        0         NaN</span>
<span class="s2">        1         NaN</span>
<span class="s2">        2   -0.055556</span>
<span class="s2">        dtype: float64</span>

<span class="s2">        See the percentage change in a Series where filling NAs with last</span>
<span class="s2">        valid observation forward to next valid.</span>

<span class="s2">        &gt;&gt;&gt; s = pd.Series([90, 91, None, 85])</span>
<span class="s2">        &gt;&gt;&gt; s</span>
<span class="s2">        0    90.0</span>
<span class="s2">        1    91.0</span>
<span class="s2">        2     NaN</span>
<span class="s2">        3    85.0</span>
<span class="s2">        dtype: float64</span>

<span class="s2">        &gt;&gt;&gt; s.pct_change(fill_method=&#39;ffill&#39;)</span>
<span class="s2">        0         NaN</span>
<span class="s2">        1    0.011111</span>
<span class="s2">        2    0.000000</span>
<span class="s2">        3   -0.065934</span>
<span class="s2">        dtype: float64</span>

<span class="s2">        **DataFrame**</span>

<span class="s2">        Percentage change in French franc, Deutsche Mark, and Italian lira from</span>
<span class="s2">        1980-01-01 to 1980-03-01.</span>

<span class="s2">        &gt;&gt;&gt; df = pd.DataFrame({</span>
<span class="s2">        ...     &#39;FR&#39;: [4.0405, 4.0963, 4.3149],</span>
<span class="s2">        ...     &#39;GR&#39;: [1.7246, 1.7482, 1.8519],</span>
<span class="s2">        ...     &#39;IT&#39;: [804.74, 810.01, 860.13]},</span>
<span class="s2">        ...     index=[&#39;1980-01-01&#39;, &#39;1980-02-01&#39;, &#39;1980-03-01&#39;])</span>
<span class="s2">        &gt;&gt;&gt; df</span>
<span class="s2">                        FR      GR      IT</span>
<span class="s2">        1980-01-01  4.0405  1.7246  804.74</span>
<span class="s2">        1980-02-01  4.0963  1.7482  810.01</span>
<span class="s2">        1980-03-01  4.3149  1.8519  860.13</span>

<span class="s2">        &gt;&gt;&gt; df.pct_change()</span>
<span class="s2">                          FR        GR        IT</span>
<span class="s2">        1980-01-01       NaN       NaN       NaN</span>
<span class="s2">        1980-02-01  0.013810  0.013684  0.006549</span>
<span class="s2">        1980-03-01  0.053365  0.059318  0.061876</span>

<span class="s2">        Percentage of change in GOOG and APPL stock volume. Shows computing</span>
<span class="s2">        the percentage change between columns.</span>

<span class="s2">        &gt;&gt;&gt; df = pd.DataFrame({</span>
<span class="s2">        ...     &#39;2016&#39;: [1769950, 30586265],</span>
<span class="s2">        ...     &#39;2015&#39;: [1500923, 40912316],</span>
<span class="s2">        ...     &#39;2014&#39;: [1371819, 41403351]},</span>
<span class="s2">        ...     index=[&#39;GOOG&#39;, &#39;APPL&#39;])</span>
<span class="s2">        &gt;&gt;&gt; df</span>
<span class="s2">                  2016      2015      2014</span>
<span class="s2">        GOOG   1769950   1500923   1371819</span>
<span class="s2">        APPL  30586265  40912316  41403351</span>

<span class="s2">        &gt;&gt;&gt; df.pct_change(axis=&#39;columns&#39;)</span>
<span class="s2">              2016      2015      2014</span>
<span class="s2">        GOOG   NaN -0.151997 -0.086016</span>
<span class="s2">        APPL   NaN  0.337604  0.012002</span>
<span class="s2">        &quot;&quot;&quot;</span>

    <span class="nd">@Appender</span><span class="p">(</span><span class="n">_shared_docs</span><span class="p">[</span><span class="s2">&quot;pct_change&quot;</span><span class="p">]</span> <span class="o">%</span> <span class="n">_shared_doc_kwargs</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">pct_change</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">periods</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">fill_method</span><span class="o">=</span><span class="s2">&quot;pad&quot;</span><span class="p">,</span> <span class="n">limit</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">freq</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="c1"># TODO: Not sure if above is correct - need someone to confirm.</span>
        <span class="n">axis</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_axis_number</span><span class="p">(</span><span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;axis&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_stat_axis_name</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">fill_method</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fillna</span><span class="p">(</span><span class="n">method</span><span class="o">=</span><span class="n">fill_method</span><span class="p">,</span> <span class="n">limit</span><span class="o">=</span><span class="n">limit</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span>

        <span class="n">rs</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">div</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">shift</span><span class="p">(</span><span class="n">periods</span><span class="o">=</span><span class="n">periods</span><span class="p">,</span> <span class="n">freq</span><span class="o">=</span><span class="n">freq</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">))</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="n">rs</span> <span class="o">=</span> <span class="n">rs</span><span class="o">.</span><span class="n">reindex_like</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">freq</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">mask</span> <span class="o">=</span> <span class="n">isna</span><span class="p">(</span><span class="n">com</span><span class="o">.</span><span class="n">values_from_object</span><span class="p">(</span><span class="n">data</span><span class="p">))</span>
            <span class="n">np</span><span class="o">.</span><span class="n">putmask</span><span class="p">(</span><span class="n">rs</span><span class="o">.</span><span class="n">values</span><span class="p">,</span> <span class="n">mask</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">rs</span>

    <span class="k">def</span> <span class="nf">_agg_by_level</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">level</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">skipna</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">axis</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Must specify &#39;axis&#39; when aggregating by level.&quot;</span><span class="p">)</span>
        <span class="n">grouped</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="n">level</span><span class="o">=</span><span class="n">level</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">sort</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">grouped</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span> <span class="ow">and</span> <span class="n">skipna</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">grouped</span><span class="p">,</span> <span class="n">name</span><span class="p">)(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="n">axis</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_axis_number</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span>
        <span class="n">method</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">),</span> <span class="n">name</span><span class="p">)</span>
        <span class="n">applyf</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">method</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">skipna</span><span class="o">=</span><span class="n">skipna</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">grouped</span><span class="o">.</span><span class="n">aggregate</span><span class="p">(</span><span class="n">applyf</span><span class="p">)</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">_add_numeric_operations</span><span class="p">(</span><span class="bp">cls</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Add the operations to the cls; evaluate the doc strings again</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">axis_descr</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">name2</span> <span class="o">=</span> <span class="n">_doc_parms</span><span class="p">(</span><span class="bp">cls</span><span class="p">)</span>

        <span class="bp">cls</span><span class="o">.</span><span class="n">any</span> <span class="o">=</span> <span class="n">_make_logical_function</span><span class="p">(</span>
            <span class="bp">cls</span><span class="p">,</span>
            <span class="s2">&quot;any&quot;</span><span class="p">,</span>
            <span class="n">name</span><span class="p">,</span>
            <span class="n">name2</span><span class="p">,</span>
            <span class="n">axis_descr</span><span class="p">,</span>
            <span class="n">_any_desc</span><span class="p">,</span>
            <span class="n">nanops</span><span class="o">.</span><span class="n">nanany</span><span class="p">,</span>
            <span class="n">_any_see_also</span><span class="p">,</span>
            <span class="n">_any_examples</span><span class="p">,</span>
            <span class="n">empty_value</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="bp">cls</span><span class="o">.</span><span class="n">all</span> <span class="o">=</span> <span class="n">_make_logical_function</span><span class="p">(</span>
            <span class="bp">cls</span><span class="p">,</span>
            <span class="s2">&quot;all&quot;</span><span class="p">,</span>
            <span class="n">name</span><span class="p">,</span>
            <span class="n">name2</span><span class="p">,</span>
            <span class="n">axis_descr</span><span class="p">,</span>
            <span class="n">_all_desc</span><span class="p">,</span>
            <span class="n">nanops</span><span class="o">.</span><span class="n">nanall</span><span class="p">,</span>
            <span class="n">_all_see_also</span><span class="p">,</span>
            <span class="n">_all_examples</span><span class="p">,</span>
            <span class="n">empty_value</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="nd">@Substitution</span><span class="p">(</span>
            <span class="n">desc</span><span class="o">=</span><span class="s2">&quot;Return the mean absolute deviation of the values &quot;</span>
            <span class="s2">&quot;for the requested axis.&quot;</span><span class="p">,</span>
            <span class="n">name1</span><span class="o">=</span><span class="n">name</span><span class="p">,</span>
            <span class="n">name2</span><span class="o">=</span><span class="n">name2</span><span class="p">,</span>
            <span class="n">axis_descr</span><span class="o">=</span><span class="n">axis_descr</span><span class="p">,</span>
            <span class="n">min_count</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">,</span>
            <span class="n">see_also</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">,</span>
            <span class="n">examples</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="nd">@Appender</span><span class="p">(</span><span class="n">_num_doc</span><span class="p">)</span>
        <span class="k">def</span> <span class="nf">mad</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">skipna</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">level</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">skipna</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">skipna</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">if</span> <span class="n">axis</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">axis</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_stat_axis_number</span>
            <span class="k">if</span> <span class="n">level</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_agg_by_level</span><span class="p">(</span><span class="s2">&quot;mad&quot;</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">level</span><span class="o">=</span><span class="n">level</span><span class="p">,</span> <span class="n">skipna</span><span class="o">=</span><span class="n">skipna</span><span class="p">)</span>

            <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_numeric_data</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">axis</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">demeaned</span> <span class="o">=</span> <span class="n">data</span> <span class="o">-</span> <span class="n">data</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">demeaned</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">demeaned</span><span class="p">)</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">skipna</span><span class="o">=</span><span class="n">skipna</span><span class="p">)</span>

        <span class="bp">cls</span><span class="o">.</span><span class="n">mad</span> <span class="o">=</span> <span class="n">mad</span>

        <span class="bp">cls</span><span class="o">.</span><span class="n">sem</span> <span class="o">=</span> <span class="n">_make_stat_function_ddof</span><span class="p">(</span>
            <span class="bp">cls</span><span class="p">,</span>
            <span class="s2">&quot;sem&quot;</span><span class="p">,</span>
            <span class="n">name</span><span class="p">,</span>
            <span class="n">name2</span><span class="p">,</span>
            <span class="n">axis_descr</span><span class="p">,</span>
            <span class="s2">&quot;Return unbiased standard error of the mean over requested &quot;</span>
            <span class="s2">&quot;axis.</span><span class="se">\n\n</span><span class="s2">Normalized by N-1 by default. This can be changed &quot;</span>
            <span class="s2">&quot;using the ddof argument&quot;</span><span class="p">,</span>
            <span class="n">nanops</span><span class="o">.</span><span class="n">nansem</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="bp">cls</span><span class="o">.</span><span class="n">var</span> <span class="o">=</span> <span class="n">_make_stat_function_ddof</span><span class="p">(</span>
            <span class="bp">cls</span><span class="p">,</span>
            <span class="s2">&quot;var&quot;</span><span class="p">,</span>
            <span class="n">name</span><span class="p">,</span>
            <span class="n">name2</span><span class="p">,</span>
            <span class="n">axis_descr</span><span class="p">,</span>
            <span class="s2">&quot;Return unbiased variance over requested axis.</span><span class="se">\n\n</span><span class="s2">Normalized by &quot;</span>
            <span class="s2">&quot;N-1 by default. This can be changed using the ddof argument&quot;</span><span class="p">,</span>
            <span class="n">nanops</span><span class="o">.</span><span class="n">nanvar</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="bp">cls</span><span class="o">.</span><span class="n">std</span> <span class="o">=</span> <span class="n">_make_stat_function_ddof</span><span class="p">(</span>
            <span class="bp">cls</span><span class="p">,</span>
            <span class="s2">&quot;std&quot;</span><span class="p">,</span>
            <span class="n">name</span><span class="p">,</span>
            <span class="n">name2</span><span class="p">,</span>
            <span class="n">axis_descr</span><span class="p">,</span>
            <span class="s2">&quot;Return sample standard deviation over requested axis.&quot;</span>
            <span class="s2">&quot;</span><span class="se">\n\n</span><span class="s2">Normalized by N-1 by default. This can be changed using the &quot;</span>
            <span class="s2">&quot;ddof argument&quot;</span><span class="p">,</span>
            <span class="n">nanops</span><span class="o">.</span><span class="n">nanstd</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="nd">@Substitution</span><span class="p">(</span>
            <span class="n">desc</span><span class="o">=</span><span class="s2">&quot;Return the compound percentage of the values for &quot;</span>
            <span class="s2">&quot;the requested axis.</span><span class="se">\n\n</span><span class="s2">.. deprecated:: 0.25.0&quot;</span><span class="p">,</span>
            <span class="n">name1</span><span class="o">=</span><span class="n">name</span><span class="p">,</span>
            <span class="n">name2</span><span class="o">=</span><span class="n">name2</span><span class="p">,</span>
            <span class="n">axis_descr</span><span class="o">=</span><span class="n">axis_descr</span><span class="p">,</span>
            <span class="n">min_count</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">,</span>
            <span class="n">see_also</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">,</span>
            <span class="n">examples</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="nd">@Appender</span><span class="p">(</span><span class="n">_num_doc</span><span class="p">)</span>
        <span class="k">def</span> <span class="nf">compound</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">skipna</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">level</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span>
                <span class="s2">&quot;The &#39;compound&#39; method is deprecated and will be&quot;</span>
                <span class="s2">&quot;removed in a future version.&quot;</span>
            <span class="p">)</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="n">msg</span><span class="p">,</span> <span class="ne">FutureWarning</span><span class="p">,</span> <span class="n">stacklevel</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">skipna</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">skipna</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">return</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">skipna</span><span class="o">=</span><span class="n">skipna</span><span class="p">,</span> <span class="n">level</span><span class="o">=</span><span class="n">level</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>

        <span class="bp">cls</span><span class="o">.</span><span class="n">compound</span> <span class="o">=</span> <span class="n">compound</span>

        <span class="bp">cls</span><span class="o">.</span><span class="n">cummin</span> <span class="o">=</span> <span class="n">_make_cum_function</span><span class="p">(</span>
            <span class="bp">cls</span><span class="p">,</span>
            <span class="s2">&quot;cummin&quot;</span><span class="p">,</span>
            <span class="n">name</span><span class="p">,</span>
            <span class="n">name2</span><span class="p">,</span>
            <span class="n">axis_descr</span><span class="p">,</span>
            <span class="s2">&quot;minimum&quot;</span><span class="p">,</span>
            <span class="k">lambda</span> <span class="n">y</span><span class="p">,</span> <span class="n">axis</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">minimum</span><span class="o">.</span><span class="n">accumulate</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">axis</span><span class="p">),</span>
            <span class="s2">&quot;min&quot;</span><span class="p">,</span>
            <span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">,</span>
            <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span>
            <span class="n">_cummin_examples</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="bp">cls</span><span class="o">.</span><span class="n">cumsum</span> <span class="o">=</span> <span class="n">_make_cum_function</span><span class="p">(</span>
            <span class="bp">cls</span><span class="p">,</span>
            <span class="s2">&quot;cumsum&quot;</span><span class="p">,</span>
            <span class="n">name</span><span class="p">,</span>
            <span class="n">name2</span><span class="p">,</span>
            <span class="n">axis_descr</span><span class="p">,</span>
            <span class="s2">&quot;sum&quot;</span><span class="p">,</span>
            <span class="k">lambda</span> <span class="n">y</span><span class="p">,</span> <span class="n">axis</span><span class="p">:</span> <span class="n">y</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="n">axis</span><span class="p">),</span>
            <span class="s2">&quot;sum&quot;</span><span class="p">,</span>
            <span class="mf">0.0</span><span class="p">,</span>
            <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span>
            <span class="n">_cumsum_examples</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="bp">cls</span><span class="o">.</span><span class="n">cumprod</span> <span class="o">=</span> <span class="n">_make_cum_function</span><span class="p">(</span>
            <span class="bp">cls</span><span class="p">,</span>
            <span class="s2">&quot;cumprod&quot;</span><span class="p">,</span>
            <span class="n">name</span><span class="p">,</span>
            <span class="n">name2</span><span class="p">,</span>
            <span class="n">axis_descr</span><span class="p">,</span>
            <span class="s2">&quot;product&quot;</span><span class="p">,</span>
            <span class="k">lambda</span> <span class="n">y</span><span class="p">,</span> <span class="n">axis</span><span class="p">:</span> <span class="n">y</span><span class="o">.</span><span class="n">cumprod</span><span class="p">(</span><span class="n">axis</span><span class="p">),</span>
            <span class="s2">&quot;prod&quot;</span><span class="p">,</span>
            <span class="mf">1.0</span><span class="p">,</span>
            <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span>
            <span class="n">_cumprod_examples</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="bp">cls</span><span class="o">.</span><span class="n">cummax</span> <span class="o">=</span> <span class="n">_make_cum_function</span><span class="p">(</span>
            <span class="bp">cls</span><span class="p">,</span>
            <span class="s2">&quot;cummax&quot;</span><span class="p">,</span>
            <span class="n">name</span><span class="p">,</span>
            <span class="n">name2</span><span class="p">,</span>
            <span class="n">axis_descr</span><span class="p">,</span>
            <span class="s2">&quot;maximum&quot;</span><span class="p">,</span>
            <span class="k">lambda</span> <span class="n">y</span><span class="p">,</span> <span class="n">axis</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="o">.</span><span class="n">accumulate</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">axis</span><span class="p">),</span>
            <span class="s2">&quot;max&quot;</span><span class="p">,</span>
            <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">,</span>
            <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span>
            <span class="n">_cummax_examples</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="bp">cls</span><span class="o">.</span><span class="n">sum</span> <span class="o">=</span> <span class="n">_make_min_count_stat_function</span><span class="p">(</span>
            <span class="bp">cls</span><span class="p">,</span>
            <span class="s2">&quot;sum&quot;</span><span class="p">,</span>
            <span class="n">name</span><span class="p">,</span>
            <span class="n">name2</span><span class="p">,</span>
            <span class="n">axis_descr</span><span class="p">,</span>
            <span class="sd">&quot;&quot;&quot;Return the sum of the values for the requested axis.\n</span>
<span class="sd">            This is equivalent to the method ``numpy.sum``.&quot;&quot;&quot;</span><span class="p">,</span>
            <span class="n">nanops</span><span class="o">.</span><span class="n">nansum</span><span class="p">,</span>
            <span class="n">_stat_func_see_also</span><span class="p">,</span>
            <span class="n">_sum_examples</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="bp">cls</span><span class="o">.</span><span class="n">mean</span> <span class="o">=</span> <span class="n">_make_stat_function</span><span class="p">(</span>
            <span class="bp">cls</span><span class="p">,</span>
            <span class="s2">&quot;mean&quot;</span><span class="p">,</span>
            <span class="n">name</span><span class="p">,</span>
            <span class="n">name2</span><span class="p">,</span>
            <span class="n">axis_descr</span><span class="p">,</span>
            <span class="s2">&quot;Return the mean of the values for the requested axis.&quot;</span><span class="p">,</span>
            <span class="n">nanops</span><span class="o">.</span><span class="n">nanmean</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="bp">cls</span><span class="o">.</span><span class="n">skew</span> <span class="o">=</span> <span class="n">_make_stat_function</span><span class="p">(</span>
            <span class="bp">cls</span><span class="p">,</span>
            <span class="s2">&quot;skew&quot;</span><span class="p">,</span>
            <span class="n">name</span><span class="p">,</span>
            <span class="n">name2</span><span class="p">,</span>
            <span class="n">axis_descr</span><span class="p">,</span>
            <span class="s2">&quot;Return unbiased skew over requested axis</span><span class="se">\n</span><span class="s2">Normalized by N-1.&quot;</span><span class="p">,</span>
            <span class="n">nanops</span><span class="o">.</span><span class="n">nanskew</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="bp">cls</span><span class="o">.</span><span class="n">kurt</span> <span class="o">=</span> <span class="n">_make_stat_function</span><span class="p">(</span>
            <span class="bp">cls</span><span class="p">,</span>
            <span class="s2">&quot;kurt&quot;</span><span class="p">,</span>
            <span class="n">name</span><span class="p">,</span>
            <span class="n">name2</span><span class="p">,</span>
            <span class="n">axis_descr</span><span class="p">,</span>
            <span class="s2">&quot;Return unbiased kurtosis over requested axis using Fisher&#39;s &quot;</span>
            <span class="s2">&quot;definition of</span><span class="se">\n</span><span class="s2">kurtosis (kurtosis of normal == 0.0). Normalized &quot;</span>
            <span class="s2">&quot;by N-1.&quot;</span><span class="p">,</span>
            <span class="n">nanops</span><span class="o">.</span><span class="n">nankurt</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="bp">cls</span><span class="o">.</span><span class="n">kurtosis</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="n">kurt</span>
        <span class="bp">cls</span><span class="o">.</span><span class="n">prod</span> <span class="o">=</span> <span class="n">_make_min_count_stat_function</span><span class="p">(</span>
            <span class="bp">cls</span><span class="p">,</span>
            <span class="s2">&quot;prod&quot;</span><span class="p">,</span>
            <span class="n">name</span><span class="p">,</span>
            <span class="n">name2</span><span class="p">,</span>
            <span class="n">axis_descr</span><span class="p">,</span>
            <span class="s2">&quot;Return the product of the values for the requested axis.&quot;</span><span class="p">,</span>
            <span class="n">nanops</span><span class="o">.</span><span class="n">nanprod</span><span class="p">,</span>
            <span class="n">examples</span><span class="o">=</span><span class="n">_prod_examples</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="bp">cls</span><span class="o">.</span><span class="n">product</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="n">prod</span>
        <span class="bp">cls</span><span class="o">.</span><span class="n">median</span> <span class="o">=</span> <span class="n">_make_stat_function</span><span class="p">(</span>
            <span class="bp">cls</span><span class="p">,</span>
            <span class="s2">&quot;median&quot;</span><span class="p">,</span>
            <span class="n">name</span><span class="p">,</span>
            <span class="n">name2</span><span class="p">,</span>
            <span class="n">axis_descr</span><span class="p">,</span>
            <span class="s2">&quot;Return the median of the values for the requested axis.&quot;</span><span class="p">,</span>
            <span class="n">nanops</span><span class="o">.</span><span class="n">nanmedian</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="bp">cls</span><span class="o">.</span><span class="n">max</span> <span class="o">=</span> <span class="n">_make_stat_function</span><span class="p">(</span>
            <span class="bp">cls</span><span class="p">,</span>
            <span class="s2">&quot;max&quot;</span><span class="p">,</span>
            <span class="n">name</span><span class="p">,</span>
            <span class="n">name2</span><span class="p">,</span>
            <span class="n">axis_descr</span><span class="p">,</span>
            <span class="sd">&quot;&quot;&quot;Return the maximum of the values for the requested axis.\n</span>
<span class="sd">            If you want the *index* of the maximum, use ``idxmax``. This is</span>
<span class="sd">            the equivalent of the ``numpy.ndarray`` method ``argmax``.&quot;&quot;&quot;</span><span class="p">,</span>
            <span class="n">nanops</span><span class="o">.</span><span class="n">nanmax</span><span class="p">,</span>
            <span class="n">_stat_func_see_also</span><span class="p">,</span>
            <span class="n">_max_examples</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="bp">cls</span><span class="o">.</span><span class="n">min</span> <span class="o">=</span> <span class="n">_make_stat_function</span><span class="p">(</span>
            <span class="bp">cls</span><span class="p">,</span>
            <span class="s2">&quot;min&quot;</span><span class="p">,</span>
            <span class="n">name</span><span class="p">,</span>
            <span class="n">name2</span><span class="p">,</span>
            <span class="n">axis_descr</span><span class="p">,</span>
            <span class="sd">&quot;&quot;&quot;Return the minimum of the values for the requested axis.\n</span>
<span class="sd">            If you want the *index* of the minimum, use ``idxmin``. This is</span>
<span class="sd">            the equivalent of the ``numpy.ndarray`` method ``argmin``.&quot;&quot;&quot;</span><span class="p">,</span>
            <span class="n">nanops</span><span class="o">.</span><span class="n">nanmin</span><span class="p">,</span>
            <span class="n">_stat_func_see_also</span><span class="p">,</span>
            <span class="n">_min_examples</span><span class="p">,</span>
        <span class="p">)</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">_add_series_only_operations</span><span class="p">(</span><span class="bp">cls</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Add the series only operations to the cls; evaluate the doc</span>
<span class="sd">        strings again.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">axis_descr</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">name2</span> <span class="o">=</span> <span class="n">_doc_parms</span><span class="p">(</span><span class="bp">cls</span><span class="p">)</span>

        <span class="k">def</span> <span class="nf">nanptp</span><span class="p">(</span><span class="n">values</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">skipna</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
            <span class="n">nmax</span> <span class="o">=</span> <span class="n">nanops</span><span class="o">.</span><span class="n">nanmax</span><span class="p">(</span><span class="n">values</span><span class="p">,</span> <span class="n">axis</span><span class="p">,</span> <span class="n">skipna</span><span class="p">)</span>
            <span class="n">nmin</span> <span class="o">=</span> <span class="n">nanops</span><span class="o">.</span><span class="n">nanmin</span><span class="p">(</span><span class="n">values</span><span class="p">,</span> <span class="n">axis</span><span class="p">,</span> <span class="n">skipna</span><span class="p">)</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                <span class="s2">&quot;Method .ptp is deprecated and will be removed &quot;</span>
                <span class="s2">&quot;in a future version. Use numpy.ptp instead.&quot;</span><span class="p">,</span>
                <span class="ne">FutureWarning</span><span class="p">,</span>
                <span class="n">stacklevel</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="k">return</span> <span class="n">nmax</span> <span class="o">-</span> <span class="n">nmin</span>

        <span class="bp">cls</span><span class="o">.</span><span class="n">ptp</span> <span class="o">=</span> <span class="n">_make_stat_function</span><span class="p">(</span>
            <span class="bp">cls</span><span class="p">,</span>
            <span class="s2">&quot;ptp&quot;</span><span class="p">,</span>
            <span class="n">name</span><span class="p">,</span>
            <span class="n">name2</span><span class="p">,</span>
            <span class="n">axis_descr</span><span class="p">,</span>
            <span class="sd">&quot;&quot;&quot;Return the difference between the maximum value and the</span>
<span class="sd">            minimum value in the object. This is the equivalent of the</span>
<span class="sd">            ``numpy.ndarray`` method ``ptp``.\n\n.. deprecated:: 0.24.0</span>
<span class="sd">                Use numpy.ptp instead&quot;&quot;&quot;</span><span class="p">,</span>
            <span class="n">nanptp</span><span class="p">,</span>
        <span class="p">)</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">_add_series_or_dataframe_operations</span><span class="p">(</span><span class="bp">cls</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Add the series or dataframe only operations to the cls; evaluate</span>
<span class="sd">        the doc strings again.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="kn">from</span> <span class="nn">pandas.core</span> <span class="k">import</span> <span class="n">window</span> <span class="k">as</span> <span class="n">rwindow</span>

        <span class="nd">@Appender</span><span class="p">(</span><span class="n">rwindow</span><span class="o">.</span><span class="n">rolling</span><span class="o">.</span><span class="vm">__doc__</span><span class="p">)</span>
        <span class="k">def</span> <span class="nf">rolling</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">window</span><span class="p">,</span>
            <span class="n">min_periods</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">center</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
            <span class="n">win_type</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">on</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
            <span class="n">closed</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="p">):</span>
            <span class="n">axis</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_axis_number</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">rwindow</span><span class="o">.</span><span class="n">rolling</span><span class="p">(</span>
                <span class="bp">self</span><span class="p">,</span>
                <span class="n">window</span><span class="o">=</span><span class="n">window</span><span class="p">,</span>
                <span class="n">min_periods</span><span class="o">=</span><span class="n">min_periods</span><span class="p">,</span>
                <span class="n">center</span><span class="o">=</span><span class="n">center</span><span class="p">,</span>
                <span class="n">win_type</span><span class="o">=</span><span class="n">win_type</span><span class="p">,</span>
                <span class="n">on</span><span class="o">=</span><span class="n">on</span><span class="p">,</span>
                <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span>
                <span class="n">closed</span><span class="o">=</span><span class="n">closed</span><span class="p">,</span>
            <span class="p">)</span>

        <span class="bp">cls</span><span class="o">.</span><span class="n">rolling</span> <span class="o">=</span> <span class="n">rolling</span>

        <span class="nd">@Appender</span><span class="p">(</span><span class="n">rwindow</span><span class="o">.</span><span class="n">expanding</span><span class="o">.</span><span class="vm">__doc__</span><span class="p">)</span>
        <span class="k">def</span> <span class="nf">expanding</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">min_periods</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">center</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
            <span class="n">axis</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_axis_number</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">rwindow</span><span class="o">.</span><span class="n">expanding</span><span class="p">(</span>
                <span class="bp">self</span><span class="p">,</span> <span class="n">min_periods</span><span class="o">=</span><span class="n">min_periods</span><span class="p">,</span> <span class="n">center</span><span class="o">=</span><span class="n">center</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span>
            <span class="p">)</span>

        <span class="bp">cls</span><span class="o">.</span><span class="n">expanding</span> <span class="o">=</span> <span class="n">expanding</span>

        <span class="nd">@Appender</span><span class="p">(</span><span class="n">rwindow</span><span class="o">.</span><span class="n">ewm</span><span class="o">.</span><span class="vm">__doc__</span><span class="p">)</span>
        <span class="k">def</span> <span class="nf">ewm</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">com</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">span</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">halflife</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">alpha</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">min_periods</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
            <span class="n">adjust</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="n">ignore_na</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
            <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
        <span class="p">):</span>
            <span class="n">axis</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_axis_number</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">rwindow</span><span class="o">.</span><span class="n">ewm</span><span class="p">(</span>
                <span class="bp">self</span><span class="p">,</span>
                <span class="n">com</span><span class="o">=</span><span class="n">com</span><span class="p">,</span>
                <span class="n">span</span><span class="o">=</span><span class="n">span</span><span class="p">,</span>
                <span class="n">halflife</span><span class="o">=</span><span class="n">halflife</span><span class="p">,</span>
                <span class="n">alpha</span><span class="o">=</span><span class="n">alpha</span><span class="p">,</span>
                <span class="n">min_periods</span><span class="o">=</span><span class="n">min_periods</span><span class="p">,</span>
                <span class="n">adjust</span><span class="o">=</span><span class="n">adjust</span><span class="p">,</span>
                <span class="n">ignore_na</span><span class="o">=</span><span class="n">ignore_na</span><span class="p">,</span>
                <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span>
            <span class="p">)</span>

        <span class="bp">cls</span><span class="o">.</span><span class="n">ewm</span> <span class="o">=</span> <span class="n">ewm</span>

    <span class="nd">@Appender</span><span class="p">(</span><span class="n">_shared_docs</span><span class="p">[</span><span class="s2">&quot;transform&quot;</span><span class="p">]</span> <span class="o">%</span> <span class="nb">dict</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">,</span> <span class="o">**</span><span class="n">_shared_doc_kwargs</span><span class="p">))</span>
    <span class="k">def</span> <span class="nf">transform</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">func</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">agg</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">is_scalar</span><span class="p">(</span><span class="n">result</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">result</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;transforms cannot produce &quot;</span> <span class="s2">&quot;aggregated results&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">result</span>

    <span class="c1"># ----------------------------------------------------------------------</span>
    <span class="c1"># Misc methods</span>

    <span class="n">_shared_docs</span><span class="p">[</span>
        <span class="s2">&quot;valid_index&quot;</span>
    <span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;</span>
<span class="s2">        Return index for </span><span class="si">%(position)s</span><span class="s2"> non-NA/null value.</span>

<span class="s2">        Returns</span>
<span class="s2">        -------</span>
<span class="s2">        scalar : type of index</span>

<span class="s2">        Notes</span>
<span class="s2">        -----</span>
<span class="s2">        If all elements are non-NA/null, returns None.</span>
<span class="s2">        Also returns None for empty </span><span class="si">%(klass)s</span><span class="s2">.</span>
<span class="s2">        &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">_find_valid_index</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">how</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Retrieves the index of the first valid value.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        how : {&#39;first&#39;, &#39;last&#39;}</span>
<span class="sd">            Use this parameter to change between the first or last valid index.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        idx_first_valid : type of index</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="n">how</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;first&quot;</span><span class="p">,</span> <span class="s2">&quot;last&quot;</span><span class="p">]</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>  <span class="c1"># early stop</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="n">is_valid</span> <span class="o">=</span> <span class="o">~</span><span class="bp">self</span><span class="o">.</span><span class="n">isna</span><span class="p">()</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">is_valid</span> <span class="o">=</span> <span class="n">is_valid</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>  <span class="c1"># reduce axis 1</span>

        <span class="k">if</span> <span class="n">how</span> <span class="o">==</span> <span class="s2">&quot;first&quot;</span><span class="p">:</span>
            <span class="n">idxpos</span> <span class="o">=</span> <span class="n">is_valid</span><span class="o">.</span><span class="n">values</span><span class="p">[::]</span><span class="o">.</span><span class="n">argmax</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">how</span> <span class="o">==</span> <span class="s2">&quot;last&quot;</span><span class="p">:</span>
            <span class="n">idxpos</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">is_valid</span><span class="o">.</span><span class="n">values</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">argmax</span><span class="p">()</span>

        <span class="n">chk_notna</span> <span class="o">=</span> <span class="n">is_valid</span><span class="o">.</span><span class="n">iat</span><span class="p">[</span><span class="n">idxpos</span><span class="p">]</span>
        <span class="n">idx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="p">[</span><span class="n">idxpos</span><span class="p">]</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">chk_notna</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="k">return</span> <span class="n">idx</span>

    <span class="nd">@Appender</span><span class="p">(</span>
        <span class="n">_shared_docs</span><span class="p">[</span><span class="s2">&quot;valid_index&quot;</span><span class="p">]</span> <span class="o">%</span> <span class="p">{</span><span class="s2">&quot;position&quot;</span><span class="p">:</span> <span class="s2">&quot;first&quot;</span><span class="p">,</span> <span class="s2">&quot;klass&quot;</span><span class="p">:</span> <span class="s2">&quot;Series/DataFrame&quot;</span><span class="p">}</span>
    <span class="p">)</span>
    <span class="k">def</span> <span class="nf">first_valid_index</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_find_valid_index</span><span class="p">(</span><span class="s2">&quot;first&quot;</span><span class="p">)</span>

    <span class="nd">@Appender</span><span class="p">(</span>
        <span class="n">_shared_docs</span><span class="p">[</span><span class="s2">&quot;valid_index&quot;</span><span class="p">]</span> <span class="o">%</span> <span class="p">{</span><span class="s2">&quot;position&quot;</span><span class="p">:</span> <span class="s2">&quot;last&quot;</span><span class="p">,</span> <span class="s2">&quot;klass&quot;</span><span class="p">:</span> <span class="s2">&quot;Series/DataFrame&quot;</span><span class="p">}</span>
    <span class="p">)</span>
    <span class="k">def</span> <span class="nf">last_valid_index</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_find_valid_index</span><span class="p">(</span><span class="s2">&quot;last&quot;</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_doc_parms</span><span class="p">(</span><span class="bp">cls</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Return a tuple of the doc parms.&quot;&quot;&quot;</span>
    <span class="n">axis_descr</span> <span class="o">=</span> <span class="s2">&quot;{</span><span class="si">%s</span><span class="s2">}&quot;</span> <span class="o">%</span> <span class="s2">&quot;, &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span>
        <span class="s2">&quot;</span><span class="si">{0}</span><span class="s2"> (</span><span class="si">{1}</span><span class="s2">)&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">a</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">cls</span><span class="o">.</span><span class="n">_AXIS_ORDERS</span><span class="p">)</span>
    <span class="p">)</span>
    <span class="n">name</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="n">_constructor_sliced</span><span class="o">.</span><span class="vm">__name__</span> <span class="k">if</span> <span class="bp">cls</span><span class="o">.</span><span class="n">_AXIS_LEN</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="k">else</span> <span class="s2">&quot;scalar&quot;</span>
    <span class="n">name2</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="vm">__name__</span>
    <span class="k">return</span> <span class="n">axis_descr</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">name2</span>


<span class="n">_num_doc</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;</span>
<span class="si">%(desc)s</span><span class="s2"></span>

<span class="s2">Parameters</span>
<span class="s2">----------</span>
<span class="s2">axis : </span><span class="si">%(axis_descr)s</span><span class="s2"></span>
<span class="s2">    Axis for the function to be applied on.</span>
<span class="s2">skipna : bool, default True</span>
<span class="s2">    Exclude NA/null values when computing the result.</span>
<span class="s2">level : int or level name, default None</span>
<span class="s2">    If the axis is a MultiIndex (hierarchical), count along a</span>
<span class="s2">    particular level, collapsing into a </span><span class="si">%(name1)s</span><span class="s2">.</span>
<span class="s2">numeric_only : bool, default None</span>
<span class="s2">    Include only float, int, boolean columns. If None, will attempt to use</span>
<span class="s2">    everything, then use only numeric data. Not implemented for Series.</span>
<span class="si">%(min_count)s</span><span class="se">\</span>
<span class="s2">**kwargs</span>
<span class="s2">    Additional keyword arguments to be passed to the function.</span>

<span class="s2">Returns</span>
<span class="s2">-------</span>
<span class="si">%(name1)s</span><span class="s2"> or </span><span class="si">%(name2)s</span><span class="s2"> (if level specified)</span><span class="se">\</span>
<span class="si">%(see_also)s</span><span class="se">\</span>
<span class="si">%(examples)s</span><span class="s2"></span>
<span class="s2">&quot;&quot;&quot;</span>

<span class="n">_num_ddof_doc</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;</span>
<span class="si">%(desc)s</span><span class="s2"></span>

<span class="s2">Parameters</span>
<span class="s2">----------</span>
<span class="s2">axis : </span><span class="si">%(axis_descr)s</span><span class="s2"></span>
<span class="s2">skipna : bool, default True</span>
<span class="s2">    Exclude NA/null values. If an entire row/column is NA, the result</span>
<span class="s2">    will be NA</span>
<span class="s2">level : int or level name, default None</span>
<span class="s2">    If the axis is a MultiIndex (hierarchical), count along a</span>
<span class="s2">    particular level, collapsing into a </span><span class="si">%(name1)s</span><span class="s2"></span>
<span class="s2">ddof : int, default 1</span>
<span class="s2">    Delta Degrees of Freedom. The divisor used in calculations is N - ddof,</span>
<span class="s2">    where N represents the number of elements.</span>
<span class="s2">numeric_only : bool, default None</span>
<span class="s2">    Include only float, int, boolean columns. If None, will attempt to use</span>
<span class="s2">    everything, then use only numeric data. Not implemented for Series.</span>

<span class="s2">Returns</span>
<span class="s2">-------</span>
<span class="si">%(name1)s</span><span class="s2"> or </span><span class="si">%(name2)s</span><span class="s2"> (if level specified)</span><span class="se">\n</span><span class="s2">&quot;&quot;&quot;</span>

<span class="n">_bool_doc</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;</span>
<span class="si">%(desc)s</span><span class="s2"></span>

<span class="s2">Parameters</span>
<span class="s2">----------</span>
<span class="s2">axis : {0 or &#39;index&#39;, 1 or &#39;columns&#39;, None}, default 0</span>
<span class="s2">    Indicate which axis or axes should be reduced.</span>

<span class="s2">    * 0 / &#39;index&#39; : reduce the index, return a Series whose index is the</span>
<span class="s2">      original column labels.</span>
<span class="s2">    * 1 / &#39;columns&#39; : reduce the columns, return a Series whose index is the</span>
<span class="s2">      original index.</span>
<span class="s2">    * None : reduce all axes, return a scalar.</span>

<span class="s2">bool_only : bool, default None</span>
<span class="s2">    Include only boolean columns. If None, will attempt to use everything,</span>
<span class="s2">    then use only boolean data. Not implemented for Series.</span>
<span class="s2">skipna : bool, default True</span>
<span class="s2">    Exclude NA/null values. If the entire row/column is NA and skipna is</span>
<span class="s2">    True, then the result will be </span><span class="si">%(empty_value)s</span><span class="s2">, as for an empty row/column.</span>
<span class="s2">    If skipna is False, then NA are treated as True, because these are not</span>
<span class="s2">    equal to zero.</span>
<span class="s2">level : int or level name, default None</span>
<span class="s2">    If the axis is a MultiIndex (hierarchical), count along a</span>
<span class="s2">    particular level, collapsing into a </span><span class="si">%(name1)s</span><span class="s2">.</span>
<span class="s2">**kwargs : any, default None</span>
<span class="s2">    Additional keywords have no effect but might be accepted for</span>
<span class="s2">    compatibility with NumPy.</span>

<span class="s2">Returns</span>
<span class="s2">-------</span>
<span class="si">%(name1)s</span><span class="s2"> or </span><span class="si">%(name2)s</span><span class="s2"></span>
<span class="s2">    If level is specified, then, </span><span class="si">%(name2)s</span><span class="s2"> is returned; otherwise, </span><span class="si">%(name1)s</span><span class="s2"></span>
<span class="s2">    is returned.</span>

<span class="si">%(see_also)s</span><span class="s2"></span>
<span class="si">%(examples)s</span><span class="s2">&quot;&quot;&quot;</span>

<span class="n">_all_desc</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;</span><span class="se">\</span>
<span class="s2">Return whether all elements are True, potentially over an axis.</span>

<span class="s2">Returns True unless there at least one element within a series or</span>
<span class="s2">along a Dataframe axis that is False or equivalent (e.g. zero or</span>
<span class="s2">empty).&quot;&quot;&quot;</span>

<span class="n">_all_examples</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;</span><span class="se">\</span>
<span class="s2">Examples</span>
<span class="s2">--------</span>
<span class="s2">**Series**</span>

<span class="s2">&gt;&gt;&gt; pd.Series([True, True]).all()</span>
<span class="s2">True</span>
<span class="s2">&gt;&gt;&gt; pd.Series([True, False]).all()</span>
<span class="s2">False</span>
<span class="s2">&gt;&gt;&gt; pd.Series([]).all()</span>
<span class="s2">True</span>
<span class="s2">&gt;&gt;&gt; pd.Series([np.nan]).all()</span>
<span class="s2">True</span>
<span class="s2">&gt;&gt;&gt; pd.Series([np.nan]).all(skipna=False)</span>
<span class="s2">True</span>

<span class="s2">**DataFrames**</span>

<span class="s2">Create a dataframe from a dictionary.</span>

<span class="s2">&gt;&gt;&gt; df = pd.DataFrame({&#39;col1&#39;: [True, True], &#39;col2&#39;: [True, False]})</span>
<span class="s2">&gt;&gt;&gt; df</span>
<span class="s2">   col1   col2</span>
<span class="s2">0  True   True</span>
<span class="s2">1  True  False</span>

<span class="s2">Default behaviour checks if column-wise values all return True.</span>

<span class="s2">&gt;&gt;&gt; df.all()</span>
<span class="s2">col1     True</span>
<span class="s2">col2    False</span>
<span class="s2">dtype: bool</span>

<span class="s2">Specify ``axis=&#39;columns&#39;`` to check if row-wise values all return True.</span>

<span class="s2">&gt;&gt;&gt; df.all(axis=&#39;columns&#39;)</span>
<span class="s2">0     True</span>
<span class="s2">1    False</span>
<span class="s2">dtype: bool</span>

<span class="s2">Or ``axis=None`` for whether every value is True.</span>

<span class="s2">&gt;&gt;&gt; df.all(axis=None)</span>
<span class="s2">False</span>
<span class="s2">&quot;&quot;&quot;</span>

<span class="n">_all_see_also</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;</span><span class="se">\</span>
<span class="s2">See Also</span>
<span class="s2">--------</span>
<span class="s2">Series.all : Return True if all elements are True.</span>
<span class="s2">DataFrame.any : Return True if one (or more) elements are True.</span>
<span class="s2">&quot;&quot;&quot;</span>

<span class="n">_cnum_doc</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;</span>
<span class="s2">Return cumulative </span><span class="si">%(desc)s</span><span class="s2"> over a DataFrame or Series axis.</span>

<span class="s2">Returns a DataFrame or Series of the same size containing the cumulative</span>
<span class="si">%(desc)s</span><span class="s2">.</span>

<span class="s2">Parameters</span>
<span class="s2">----------</span>
<span class="s2">axis : {0 or &#39;index&#39;, 1 or &#39;columns&#39;}, default 0</span>
<span class="s2">    The index or the name of the axis. 0 is equivalent to None or &#39;index&#39;.</span>
<span class="s2">skipna : boolean, default True</span>
<span class="s2">    Exclude NA/null values. If an entire row/column is NA, the result</span>
<span class="s2">    will be NA.</span>
<span class="s2">*args, **kwargs :</span>
<span class="s2">    Additional keywords have no effect but might be accepted for</span>
<span class="s2">    compatibility with NumPy.</span>

<span class="s2">Returns</span>
<span class="s2">-------</span>
<span class="si">%(name1)s</span><span class="s2"> or </span><span class="si">%(name2)s</span><span class="s2"></span>

<span class="s2">See Also</span>
<span class="s2">--------</span>
<span class="s2">core.window.Expanding.</span><span class="si">%(accum_func_name)s</span><span class="s2"> : Similar functionality</span>
<span class="s2">    but ignores ``NaN`` values.</span>
<span class="si">%(name2)s</span><span class="s2">.</span><span class="si">%(accum_func_name)s</span><span class="s2"> : Return the </span><span class="si">%(desc)s</span><span class="s2"> over</span>
<span class="s2">    </span><span class="si">%(name2)s</span><span class="s2"> axis.</span>
<span class="si">%(name2)s</span><span class="s2">.cummax : Return cumulative maximum over </span><span class="si">%(name2)s</span><span class="s2"> axis.</span>
<span class="si">%(name2)s</span><span class="s2">.cummin : Return cumulative minimum over </span><span class="si">%(name2)s</span><span class="s2"> axis.</span>
<span class="si">%(name2)s</span><span class="s2">.cumsum : Return cumulative sum over </span><span class="si">%(name2)s</span><span class="s2"> axis.</span>
<span class="si">%(name2)s</span><span class="s2">.cumprod : Return cumulative product over </span><span class="si">%(name2)s</span><span class="s2"> axis.</span>

<span class="si">%(examples)s</span><span class="s2">&quot;&quot;&quot;</span>

<span class="n">_cummin_examples</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;</span><span class="se">\</span>
<span class="s2">Examples</span>
<span class="s2">--------</span>
<span class="s2">**Series**</span>

<span class="s2">&gt;&gt;&gt; s = pd.Series([2, np.nan, 5, -1, 0])</span>
<span class="s2">&gt;&gt;&gt; s</span>
<span class="s2">0    2.0</span>
<span class="s2">1    NaN</span>
<span class="s2">2    5.0</span>
<span class="s2">3   -1.0</span>
<span class="s2">4    0.0</span>
<span class="s2">dtype: float64</span>

<span class="s2">By default, NA values are ignored.</span>

<span class="s2">&gt;&gt;&gt; s.cummin()</span>
<span class="s2">0    2.0</span>
<span class="s2">1    NaN</span>
<span class="s2">2    2.0</span>
<span class="s2">3   -1.0</span>
<span class="s2">4   -1.0</span>
<span class="s2">dtype: float64</span>

<span class="s2">To include NA values in the operation, use ``skipna=False``</span>

<span class="s2">&gt;&gt;&gt; s.cummin(skipna=False)</span>
<span class="s2">0    2.0</span>
<span class="s2">1    NaN</span>
<span class="s2">2    NaN</span>
<span class="s2">3    NaN</span>
<span class="s2">4    NaN</span>
<span class="s2">dtype: float64</span>

<span class="s2">**DataFrame**</span>

<span class="s2">&gt;&gt;&gt; df = pd.DataFrame([[2.0, 1.0],</span>
<span class="s2">...                    [3.0, np.nan],</span>
<span class="s2">...                    [1.0, 0.0]],</span>
<span class="s2">...                    columns=list(&#39;AB&#39;))</span>
<span class="s2">&gt;&gt;&gt; df</span>
<span class="s2">     A    B</span>
<span class="s2">0  2.0  1.0</span>
<span class="s2">1  3.0  NaN</span>
<span class="s2">2  1.0  0.0</span>

<span class="s2">By default, iterates over rows and finds the minimum</span>
<span class="s2">in each column. This is equivalent to ``axis=None`` or ``axis=&#39;index&#39;``.</span>

<span class="s2">&gt;&gt;&gt; df.cummin()</span>
<span class="s2">     A    B</span>
<span class="s2">0  2.0  1.0</span>
<span class="s2">1  2.0  NaN</span>
<span class="s2">2  1.0  0.0</span>

<span class="s2">To iterate over columns and find the minimum in each row,</span>
<span class="s2">use ``axis=1``</span>

<span class="s2">&gt;&gt;&gt; df.cummin(axis=1)</span>
<span class="s2">     A    B</span>
<span class="s2">0  2.0  1.0</span>
<span class="s2">1  3.0  NaN</span>
<span class="s2">2  1.0  0.0</span>
<span class="s2">&quot;&quot;&quot;</span>

<span class="n">_cumsum_examples</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;</span><span class="se">\</span>
<span class="s2">Examples</span>
<span class="s2">--------</span>
<span class="s2">**Series**</span>

<span class="s2">&gt;&gt;&gt; s = pd.Series([2, np.nan, 5, -1, 0])</span>
<span class="s2">&gt;&gt;&gt; s</span>
<span class="s2">0    2.0</span>
<span class="s2">1    NaN</span>
<span class="s2">2    5.0</span>
<span class="s2">3   -1.0</span>
<span class="s2">4    0.0</span>
<span class="s2">dtype: float64</span>

<span class="s2">By default, NA values are ignored.</span>

<span class="s2">&gt;&gt;&gt; s.cumsum()</span>
<span class="s2">0    2.0</span>
<span class="s2">1    NaN</span>
<span class="s2">2    7.0</span>
<span class="s2">3    6.0</span>
<span class="s2">4    6.0</span>
<span class="s2">dtype: float64</span>

<span class="s2">To include NA values in the operation, use ``skipna=False``</span>

<span class="s2">&gt;&gt;&gt; s.cumsum(skipna=False)</span>
<span class="s2">0    2.0</span>
<span class="s2">1    NaN</span>
<span class="s2">2    NaN</span>
<span class="s2">3    NaN</span>
<span class="s2">4    NaN</span>
<span class="s2">dtype: float64</span>

<span class="s2">**DataFrame**</span>

<span class="s2">&gt;&gt;&gt; df = pd.DataFrame([[2.0, 1.0],</span>
<span class="s2">...                    [3.0, np.nan],</span>
<span class="s2">...                    [1.0, 0.0]],</span>
<span class="s2">...                    columns=list(&#39;AB&#39;))</span>
<span class="s2">&gt;&gt;&gt; df</span>
<span class="s2">     A    B</span>
<span class="s2">0  2.0  1.0</span>
<span class="s2">1  3.0  NaN</span>
<span class="s2">2  1.0  0.0</span>

<span class="s2">By default, iterates over rows and finds the sum</span>
<span class="s2">in each column. This is equivalent to ``axis=None`` or ``axis=&#39;index&#39;``.</span>

<span class="s2">&gt;&gt;&gt; df.cumsum()</span>
<span class="s2">     A    B</span>
<span class="s2">0  2.0  1.0</span>
<span class="s2">1  5.0  NaN</span>
<span class="s2">2  6.0  1.0</span>

<span class="s2">To iterate over columns and find the sum in each row,</span>
<span class="s2">use ``axis=1``</span>

<span class="s2">&gt;&gt;&gt; df.cumsum(axis=1)</span>
<span class="s2">     A    B</span>
<span class="s2">0  2.0  3.0</span>
<span class="s2">1  3.0  NaN</span>
<span class="s2">2  1.0  1.0</span>
<span class="s2">&quot;&quot;&quot;</span>

<span class="n">_cumprod_examples</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;</span><span class="se">\</span>
<span class="s2">Examples</span>
<span class="s2">--------</span>
<span class="s2">**Series**</span>

<span class="s2">&gt;&gt;&gt; s = pd.Series([2, np.nan, 5, -1, 0])</span>
<span class="s2">&gt;&gt;&gt; s</span>
<span class="s2">0    2.0</span>
<span class="s2">1    NaN</span>
<span class="s2">2    5.0</span>
<span class="s2">3   -1.0</span>
<span class="s2">4    0.0</span>
<span class="s2">dtype: float64</span>

<span class="s2">By default, NA values are ignored.</span>

<span class="s2">&gt;&gt;&gt; s.cumprod()</span>
<span class="s2">0     2.0</span>
<span class="s2">1     NaN</span>
<span class="s2">2    10.0</span>
<span class="s2">3   -10.0</span>
<span class="s2">4    -0.0</span>
<span class="s2">dtype: float64</span>

<span class="s2">To include NA values in the operation, use ``skipna=False``</span>

<span class="s2">&gt;&gt;&gt; s.cumprod(skipna=False)</span>
<span class="s2">0    2.0</span>
<span class="s2">1    NaN</span>
<span class="s2">2    NaN</span>
<span class="s2">3    NaN</span>
<span class="s2">4    NaN</span>
<span class="s2">dtype: float64</span>

<span class="s2">**DataFrame**</span>

<span class="s2">&gt;&gt;&gt; df = pd.DataFrame([[2.0, 1.0],</span>
<span class="s2">...                    [3.0, np.nan],</span>
<span class="s2">...                    [1.0, 0.0]],</span>
<span class="s2">...                    columns=list(&#39;AB&#39;))</span>
<span class="s2">&gt;&gt;&gt; df</span>
<span class="s2">     A    B</span>
<span class="s2">0  2.0  1.0</span>
<span class="s2">1  3.0  NaN</span>
<span class="s2">2  1.0  0.0</span>

<span class="s2">By default, iterates over rows and finds the product</span>
<span class="s2">in each column. This is equivalent to ``axis=None`` or ``axis=&#39;index&#39;``.</span>

<span class="s2">&gt;&gt;&gt; df.cumprod()</span>
<span class="s2">     A    B</span>
<span class="s2">0  2.0  1.0</span>
<span class="s2">1  6.0  NaN</span>
<span class="s2">2  6.0  0.0</span>

<span class="s2">To iterate over columns and find the product in each row,</span>
<span class="s2">use ``axis=1``</span>

<span class="s2">&gt;&gt;&gt; df.cumprod(axis=1)</span>
<span class="s2">     A    B</span>
<span class="s2">0  2.0  2.0</span>
<span class="s2">1  3.0  NaN</span>
<span class="s2">2  1.0  0.0</span>
<span class="s2">&quot;&quot;&quot;</span>

<span class="n">_cummax_examples</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;</span><span class="se">\</span>
<span class="s2">Examples</span>
<span class="s2">--------</span>
<span class="s2">**Series**</span>

<span class="s2">&gt;&gt;&gt; s = pd.Series([2, np.nan, 5, -1, 0])</span>
<span class="s2">&gt;&gt;&gt; s</span>
<span class="s2">0    2.0</span>
<span class="s2">1    NaN</span>
<span class="s2">2    5.0</span>
<span class="s2">3   -1.0</span>
<span class="s2">4    0.0</span>
<span class="s2">dtype: float64</span>

<span class="s2">By default, NA values are ignored.</span>

<span class="s2">&gt;&gt;&gt; s.cummax()</span>
<span class="s2">0    2.0</span>
<span class="s2">1    NaN</span>
<span class="s2">2    5.0</span>
<span class="s2">3    5.0</span>
<span class="s2">4    5.0</span>
<span class="s2">dtype: float64</span>

<span class="s2">To include NA values in the operation, use ``skipna=False``</span>

<span class="s2">&gt;&gt;&gt; s.cummax(skipna=False)</span>
<span class="s2">0    2.0</span>
<span class="s2">1    NaN</span>
<span class="s2">2    NaN</span>
<span class="s2">3    NaN</span>
<span class="s2">4    NaN</span>
<span class="s2">dtype: float64</span>

<span class="s2">**DataFrame**</span>

<span class="s2">&gt;&gt;&gt; df = pd.DataFrame([[2.0, 1.0],</span>
<span class="s2">...                    [3.0, np.nan],</span>
<span class="s2">...                    [1.0, 0.0]],</span>
<span class="s2">...                    columns=list(&#39;AB&#39;))</span>
<span class="s2">&gt;&gt;&gt; df</span>
<span class="s2">     A    B</span>
<span class="s2">0  2.0  1.0</span>
<span class="s2">1  3.0  NaN</span>
<span class="s2">2  1.0  0.0</span>

<span class="s2">By default, iterates over rows and finds the maximum</span>
<span class="s2">in each column. This is equivalent to ``axis=None`` or ``axis=&#39;index&#39;``.</span>

<span class="s2">&gt;&gt;&gt; df.cummax()</span>
<span class="s2">     A    B</span>
<span class="s2">0  2.0  1.0</span>
<span class="s2">1  3.0  NaN</span>
<span class="s2">2  3.0  1.0</span>

<span class="s2">To iterate over columns and find the maximum in each row,</span>
<span class="s2">use ``axis=1``</span>

<span class="s2">&gt;&gt;&gt; df.cummax(axis=1)</span>
<span class="s2">     A    B</span>
<span class="s2">0  2.0  2.0</span>
<span class="s2">1  3.0  NaN</span>
<span class="s2">2  1.0  1.0</span>
<span class="s2">&quot;&quot;&quot;</span>

<span class="n">_any_see_also</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;</span><span class="se">\</span>
<span class="s2">See Also</span>
<span class="s2">--------</span>
<span class="s2">numpy.any : Numpy version of this method.</span>
<span class="s2">Series.any : Return whether any element is True.</span>
<span class="s2">Series.all : Return whether all elements are True.</span>
<span class="s2">DataFrame.any : Return whether any element is True over requested axis.</span>
<span class="s2">DataFrame.all : Return whether all elements are True over requested axis.</span>
<span class="s2">&quot;&quot;&quot;</span>

<span class="n">_any_desc</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;</span><span class="se">\</span>
<span class="s2">Return whether any element is True, potentially over an axis.</span>

<span class="s2">Returns False unless there at least one element within a series or</span>
<span class="s2">along a Dataframe axis that is True or equivalent (e.g. non-zero or</span>
<span class="s2">non-empty).&quot;&quot;&quot;</span>

<span class="n">_any_examples</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;</span><span class="se">\</span>
<span class="s2">Examples</span>
<span class="s2">--------</span>
<span class="s2">**Series**</span>

<span class="s2">For Series input, the output is a scalar indicating whether any element</span>
<span class="s2">is True.</span>

<span class="s2">&gt;&gt;&gt; pd.Series([False, False]).any()</span>
<span class="s2">False</span>
<span class="s2">&gt;&gt;&gt; pd.Series([True, False]).any()</span>
<span class="s2">True</span>
<span class="s2">&gt;&gt;&gt; pd.Series([]).any()</span>
<span class="s2">False</span>
<span class="s2">&gt;&gt;&gt; pd.Series([np.nan]).any()</span>
<span class="s2">False</span>
<span class="s2">&gt;&gt;&gt; pd.Series([np.nan]).any(skipna=False)</span>
<span class="s2">True</span>

<span class="s2">**DataFrame**</span>

<span class="s2">Whether each column contains at least one True element (the default).</span>

<span class="s2">&gt;&gt;&gt; df = pd.DataFrame({&quot;A&quot;: [1, 2], &quot;B&quot;: [0, 2], &quot;C&quot;: [0, 0]})</span>
<span class="s2">&gt;&gt;&gt; df</span>
<span class="s2">   A  B  C</span>
<span class="s2">0  1  0  0</span>
<span class="s2">1  2  2  0</span>

<span class="s2">&gt;&gt;&gt; df.any()</span>
<span class="s2">A     True</span>
<span class="s2">B     True</span>
<span class="s2">C    False</span>
<span class="s2">dtype: bool</span>

<span class="s2">Aggregating over the columns.</span>

<span class="s2">&gt;&gt;&gt; df = pd.DataFrame({&quot;A&quot;: [True, False], &quot;B&quot;: [1, 2]})</span>
<span class="s2">&gt;&gt;&gt; df</span>
<span class="s2">       A  B</span>
<span class="s2">0   True  1</span>
<span class="s2">1  False  2</span>

<span class="s2">&gt;&gt;&gt; df.any(axis=&#39;columns&#39;)</span>
<span class="s2">0    True</span>
<span class="s2">1    True</span>
<span class="s2">dtype: bool</span>

<span class="s2">&gt;&gt;&gt; df = pd.DataFrame({&quot;A&quot;: [True, False], &quot;B&quot;: [1, 0]})</span>
<span class="s2">&gt;&gt;&gt; df</span>
<span class="s2">       A  B</span>
<span class="s2">0   True  1</span>
<span class="s2">1  False  0</span>

<span class="s2">&gt;&gt;&gt; df.any(axis=&#39;columns&#39;)</span>
<span class="s2">0    True</span>
<span class="s2">1    False</span>
<span class="s2">dtype: bool</span>

<span class="s2">Aggregating over the entire DataFrame with ``axis=None``.</span>

<span class="s2">&gt;&gt;&gt; df.any(axis=None)</span>
<span class="s2">True</span>

<span class="s2">`any` for an empty DataFrame is an empty Series.</span>

<span class="s2">&gt;&gt;&gt; pd.DataFrame([]).any()</span>
<span class="s2">Series([], dtype: bool)</span>
<span class="s2">&quot;&quot;&quot;</span>

<span class="n">_shared_docs</span><span class="p">[</span>
    <span class="s2">&quot;stat_func_example&quot;</span>
<span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;</span>

<span class="s2">Examples</span>
<span class="s2">--------</span>
<span class="s2">&gt;&gt;&gt; idx = pd.MultiIndex.from_arrays([</span>
<span class="s2">...     [&#39;warm&#39;, &#39;warm&#39;, &#39;cold&#39;, &#39;cold&#39;],</span>
<span class="s2">...     [&#39;dog&#39;, &#39;falcon&#39;, &#39;fish&#39;, &#39;spider&#39;]],</span>
<span class="s2">...     names=[&#39;blooded&#39;, &#39;animal&#39;])</span>
<span class="s2">&gt;&gt;&gt; s = pd.Series([4, 2, 0, 8], name=&#39;legs&#39;, index=idx)</span>
<span class="s2">&gt;&gt;&gt; s</span>
<span class="s2">blooded  animal</span>
<span class="s2">warm     dog       4</span>
<span class="s2">         falcon    2</span>
<span class="s2">cold     fish      0</span>
<span class="s2">         spider    8</span>
<span class="s2">Name: legs, dtype: int64</span>

<span class="s2">&gt;&gt;&gt; s.</span><span class="si">{stat_func}</span><span class="s2">()</span>
<span class="si">{default_output}</span><span class="s2"></span>

<span class="si">{verb}</span><span class="s2"> using level names, as well as indices.</span>

<span class="s2">&gt;&gt;&gt; s.</span><span class="si">{stat_func}</span><span class="s2">(level=&#39;blooded&#39;)</span>
<span class="s2">blooded</span>
<span class="s2">warm    </span><span class="si">{level_output_0}</span><span class="s2"></span>
<span class="s2">cold    </span><span class="si">{level_output_1}</span><span class="s2"></span>
<span class="s2">Name: legs, dtype: int64</span>

<span class="s2">&gt;&gt;&gt; s.</span><span class="si">{stat_func}</span><span class="s2">(level=0)</span>
<span class="s2">blooded</span>
<span class="s2">warm    </span><span class="si">{level_output_0}</span><span class="s2"></span>
<span class="s2">cold    </span><span class="si">{level_output_1}</span><span class="s2"></span>
<span class="s2">Name: legs, dtype: int64&quot;&quot;&quot;</span>

<span class="n">_sum_examples</span> <span class="o">=</span> <span class="n">_shared_docs</span><span class="p">[</span><span class="s2">&quot;stat_func_example&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
    <span class="n">stat_func</span><span class="o">=</span><span class="s2">&quot;sum&quot;</span><span class="p">,</span> <span class="n">verb</span><span class="o">=</span><span class="s2">&quot;Sum&quot;</span><span class="p">,</span> <span class="n">default_output</span><span class="o">=</span><span class="mi">14</span><span class="p">,</span> <span class="n">level_output_0</span><span class="o">=</span><span class="mi">6</span><span class="p">,</span> <span class="n">level_output_1</span><span class="o">=</span><span class="mi">8</span>
<span class="p">)</span>

<span class="n">_sum_examples</span> <span class="o">+=</span> <span class="s2">&quot;&quot;&quot;</span>

<span class="s2">By default, the sum of an empty or all-NA Series is ``0``.</span>

<span class="s2">&gt;&gt;&gt; pd.Series([]).sum()  # min_count=0 is the default</span>
<span class="s2">0.0</span>

<span class="s2">This can be controlled with the ``min_count`` parameter. For example, if</span>
<span class="s2">you&#39;d like the sum of an empty series to be NaN, pass ``min_count=1``.</span>

<span class="s2">&gt;&gt;&gt; pd.Series([]).sum(min_count=1)</span>
<span class="s2">nan</span>

<span class="s2">Thanks to the ``skipna`` parameter, ``min_count`` handles all-NA and</span>
<span class="s2">empty series identically.</span>

<span class="s2">&gt;&gt;&gt; pd.Series([np.nan]).sum()</span>
<span class="s2">0.0</span>

<span class="s2">&gt;&gt;&gt; pd.Series([np.nan]).sum(min_count=1)</span>
<span class="s2">nan&quot;&quot;&quot;</span>

<span class="n">_max_examples</span> <span class="o">=</span> <span class="n">_shared_docs</span><span class="p">[</span><span class="s2">&quot;stat_func_example&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
    <span class="n">stat_func</span><span class="o">=</span><span class="s2">&quot;max&quot;</span><span class="p">,</span> <span class="n">verb</span><span class="o">=</span><span class="s2">&quot;Max&quot;</span><span class="p">,</span> <span class="n">default_output</span><span class="o">=</span><span class="mi">8</span><span class="p">,</span> <span class="n">level_output_0</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">level_output_1</span><span class="o">=</span><span class="mi">8</span>
<span class="p">)</span>

<span class="n">_min_examples</span> <span class="o">=</span> <span class="n">_shared_docs</span><span class="p">[</span><span class="s2">&quot;stat_func_example&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
    <span class="n">stat_func</span><span class="o">=</span><span class="s2">&quot;min&quot;</span><span class="p">,</span> <span class="n">verb</span><span class="o">=</span><span class="s2">&quot;Min&quot;</span><span class="p">,</span> <span class="n">default_output</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">level_output_0</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">level_output_1</span><span class="o">=</span><span class="mi">0</span>
<span class="p">)</span>

<span class="n">_stat_func_see_also</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;</span>

<span class="s2">See Also</span>
<span class="s2">--------</span>
<span class="s2">Series.sum : Return the sum.</span>
<span class="s2">Series.min : Return the minimum.</span>
<span class="s2">Series.max : Return the maximum.</span>
<span class="s2">Series.idxmin : Return the index of the minimum.</span>
<span class="s2">Series.idxmax : Return the index of the maximum.</span>
<span class="s2">DataFrame.sum : Return the sum over the requested axis.</span>
<span class="s2">DataFrame.min : Return the minimum over the requested axis.</span>
<span class="s2">DataFrame.max : Return the maximum over the requested axis.</span>
<span class="s2">DataFrame.idxmin : Return the index of the minimum over the requested axis.</span>
<span class="s2">DataFrame.idxmax : Return the index of the maximum over the requested axis.&quot;&quot;&quot;</span>

<span class="n">_prod_examples</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;</span>

<span class="s2">Examples</span>
<span class="s2">--------</span>
<span class="s2">By default, the product of an empty or all-NA Series is ``1``</span>

<span class="s2">&gt;&gt;&gt; pd.Series([]).prod()</span>
<span class="s2">1.0</span>

<span class="s2">This can be controlled with the ``min_count`` parameter</span>

<span class="s2">&gt;&gt;&gt; pd.Series([]).prod(min_count=1)</span>
<span class="s2">nan</span>

<span class="s2">Thanks to the ``skipna`` parameter, ``min_count`` handles all-NA and</span>
<span class="s2">empty series identically.</span>

<span class="s2">&gt;&gt;&gt; pd.Series([np.nan]).prod()</span>
<span class="s2">1.0</span>

<span class="s2">&gt;&gt;&gt; pd.Series([np.nan]).prod(min_count=1)</span>
<span class="s2">nan&quot;&quot;&quot;</span>

<span class="n">_min_count_stub</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;</span><span class="se">\</span>
<span class="s2">min_count : int, default 0</span>
<span class="s2">    The required number of valid values to perform the operation. If fewer than</span>
<span class="s2">    ``min_count`` non-NA values are present the result will be NA.</span>

<span class="s2">    .. versionadded :: 0.22.0</span>

<span class="s2">       Added with the default being 0. This means the sum of an all-NA</span>
<span class="s2">       or empty Series is 0, and the product of an all-NA or empty</span>
<span class="s2">       Series is 1.</span>
<span class="s2">&quot;&quot;&quot;</span>


<span class="k">def</span> <span class="nf">_make_min_count_stat_function</span><span class="p">(</span>
    <span class="bp">cls</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">name1</span><span class="p">,</span> <span class="n">name2</span><span class="p">,</span> <span class="n">axis_descr</span><span class="p">,</span> <span class="n">desc</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">see_also</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">,</span> <span class="n">examples</span><span class="o">=</span><span class="s2">&quot;&quot;</span>
<span class="p">):</span>
    <span class="nd">@Substitution</span><span class="p">(</span>
        <span class="n">desc</span><span class="o">=</span><span class="n">desc</span><span class="p">,</span>
        <span class="n">name1</span><span class="o">=</span><span class="n">name1</span><span class="p">,</span>
        <span class="n">name2</span><span class="o">=</span><span class="n">name2</span><span class="p">,</span>
        <span class="n">axis_descr</span><span class="o">=</span><span class="n">axis_descr</span><span class="p">,</span>
        <span class="n">min_count</span><span class="o">=</span><span class="n">_min_count_stub</span><span class="p">,</span>
        <span class="n">see_also</span><span class="o">=</span><span class="n">see_also</span><span class="p">,</span>
        <span class="n">examples</span><span class="o">=</span><span class="n">examples</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="nd">@Appender</span><span class="p">(</span><span class="n">_num_doc</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">stat_func</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">axis</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">skipna</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">level</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">numeric_only</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">min_count</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span>
    <span class="p">):</span>
        <span class="k">if</span> <span class="n">name</span> <span class="o">==</span> <span class="s2">&quot;sum&quot;</span><span class="p">:</span>
            <span class="n">nv</span><span class="o">.</span><span class="n">validate_sum</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(),</span> <span class="n">kwargs</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">name</span> <span class="o">==</span> <span class="s2">&quot;prod&quot;</span><span class="p">:</span>
            <span class="n">nv</span><span class="o">.</span><span class="n">validate_prod</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(),</span> <span class="n">kwargs</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">nv</span><span class="o">.</span><span class="n">validate_stat_func</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(),</span> <span class="n">kwargs</span><span class="p">,</span> <span class="n">fname</span><span class="o">=</span><span class="n">name</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">skipna</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">skipna</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">if</span> <span class="n">axis</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">axis</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_stat_axis_number</span>
        <span class="k">if</span> <span class="n">level</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_agg_by_level</span><span class="p">(</span>
                <span class="n">name</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">level</span><span class="o">=</span><span class="n">level</span><span class="p">,</span> <span class="n">skipna</span><span class="o">=</span><span class="n">skipna</span><span class="p">,</span> <span class="n">min_count</span><span class="o">=</span><span class="n">min_count</span>
            <span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_reduce</span><span class="p">(</span>
            <span class="n">f</span><span class="p">,</span>
            <span class="n">name</span><span class="p">,</span>
            <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span>
            <span class="n">skipna</span><span class="o">=</span><span class="n">skipna</span><span class="p">,</span>
            <span class="n">numeric_only</span><span class="o">=</span><span class="n">numeric_only</span><span class="p">,</span>
            <span class="n">min_count</span><span class="o">=</span><span class="n">min_count</span><span class="p">,</span>
        <span class="p">)</span>

    <span class="k">return</span> <span class="n">set_function_name</span><span class="p">(</span><span class="n">stat_func</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="bp">cls</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_make_stat_function</span><span class="p">(</span>
    <span class="bp">cls</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">name1</span><span class="p">,</span> <span class="n">name2</span><span class="p">,</span> <span class="n">axis_descr</span><span class="p">,</span> <span class="n">desc</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">see_also</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">,</span> <span class="n">examples</span><span class="o">=</span><span class="s2">&quot;&quot;</span>
<span class="p">):</span>
    <span class="nd">@Substitution</span><span class="p">(</span>
        <span class="n">desc</span><span class="o">=</span><span class="n">desc</span><span class="p">,</span>
        <span class="n">name1</span><span class="o">=</span><span class="n">name1</span><span class="p">,</span>
        <span class="n">name2</span><span class="o">=</span><span class="n">name2</span><span class="p">,</span>
        <span class="n">axis_descr</span><span class="o">=</span><span class="n">axis_descr</span><span class="p">,</span>
        <span class="n">min_count</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">,</span>
        <span class="n">see_also</span><span class="o">=</span><span class="n">see_also</span><span class="p">,</span>
        <span class="n">examples</span><span class="o">=</span><span class="n">examples</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="nd">@Appender</span><span class="p">(</span><span class="n">_num_doc</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">stat_func</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">skipna</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">level</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">numeric_only</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span>
    <span class="p">):</span>
        <span class="k">if</span> <span class="n">name</span> <span class="o">==</span> <span class="s2">&quot;median&quot;</span><span class="p">:</span>
            <span class="n">nv</span><span class="o">.</span><span class="n">validate_median</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(),</span> <span class="n">kwargs</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">nv</span><span class="o">.</span><span class="n">validate_stat_func</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(),</span> <span class="n">kwargs</span><span class="p">,</span> <span class="n">fname</span><span class="o">=</span><span class="n">name</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">skipna</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">skipna</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">if</span> <span class="n">axis</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">axis</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_stat_axis_number</span>
        <span class="k">if</span> <span class="n">level</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_agg_by_level</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">level</span><span class="o">=</span><span class="n">level</span><span class="p">,</span> <span class="n">skipna</span><span class="o">=</span><span class="n">skipna</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_reduce</span><span class="p">(</span>
            <span class="n">f</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">skipna</span><span class="o">=</span><span class="n">skipna</span><span class="p">,</span> <span class="n">numeric_only</span><span class="o">=</span><span class="n">numeric_only</span>
        <span class="p">)</span>

    <span class="k">return</span> <span class="n">set_function_name</span><span class="p">(</span><span class="n">stat_func</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="bp">cls</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_make_stat_function_ddof</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">name1</span><span class="p">,</span> <span class="n">name2</span><span class="p">,</span> <span class="n">axis_descr</span><span class="p">,</span> <span class="n">desc</span><span class="p">,</span> <span class="n">f</span><span class="p">):</span>
    <span class="nd">@Substitution</span><span class="p">(</span><span class="n">desc</span><span class="o">=</span><span class="n">desc</span><span class="p">,</span> <span class="n">name1</span><span class="o">=</span><span class="n">name1</span><span class="p">,</span> <span class="n">name2</span><span class="o">=</span><span class="n">name2</span><span class="p">,</span> <span class="n">axis_descr</span><span class="o">=</span><span class="n">axis_descr</span><span class="p">)</span>
    <span class="nd">@Appender</span><span class="p">(</span><span class="n">_num_ddof_doc</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">stat_func</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">skipna</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">level</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">ddof</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">numeric_only</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span>
    <span class="p">):</span>
        <span class="n">nv</span><span class="o">.</span><span class="n">validate_stat_ddof_func</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(),</span> <span class="n">kwargs</span><span class="p">,</span> <span class="n">fname</span><span class="o">=</span><span class="n">name</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">skipna</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">skipna</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">if</span> <span class="n">axis</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">axis</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_stat_axis_number</span>
        <span class="k">if</span> <span class="n">level</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_agg_by_level</span><span class="p">(</span>
                <span class="n">name</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">level</span><span class="o">=</span><span class="n">level</span><span class="p">,</span> <span class="n">skipna</span><span class="o">=</span><span class="n">skipna</span><span class="p">,</span> <span class="n">ddof</span><span class="o">=</span><span class="n">ddof</span>
            <span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_reduce</span><span class="p">(</span>
            <span class="n">f</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">numeric_only</span><span class="o">=</span><span class="n">numeric_only</span><span class="p">,</span> <span class="n">skipna</span><span class="o">=</span><span class="n">skipna</span><span class="p">,</span> <span class="n">ddof</span><span class="o">=</span><span class="n">ddof</span>
        <span class="p">)</span>

    <span class="k">return</span> <span class="n">set_function_name</span><span class="p">(</span><span class="n">stat_func</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="bp">cls</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_make_cum_function</span><span class="p">(</span>
    <span class="bp">cls</span><span class="p">,</span>
    <span class="n">name</span><span class="p">,</span>
    <span class="n">name1</span><span class="p">,</span>
    <span class="n">name2</span><span class="p">,</span>
    <span class="n">axis_descr</span><span class="p">,</span>
    <span class="n">desc</span><span class="p">,</span>
    <span class="n">accum_func</span><span class="p">,</span>
    <span class="n">accum_func_name</span><span class="p">,</span>
    <span class="n">mask_a</span><span class="p">,</span>
    <span class="n">mask_b</span><span class="p">,</span>
    <span class="n">examples</span><span class="p">,</span>
<span class="p">):</span>
    <span class="nd">@Substitution</span><span class="p">(</span>
        <span class="n">desc</span><span class="o">=</span><span class="n">desc</span><span class="p">,</span>
        <span class="n">name1</span><span class="o">=</span><span class="n">name1</span><span class="p">,</span>
        <span class="n">name2</span><span class="o">=</span><span class="n">name2</span><span class="p">,</span>
        <span class="n">axis_descr</span><span class="o">=</span><span class="n">axis_descr</span><span class="p">,</span>
        <span class="n">accum_func_name</span><span class="o">=</span><span class="n">accum_func_name</span><span class="p">,</span>
        <span class="n">examples</span><span class="o">=</span><span class="n">examples</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="nd">@Appender</span><span class="p">(</span><span class="n">_cnum_doc</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">cum_func</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">skipna</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="n">skipna</span> <span class="o">=</span> <span class="n">nv</span><span class="o">.</span><span class="n">validate_cum_func_with_skipna</span><span class="p">(</span><span class="n">skipna</span><span class="p">,</span> <span class="n">args</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">axis</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">axis</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_stat_axis_number</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">axis</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_axis_number</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span>

        <span class="n">y</span> <span class="o">=</span> <span class="n">com</span><span class="o">.</span><span class="n">values_from_object</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">skipna</span> <span class="ow">and</span> <span class="nb">issubclass</span><span class="p">(</span><span class="n">y</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">type</span><span class="p">,</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">datetime64</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">timedelta64</span><span class="p">)):</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">accum_func</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">axis</span><span class="p">)</span>
            <span class="n">mask</span> <span class="o">=</span> <span class="n">isna</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
            <span class="n">np</span><span class="o">.</span><span class="n">putmask</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">mask</span><span class="p">,</span> <span class="n">iNaT</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">skipna</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">issubclass</span><span class="p">(</span><span class="n">y</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">type</span><span class="p">,</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">integer</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">bool_</span><span class="p">)):</span>
            <span class="n">mask</span> <span class="o">=</span> <span class="n">isna</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
            <span class="n">np</span><span class="o">.</span><span class="n">putmask</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">mask</span><span class="p">,</span> <span class="n">mask_a</span><span class="p">)</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">accum_func</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">axis</span><span class="p">)</span>
            <span class="n">np</span><span class="o">.</span><span class="n">putmask</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">mask</span><span class="p">,</span> <span class="n">mask_b</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">accum_func</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">axis</span><span class="p">)</span>

        <span class="n">d</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_construct_axes_dict</span><span class="p">()</span>
        <span class="n">d</span><span class="p">[</span><span class="s2">&quot;copy&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_constructor</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="o">**</span><span class="n">d</span><span class="p">)</span><span class="o">.</span><span class="n">__finalize__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">set_function_name</span><span class="p">(</span><span class="n">cum_func</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="bp">cls</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_make_logical_function</span><span class="p">(</span>
    <span class="bp">cls</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">name1</span><span class="p">,</span> <span class="n">name2</span><span class="p">,</span> <span class="n">axis_descr</span><span class="p">,</span> <span class="n">desc</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">see_also</span><span class="p">,</span> <span class="n">examples</span><span class="p">,</span> <span class="n">empty_value</span>
<span class="p">):</span>
    <span class="nd">@Substitution</span><span class="p">(</span>
        <span class="n">desc</span><span class="o">=</span><span class="n">desc</span><span class="p">,</span>
        <span class="n">name1</span><span class="o">=</span><span class="n">name1</span><span class="p">,</span>
        <span class="n">name2</span><span class="o">=</span><span class="n">name2</span><span class="p">,</span>
        <span class="n">axis_descr</span><span class="o">=</span><span class="n">axis_descr</span><span class="p">,</span>
        <span class="n">see_also</span><span class="o">=</span><span class="n">see_also</span><span class="p">,</span>
        <span class="n">examples</span><span class="o">=</span><span class="n">examples</span><span class="p">,</span>
        <span class="n">empty_value</span><span class="o">=</span><span class="n">empty_value</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="nd">@Appender</span><span class="p">(</span><span class="n">_bool_doc</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">logical_func</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">bool_only</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">skipna</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">level</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="n">nv</span><span class="o">.</span><span class="n">validate_logical_func</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(),</span> <span class="n">kwargs</span><span class="p">,</span> <span class="n">fname</span><span class="o">=</span><span class="n">name</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">level</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">bool_only</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span>
                    <span class="s2">&quot;Option bool_only is not &quot;</span> <span class="s2">&quot;implemented with option level.&quot;</span>
                <span class="p">)</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_agg_by_level</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">level</span><span class="o">=</span><span class="n">level</span><span class="p">,</span> <span class="n">skipna</span><span class="o">=</span><span class="n">skipna</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_reduce</span><span class="p">(</span>
            <span class="n">f</span><span class="p">,</span>
            <span class="n">name</span><span class="p">,</span>
            <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span>
            <span class="n">skipna</span><span class="o">=</span><span class="n">skipna</span><span class="p">,</span>
            <span class="n">numeric_only</span><span class="o">=</span><span class="n">bool_only</span><span class="p">,</span>
            <span class="n">filter_type</span><span class="o">=</span><span class="s2">&quot;bool&quot;</span><span class="p">,</span>
        <span class="p">)</span>

    <span class="k">return</span> <span class="n">set_function_name</span><span class="p">(</span><span class="n">logical_func</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="bp">cls</span><span class="p">)</span>


<span class="c1"># install the indexes</span>
<span class="k">for</span> <span class="n">_name</span><span class="p">,</span> <span class="n">_indexer</span> <span class="ow">in</span> <span class="n">indexing</span><span class="o">.</span><span class="n">get_indexers_list</span><span class="p">():</span>
    <span class="n">NDFrame</span><span class="o">.</span><span class="n">_create_indexer</span><span class="p">(</span><span class="n">_name</span><span class="p">,</span> <span class="n">_indexer</span><span class="p">)</span>
</pre></div>

           </div>
           
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2020, observethesun

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>