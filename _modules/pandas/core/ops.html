

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>pandas.core.ops &mdash; helio  documentation</title>
  

  
  
  
  

  
  <script type="text/javascript" src="../../../_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../../../" src="../../../_static/documentation_options.js"></script>
        <script src="../../../_static/jquery.js"></script>
        <script src="../../../_static/underscore.js"></script>
        <script src="../../../_static/doctools.js"></script>
        <script src="../../../_static/language_data.js"></script>
    
    <script type="text/javascript" src="../../../_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="../../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../../../index.html" class="icon icon-home"> helio
          

          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../../api/helio.html">API</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">helio</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../../index.html">Docs</a> &raquo;</li>
        
          <li><a href="../../index.html">Module code</a> &raquo;</li>
        
      <li>pandas.core.ops</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for pandas.core.ops</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Arithmetic operations for PandasObjects</span>

<span class="sd">This is not a public API.</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="kn">import</span> <span class="nn">datetime</span>
<span class="kn">import</span> <span class="nn">operator</span>
<span class="kn">import</span> <span class="nn">textwrap</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="k">import</span> <span class="n">Any</span><span class="p">,</span> <span class="n">Callable</span>
<span class="kn">import</span> <span class="nn">warnings</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>

<span class="kn">from</span> <span class="nn">pandas._libs</span> <span class="k">import</span> <span class="n">Timedelta</span><span class="p">,</span> <span class="n">Timestamp</span><span class="p">,</span> <span class="n">lib</span><span class="p">,</span> <span class="n">ops</span> <span class="k">as</span> <span class="n">libops</span>
<span class="kn">from</span> <span class="nn">pandas.errors</span> <span class="k">import</span> <span class="n">NullFrequencyError</span>
<span class="kn">from</span> <span class="nn">pandas.util._decorators</span> <span class="k">import</span> <span class="n">Appender</span>

<span class="kn">from</span> <span class="nn">pandas.core.dtypes.cast</span> <span class="k">import</span> <span class="p">(</span>
    <span class="n">construct_1d_object_array_from_listlike</span><span class="p">,</span>
    <span class="n">find_common_type</span><span class="p">,</span>
    <span class="n">maybe_upcast_putmask</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">from</span> <span class="nn">pandas.core.dtypes.common</span> <span class="k">import</span> <span class="p">(</span>
    <span class="n">ensure_object</span><span class="p">,</span>
    <span class="n">is_bool_dtype</span><span class="p">,</span>
    <span class="n">is_categorical_dtype</span><span class="p">,</span>
    <span class="n">is_datetime64_dtype</span><span class="p">,</span>
    <span class="n">is_datetime64tz_dtype</span><span class="p">,</span>
    <span class="n">is_datetimelike_v_numeric</span><span class="p">,</span>
    <span class="n">is_extension_array_dtype</span><span class="p">,</span>
    <span class="n">is_integer_dtype</span><span class="p">,</span>
    <span class="n">is_list_like</span><span class="p">,</span>
    <span class="n">is_object_dtype</span><span class="p">,</span>
    <span class="n">is_period_dtype</span><span class="p">,</span>
    <span class="n">is_scalar</span><span class="p">,</span>
    <span class="n">is_timedelta64_dtype</span><span class="p">,</span>
    <span class="n">needs_i8_conversion</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">from</span> <span class="nn">pandas.core.dtypes.generic</span> <span class="k">import</span> <span class="p">(</span>
    <span class="n">ABCDataFrame</span><span class="p">,</span>
    <span class="n">ABCDatetimeArray</span><span class="p">,</span>
    <span class="n">ABCIndex</span><span class="p">,</span>
    <span class="n">ABCIndexClass</span><span class="p">,</span>
    <span class="n">ABCSeries</span><span class="p">,</span>
    <span class="n">ABCSparseArray</span><span class="p">,</span>
    <span class="n">ABCSparseSeries</span><span class="p">,</span>
    <span class="n">ABCTimedeltaArray</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">from</span> <span class="nn">pandas.core.dtypes.missing</span> <span class="k">import</span> <span class="n">isna</span><span class="p">,</span> <span class="n">notna</span>

<span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>
<span class="kn">from</span> <span class="nn">pandas._typing</span> <span class="k">import</span> <span class="n">ArrayLike</span>
<span class="kn">import</span> <span class="nn">pandas.core.common</span> <span class="k">as</span> <span class="nn">com</span>

<span class="kn">from</span> <span class="nn">.</span> <span class="k">import</span> <span class="n">missing</span>
<span class="kn">from</span> <span class="nn">.docstrings</span> <span class="k">import</span> <span class="p">(</span>
    <span class="n">_arith_doc_FRAME</span><span class="p">,</span>
    <span class="n">_flex_comp_doc_FRAME</span><span class="p">,</span>
    <span class="n">_make_flex_doc</span><span class="p">,</span>
    <span class="n">_op_descriptions</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">from</span> <span class="nn">.roperator</span> <span class="k">import</span> <span class="p">(</span>  <span class="c1"># noqa:F401</span>
    <span class="n">radd</span><span class="p">,</span>
    <span class="n">rand_</span><span class="p">,</span>
    <span class="n">rdiv</span><span class="p">,</span>
    <span class="n">rdivmod</span><span class="p">,</span>
    <span class="n">rfloordiv</span><span class="p">,</span>
    <span class="n">rmod</span><span class="p">,</span>
    <span class="n">rmul</span><span class="p">,</span>
    <span class="n">ror_</span><span class="p">,</span>
    <span class="n">rpow</span><span class="p">,</span>
    <span class="n">rsub</span><span class="p">,</span>
    <span class="n">rtruediv</span><span class="p">,</span>
    <span class="n">rxor</span><span class="p">,</span>
<span class="p">)</span>

<span class="c1"># -----------------------------------------------------------------------------</span>
<span class="c1"># Ops Wrapping Utilities</span>


<span class="k">def</span> <span class="nf">get_op_result_name</span><span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Find the appropriate name to pin to an operation result.  This result</span>
<span class="sd">    should always be either an Index or a Series.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    left : {Series, Index}</span>
<span class="sd">    right : object</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    name : object</span>
<span class="sd">        Usually a string</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># `left` is always a pd.Series when called from within ops</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">right</span><span class="p">,</span> <span class="p">(</span><span class="n">ABCSeries</span><span class="p">,</span> <span class="n">ABCIndexClass</span><span class="p">)):</span>
        <span class="n">name</span> <span class="o">=</span> <span class="n">_maybe_match_name</span><span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">name</span> <span class="o">=</span> <span class="n">left</span><span class="o">.</span><span class="n">name</span>
    <span class="k">return</span> <span class="n">name</span>


<span class="k">def</span> <span class="nf">_maybe_match_name</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Try to find a name to attach to the result of an operation between</span>
<span class="sd">    a and b.  If only one of these has a `name` attribute, return that</span>
<span class="sd">    name.  Otherwise return a consensus name if they match of None if</span>
<span class="sd">    they have different names.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    a : object</span>
<span class="sd">    b : object</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    name : str or None</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    pandas.core.common.consensus_name_attr</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">a_has</span> <span class="o">=</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="s2">&quot;name&quot;</span><span class="p">)</span>
    <span class="n">b_has</span> <span class="o">=</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="s2">&quot;name&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">a_has</span> <span class="ow">and</span> <span class="n">b_has</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">a</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="n">b</span><span class="o">.</span><span class="n">name</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">a</span><span class="o">.</span><span class="n">name</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># TODO: what if they both have np.nan for their names?</span>
            <span class="k">return</span> <span class="kc">None</span>
    <span class="k">elif</span> <span class="n">a_has</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">a</span><span class="o">.</span><span class="n">name</span>
    <span class="k">elif</span> <span class="n">b_has</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">b</span><span class="o">.</span><span class="n">name</span>
    <span class="k">return</span> <span class="kc">None</span>


<span class="k">def</span> <span class="nf">maybe_upcast_for_op</span><span class="p">(</span><span class="n">obj</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Cast non-pandas objects to pandas types to unify behavior of arithmetic</span>
<span class="sd">    and comparison operations.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    obj: object</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    out : object</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    Be careful to call this *after* determining the `name` attribute to be</span>
<span class="sd">    attached to the result of the arithmetic operation.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span> <span class="ow">is</span> <span class="n">datetime</span><span class="o">.</span><span class="n">timedelta</span><span class="p">:</span>
        <span class="c1"># GH#22390  cast up to Timedelta to rely on Timedelta</span>
        <span class="c1"># implementation; otherwise operation against numeric-dtype</span>
        <span class="c1"># raises TypeError</span>
        <span class="k">return</span> <span class="n">Timedelta</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">timedelta64</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">isna</span><span class="p">(</span><span class="n">obj</span><span class="p">):</span>
        <span class="c1"># In particular non-nanosecond timedelta64 needs to be cast to</span>
        <span class="c1">#  nanoseconds, or else we get undesired behavior like</span>
        <span class="c1">#  np.timedelta64(3, &#39;D&#39;) / 2 == np.timedelta64(1, &#39;D&#39;)</span>
        <span class="c1"># The isna check is to avoid casting timedelta64(&quot;NaT&quot;), which would</span>
        <span class="c1">#  return NaT and incorrectly be treated as a datetime-NaT.</span>
        <span class="k">return</span> <span class="n">Timedelta</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="ow">and</span> <span class="n">is_timedelta64_dtype</span><span class="p">(</span><span class="n">obj</span><span class="p">):</span>
        <span class="c1"># GH#22390 Unfortunately we need to special-case right-hand</span>
        <span class="c1"># timedelta64 dtypes because numpy casts integer dtypes to</span>
        <span class="c1"># timedelta64 when operating with timedelta64</span>
        <span class="k">return</span> <span class="n">pd</span><span class="o">.</span><span class="n">TimedeltaIndex</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">obj</span>


<span class="c1"># -----------------------------------------------------------------------------</span>


<span class="k">def</span> <span class="nf">make_invalid_op</span><span class="p">(</span><span class="n">name</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return a binary method that always raises a TypeError.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    name : str</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    invalid_op : function</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">invalid_op</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
            <span class="s2">&quot;cannot perform </span><span class="si">{name}</span><span class="s2"> with this index type: &quot;</span>
            <span class="s2">&quot;</span><span class="si">{typ}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">,</span> <span class="n">typ</span><span class="o">=</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="p">)</span>
        <span class="p">)</span>

    <span class="n">invalid_op</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">=</span> <span class="n">name</span>
    <span class="k">return</span> <span class="n">invalid_op</span>


<span class="k">def</span> <span class="nf">_gen_eval_kwargs</span><span class="p">(</span><span class="n">name</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Find the keyword arguments to pass to numexpr for the given operation.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    name : str</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    eval_kwargs : dict</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; _gen_eval_kwargs(&quot;__add__&quot;)</span>
<span class="sd">    {}</span>

<span class="sd">    &gt;&gt;&gt; _gen_eval_kwargs(&quot;rtruediv&quot;)</span>
<span class="sd">    {&#39;reversed&#39;: True, &#39;truediv&#39;: True}</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">kwargs</span> <span class="o">=</span> <span class="p">{}</span>

    <span class="c1"># Series appear to only pass __add__, __radd__, ...</span>
    <span class="c1"># but DataFrame gets both these dunder names _and_ non-dunder names</span>
    <span class="c1"># add, radd, ...</span>
    <span class="n">name</span> <span class="o">=</span> <span class="n">name</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;__&quot;</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">name</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;r&quot;</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;radd&quot;</span><span class="p">,</span> <span class="s2">&quot;rand&quot;</span><span class="p">,</span> <span class="s2">&quot;ror&quot;</span><span class="p">,</span> <span class="s2">&quot;rxor&quot;</span><span class="p">]:</span>
            <span class="c1"># Exclude commutative operations</span>
            <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;reversed&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>

    <span class="k">if</span> <span class="n">name</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;truediv&quot;</span><span class="p">,</span> <span class="s2">&quot;rtruediv&quot;</span><span class="p">]:</span>
        <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;truediv&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>

    <span class="k">if</span> <span class="n">name</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;ne&quot;</span><span class="p">]:</span>
        <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;masker&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>

    <span class="k">return</span> <span class="n">kwargs</span>


<span class="k">def</span> <span class="nf">_get_frame_op_default_axis</span><span class="p">(</span><span class="n">name</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Only DataFrame cares about default_axis, specifically:</span>
<span class="sd">    special methods have default_axis=None and flex methods</span>
<span class="sd">    have default_axis=&#39;columns&#39;.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    name : str</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    default_axis: str or None</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">name</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;__r&quot;</span><span class="p">,</span> <span class="s2">&quot;__&quot;</span><span class="p">)</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;__and__&quot;</span><span class="p">,</span> <span class="s2">&quot;__or__&quot;</span><span class="p">,</span> <span class="s2">&quot;__xor__&quot;</span><span class="p">]:</span>
        <span class="c1"># bool methods</span>
        <span class="k">return</span> <span class="s2">&quot;columns&quot;</span>
    <span class="k">elif</span> <span class="n">name</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;__&quot;</span><span class="p">):</span>
        <span class="c1"># __add__, __mul__, ...</span>
        <span class="k">return</span> <span class="kc">None</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># add, mul, ...</span>
        <span class="k">return</span> <span class="s2">&quot;columns&quot;</span>


<span class="k">def</span> <span class="nf">_get_opstr</span><span class="p">(</span><span class="n">op</span><span class="p">,</span> <span class="bp">cls</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Find the operation string, if any, to pass to numexpr for this</span>
<span class="sd">    operation.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    op : binary operator</span>
<span class="sd">    cls : class</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    op_str : string or None</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># numexpr is available for non-sparse classes</span>
    <span class="n">subtyp</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="s2">&quot;_subtyp&quot;</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">)</span>
    <span class="n">use_numexpr</span> <span class="o">=</span> <span class="s2">&quot;sparse&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">subtyp</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">use_numexpr</span><span class="p">:</span>
        <span class="c1"># if we&#39;re not using numexpr, then don&#39;t pass a str_rep</span>
        <span class="k">return</span> <span class="kc">None</span>

    <span class="k">return</span> <span class="p">{</span>
        <span class="n">operator</span><span class="o">.</span><span class="n">add</span><span class="p">:</span> <span class="s2">&quot;+&quot;</span><span class="p">,</span>
        <span class="n">radd</span><span class="p">:</span> <span class="s2">&quot;+&quot;</span><span class="p">,</span>
        <span class="n">operator</span><span class="o">.</span><span class="n">mul</span><span class="p">:</span> <span class="s2">&quot;*&quot;</span><span class="p">,</span>
        <span class="n">rmul</span><span class="p">:</span> <span class="s2">&quot;*&quot;</span><span class="p">,</span>
        <span class="n">operator</span><span class="o">.</span><span class="n">sub</span><span class="p">:</span> <span class="s2">&quot;-&quot;</span><span class="p">,</span>
        <span class="n">rsub</span><span class="p">:</span> <span class="s2">&quot;-&quot;</span><span class="p">,</span>
        <span class="n">operator</span><span class="o">.</span><span class="n">truediv</span><span class="p">:</span> <span class="s2">&quot;/&quot;</span><span class="p">,</span>
        <span class="n">rtruediv</span><span class="p">:</span> <span class="s2">&quot;/&quot;</span><span class="p">,</span>
        <span class="n">operator</span><span class="o">.</span><span class="n">floordiv</span><span class="p">:</span> <span class="s2">&quot;//&quot;</span><span class="p">,</span>
        <span class="n">rfloordiv</span><span class="p">:</span> <span class="s2">&quot;//&quot;</span><span class="p">,</span>
        <span class="n">operator</span><span class="o">.</span><span class="n">mod</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span>  <span class="c1"># TODO: Why None for mod but &#39;%&#39; for rmod?</span>
        <span class="n">rmod</span><span class="p">:</span> <span class="s2">&quot;%&quot;</span><span class="p">,</span>
        <span class="n">operator</span><span class="o">.</span><span class="n">pow</span><span class="p">:</span> <span class="s2">&quot;**&quot;</span><span class="p">,</span>
        <span class="n">rpow</span><span class="p">:</span> <span class="s2">&quot;**&quot;</span><span class="p">,</span>
        <span class="n">operator</span><span class="o">.</span><span class="n">eq</span><span class="p">:</span> <span class="s2">&quot;==&quot;</span><span class="p">,</span>
        <span class="n">operator</span><span class="o">.</span><span class="n">ne</span><span class="p">:</span> <span class="s2">&quot;!=&quot;</span><span class="p">,</span>
        <span class="n">operator</span><span class="o">.</span><span class="n">le</span><span class="p">:</span> <span class="s2">&quot;&lt;=&quot;</span><span class="p">,</span>
        <span class="n">operator</span><span class="o">.</span><span class="n">lt</span><span class="p">:</span> <span class="s2">&quot;&lt;&quot;</span><span class="p">,</span>
        <span class="n">operator</span><span class="o">.</span><span class="n">ge</span><span class="p">:</span> <span class="s2">&quot;&gt;=&quot;</span><span class="p">,</span>
        <span class="n">operator</span><span class="o">.</span><span class="n">gt</span><span class="p">:</span> <span class="s2">&quot;&gt;&quot;</span><span class="p">,</span>
        <span class="n">operator</span><span class="o">.</span><span class="n">and_</span><span class="p">:</span> <span class="s2">&quot;&amp;&quot;</span><span class="p">,</span>
        <span class="n">rand_</span><span class="p">:</span> <span class="s2">&quot;&amp;&quot;</span><span class="p">,</span>
        <span class="n">operator</span><span class="o">.</span><span class="n">or_</span><span class="p">:</span> <span class="s2">&quot;|&quot;</span><span class="p">,</span>
        <span class="n">ror_</span><span class="p">:</span> <span class="s2">&quot;|&quot;</span><span class="p">,</span>
        <span class="n">operator</span><span class="o">.</span><span class="n">xor</span><span class="p">:</span> <span class="s2">&quot;^&quot;</span><span class="p">,</span>
        <span class="n">rxor</span><span class="p">:</span> <span class="s2">&quot;^&quot;</span><span class="p">,</span>
        <span class="nb">divmod</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">rdivmod</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">}[</span><span class="n">op</span><span class="p">]</span>


<span class="k">def</span> <span class="nf">_get_op_name</span><span class="p">(</span><span class="n">op</span><span class="p">,</span> <span class="n">special</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Find the name to attach to this method according to conventions</span>
<span class="sd">    for special and non-special methods.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    op : binary operator</span>
<span class="sd">    special : bool</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    op_name : str</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">opname</span> <span class="o">=</span> <span class="n">op</span><span class="o">.</span><span class="vm">__name__</span><span class="o">.</span><span class="n">strip</span><span class="p">(</span><span class="s2">&quot;_&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">special</span><span class="p">:</span>
        <span class="n">opname</span> <span class="o">=</span> <span class="s2">&quot;__</span><span class="si">{opname}</span><span class="s2">__&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">opname</span><span class="o">=</span><span class="n">opname</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">opname</span>


<span class="c1"># -----------------------------------------------------------------------------</span>
<span class="c1"># Masking NA values and fallbacks for operations numpy does not support</span>


<span class="k">def</span> <span class="nf">fill_binop</span><span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">,</span> <span class="n">fill_value</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    If a non-None fill_value is given, replace null entries in left and right</span>
<span class="sd">    with this value, but only in positions where _one_ of left/right is null,</span>
<span class="sd">    not both.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    left : array-like</span>
<span class="sd">    right : array-like</span>
<span class="sd">    fill_value : object</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    left : array-like</span>
<span class="sd">    right : array-like</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    Makes copies if fill_value is not None</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># TODO: can we make a no-copy implementation?</span>
    <span class="k">if</span> <span class="n">fill_value</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">left_mask</span> <span class="o">=</span> <span class="n">isna</span><span class="p">(</span><span class="n">left</span><span class="p">)</span>
        <span class="n">right_mask</span> <span class="o">=</span> <span class="n">isna</span><span class="p">(</span><span class="n">right</span><span class="p">)</span>
        <span class="n">left</span> <span class="o">=</span> <span class="n">left</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">right</span> <span class="o">=</span> <span class="n">right</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

        <span class="c1"># one but not both</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="n">left_mask</span> <span class="o">^</span> <span class="n">right_mask</span>
        <span class="n">left</span><span class="p">[</span><span class="n">left_mask</span> <span class="o">&amp;</span> <span class="n">mask</span><span class="p">]</span> <span class="o">=</span> <span class="n">fill_value</span>
        <span class="n">right</span><span class="p">[</span><span class="n">right_mask</span> <span class="o">&amp;</span> <span class="n">mask</span><span class="p">]</span> <span class="o">=</span> <span class="n">fill_value</span>
    <span class="k">return</span> <span class="n">left</span><span class="p">,</span> <span class="n">right</span>


<span class="k">def</span> <span class="nf">mask_cmp_op</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">op</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Apply the function `op` to only non-null points in x and y.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x : array-like</span>
<span class="sd">    y : array-like</span>
<span class="sd">    op : binary operation</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    result : ndarray[bool]</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">xrav</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">ABCSeries</span><span class="p">)):</span>
        <span class="n">yrav</span> <span class="o">=</span> <span class="n">y</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="n">notna</span><span class="p">(</span><span class="n">xrav</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">notna</span><span class="p">(</span><span class="n">yrav</span><span class="p">)</span>
        <span class="n">result</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span> <span class="o">=</span> <span class="n">op</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">xrav</span><span class="p">[</span><span class="n">mask</span><span class="p">])),</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">yrav</span><span class="p">[</span><span class="n">mask</span><span class="p">])))</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="n">notna</span><span class="p">(</span><span class="n">xrav</span><span class="p">)</span>
        <span class="n">result</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span> <span class="o">=</span> <span class="n">op</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">xrav</span><span class="p">[</span><span class="n">mask</span><span class="p">])),</span> <span class="n">y</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">op</span> <span class="o">==</span> <span class="n">operator</span><span class="o">.</span><span class="n">ne</span><span class="p">:</span>  <span class="c1"># pragma: no cover</span>
        <span class="n">np</span><span class="o">.</span><span class="n">putmask</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="o">~</span><span class="n">mask</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">np</span><span class="o">.</span><span class="n">putmask</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="o">~</span><span class="n">mask</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">result</span>


<span class="k">def</span> <span class="nf">masked_arith_op</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">op</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    If the given arithmetic operation fails, attempt it again on</span>
<span class="sd">    only the non-null elements of the input array(s).</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x : np.ndarray</span>
<span class="sd">    y : np.ndarray, Series, Index</span>
<span class="sd">    op : binary operator</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># For Series `x` is 1D so ravel() is a no-op; calling it anyway makes</span>
    <span class="c1"># the logic valid for both Series and DataFrame ops.</span>
    <span class="n">xrav</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>
    <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">ABCSeries</span><span class="p">)),</span> <span class="nb">type</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">ABCSeries</span><span class="p">,</span> <span class="n">ABCIndexClass</span><span class="p">)):</span>
        <span class="n">dtype</span> <span class="o">=</span> <span class="n">find_common_type</span><span class="p">([</span><span class="n">x</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">y</span><span class="o">.</span><span class="n">dtype</span><span class="p">])</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>

        <span class="c1"># PeriodIndex.ravel() returns int64 dtype, so we have</span>
        <span class="c1"># to work around that case.  See GH#19956</span>
        <span class="n">yrav</span> <span class="o">=</span> <span class="n">y</span> <span class="k">if</span> <span class="n">is_period_dtype</span><span class="p">(</span><span class="n">y</span><span class="p">)</span> <span class="k">else</span> <span class="n">y</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="n">notna</span><span class="p">(</span><span class="n">xrav</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">notna</span><span class="p">(</span><span class="n">yrav</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">yrav</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="n">mask</span><span class="o">.</span><span class="n">shape</span><span class="p">:</span>
            <span class="c1"># FIXME: GH#5284, GH#5035, GH#19448</span>
            <span class="c1"># Without specifically raising here we get mismatched</span>
            <span class="c1"># errors in Py3 (TypeError) vs Py2 (ValueError)</span>
            <span class="c1"># Note: Only = an issue in DataFrame case</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Cannot broadcast operands together.&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">mask</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
            <span class="k">with</span> <span class="n">np</span><span class="o">.</span><span class="n">errstate</span><span class="p">(</span><span class="nb">all</span><span class="o">=</span><span class="s2">&quot;ignore&quot;</span><span class="p">):</span>
                <span class="n">result</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span> <span class="o">=</span> <span class="n">op</span><span class="p">(</span><span class="n">xrav</span><span class="p">[</span><span class="n">mask</span><span class="p">],</span> <span class="n">com</span><span class="o">.</span><span class="n">values_from_object</span><span class="p">(</span><span class="n">yrav</span><span class="p">[</span><span class="n">mask</span><span class="p">]))</span>

    <span class="k">else</span><span class="p">:</span>
        <span class="k">assert</span> <span class="n">is_scalar</span><span class="p">(</span><span class="n">y</span><span class="p">),</span> <span class="nb">type</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">),</span> <span class="nb">type</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="c1"># mask is only meaningful for x</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">x</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="n">notna</span><span class="p">(</span><span class="n">xrav</span><span class="p">)</span>

        <span class="c1"># 1 ** np.nan is 1. So we have to unmask those.</span>
        <span class="k">if</span> <span class="n">op</span> <span class="o">==</span> <span class="nb">pow</span><span class="p">:</span>
            <span class="n">mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">x</span> <span class="o">==</span> <span class="mi">1</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="n">mask</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">op</span> <span class="o">==</span> <span class="n">rpow</span><span class="p">:</span>
            <span class="n">mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">y</span> <span class="o">==</span> <span class="mi">1</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="n">mask</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">mask</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
            <span class="k">with</span> <span class="n">np</span><span class="o">.</span><span class="n">errstate</span><span class="p">(</span><span class="nb">all</span><span class="o">=</span><span class="s2">&quot;ignore&quot;</span><span class="p">):</span>
                <span class="n">result</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span> <span class="o">=</span> <span class="n">op</span><span class="p">(</span><span class="n">xrav</span><span class="p">[</span><span class="n">mask</span><span class="p">],</span> <span class="n">y</span><span class="p">)</span>

    <span class="n">result</span><span class="p">,</span> <span class="n">changed</span> <span class="o">=</span> <span class="n">maybe_upcast_putmask</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="o">~</span><span class="n">mask</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>  <span class="c1"># 2D compat</span>
    <span class="k">return</span> <span class="n">result</span>


<span class="k">def</span> <span class="nf">invalid_comparison</span><span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">,</span> <span class="n">op</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    If a comparison has mismatched types and is not necessarily meaningful,</span>
<span class="sd">    follow python3 conventions by:</span>

<span class="sd">        - returning all-False for equality</span>
<span class="sd">        - returning all-True for inequality</span>
<span class="sd">        - raising TypeError otherwise</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    left : array-like</span>
<span class="sd">    right : scalar, array-like</span>
<span class="sd">    op : operator.{eq, ne, lt, le, gt}</span>

<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    TypeError : on inequality comparisons</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">op</span> <span class="ow">is</span> <span class="n">operator</span><span class="o">.</span><span class="n">eq</span><span class="p">:</span>
        <span class="n">res_values</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">left</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">op</span> <span class="ow">is</span> <span class="n">operator</span><span class="o">.</span><span class="n">ne</span><span class="p">:</span>
        <span class="n">res_values</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">left</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
            <span class="s2">&quot;Invalid comparison between dtype=</span><span class="si">{dtype}</span><span class="s2"> and </span><span class="si">{typ}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                <span class="n">dtype</span><span class="o">=</span><span class="n">left</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">typ</span><span class="o">=</span><span class="nb">type</span><span class="p">(</span><span class="n">right</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span>
            <span class="p">)</span>
        <span class="p">)</span>
    <span class="k">return</span> <span class="n">res_values</span>


<span class="c1"># -----------------------------------------------------------------------------</span>
<span class="c1"># Dispatch logic</span>


<span class="k">def</span> <span class="nf">should_series_dispatch</span><span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">,</span> <span class="n">op</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Identify cases where a DataFrame operation should dispatch to its</span>
<span class="sd">    Series counterpart.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    left : DataFrame</span>
<span class="sd">    right : DataFrame</span>
<span class="sd">    op : binary operator</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    override : bool</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">left</span><span class="o">.</span><span class="n">_is_mixed_type</span> <span class="ow">or</span> <span class="n">right</span><span class="o">.</span><span class="n">_is_mixed_type</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">True</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="nb">len</span><span class="p">(</span><span class="n">left</span><span class="o">.</span><span class="n">columns</span><span class="p">)</span> <span class="ow">or</span> <span class="ow">not</span> <span class="nb">len</span><span class="p">(</span><span class="n">right</span><span class="o">.</span><span class="n">columns</span><span class="p">):</span>
        <span class="c1"># ensure obj.dtypes[0] exists for each obj</span>
        <span class="k">return</span> <span class="kc">False</span>

    <span class="n">ldtype</span> <span class="o">=</span> <span class="n">left</span><span class="o">.</span><span class="n">dtypes</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">rdtype</span> <span class="o">=</span> <span class="n">right</span><span class="o">.</span><span class="n">dtypes</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">is_timedelta64_dtype</span><span class="p">(</span><span class="n">ldtype</span><span class="p">)</span> <span class="ow">and</span> <span class="n">is_integer_dtype</span><span class="p">(</span><span class="n">rdtype</span><span class="p">))</span> <span class="ow">or</span> <span class="p">(</span>
        <span class="n">is_timedelta64_dtype</span><span class="p">(</span><span class="n">rdtype</span><span class="p">)</span> <span class="ow">and</span> <span class="n">is_integer_dtype</span><span class="p">(</span><span class="n">ldtype</span><span class="p">)</span>
    <span class="p">):</span>
        <span class="c1"># numpy integer dtypes as timedelta64 dtypes in this scenario</span>
        <span class="k">return</span> <span class="kc">True</span>

    <span class="k">if</span> <span class="n">is_datetime64_dtype</span><span class="p">(</span><span class="n">ldtype</span><span class="p">)</span> <span class="ow">and</span> <span class="n">is_object_dtype</span><span class="p">(</span><span class="n">rdtype</span><span class="p">):</span>
        <span class="c1"># in particular case where right is an array of DateOffsets</span>
        <span class="k">return</span> <span class="kc">True</span>

    <span class="k">return</span> <span class="kc">False</span>


<span class="k">def</span> <span class="nf">dispatch_to_series</span><span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">,</span> <span class="n">func</span><span class="p">,</span> <span class="n">str_rep</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Evaluate the frame operation func(left, right) by evaluating</span>
<span class="sd">    column-by-column, dispatching to the Series implementation.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    left : DataFrame</span>
<span class="sd">    right : scalar or DataFrame</span>
<span class="sd">    func : arithmetic or comparison operator</span>
<span class="sd">    str_rep : str or None, default None</span>
<span class="sd">    axis : {None, 0, 1, &quot;index&quot;, &quot;columns&quot;}</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    DataFrame</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Note: we use iloc to access columns for compat with cases</span>
    <span class="c1">#       with non-unique columns.</span>
    <span class="kn">import</span> <span class="nn">pandas.core.computation.expressions</span> <span class="k">as</span> <span class="nn">expressions</span>

    <span class="n">right</span> <span class="o">=</span> <span class="n">lib</span><span class="o">.</span><span class="n">item_from_zerodim</span><span class="p">(</span><span class="n">right</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">lib</span><span class="o">.</span><span class="n">is_scalar</span><span class="p">(</span><span class="n">right</span><span class="p">)</span> <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">ndim</span><span class="p">(</span><span class="n">right</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>

        <span class="k">def</span> <span class="nf">column_op</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
            <span class="k">return</span> <span class="p">{</span><span class="n">i</span><span class="p">:</span> <span class="n">func</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">iloc</span><span class="p">[:,</span> <span class="n">i</span><span class="p">],</span> <span class="n">b</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">columns</span><span class="p">))}</span>

    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">right</span><span class="p">,</span> <span class="n">ABCDataFrame</span><span class="p">):</span>
        <span class="k">assert</span> <span class="n">right</span><span class="o">.</span><span class="n">_indexed_same</span><span class="p">(</span><span class="n">left</span><span class="p">)</span>

        <span class="k">def</span> <span class="nf">column_op</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
            <span class="k">return</span> <span class="p">{</span><span class="n">i</span><span class="p">:</span> <span class="n">func</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">iloc</span><span class="p">[:,</span> <span class="n">i</span><span class="p">],</span> <span class="n">b</span><span class="o">.</span><span class="n">iloc</span><span class="p">[:,</span> <span class="n">i</span><span class="p">])</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">columns</span><span class="p">))}</span>

    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">right</span><span class="p">,</span> <span class="n">ABCSeries</span><span class="p">)</span> <span class="ow">and</span> <span class="n">axis</span> <span class="o">==</span> <span class="s2">&quot;columns&quot;</span><span class="p">:</span>
        <span class="c1"># We only get here if called via left._combine_match_columns,</span>
        <span class="c1"># in which case we specifically want to operate row-by-row</span>
        <span class="k">assert</span> <span class="n">right</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">equals</span><span class="p">(</span><span class="n">left</span><span class="o">.</span><span class="n">columns</span><span class="p">)</span>

        <span class="k">def</span> <span class="nf">column_op</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
            <span class="k">return</span> <span class="p">{</span><span class="n">i</span><span class="p">:</span> <span class="n">func</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">iloc</span><span class="p">[:,</span> <span class="n">i</span><span class="p">],</span> <span class="n">b</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">columns</span><span class="p">))}</span>

    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">right</span><span class="p">,</span> <span class="n">ABCSeries</span><span class="p">):</span>
        <span class="k">assert</span> <span class="n">right</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">equals</span><span class="p">(</span><span class="n">left</span><span class="o">.</span><span class="n">index</span><span class="p">)</span>  <span class="c1"># Handle other cases later</span>

        <span class="k">def</span> <span class="nf">column_op</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
            <span class="k">return</span> <span class="p">{</span><span class="n">i</span><span class="p">:</span> <span class="n">func</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">iloc</span><span class="p">[:,</span> <span class="n">i</span><span class="p">],</span> <span class="n">b</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">columns</span><span class="p">))}</span>

    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># Remaining cases have less-obvious dispatch rules</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="n">right</span><span class="p">)</span>

    <span class="n">new_data</span> <span class="o">=</span> <span class="n">expressions</span><span class="o">.</span><span class="n">evaluate</span><span class="p">(</span><span class="n">column_op</span><span class="p">,</span> <span class="n">str_rep</span><span class="p">,</span> <span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">)</span>

    <span class="n">result</span> <span class="o">=</span> <span class="n">left</span><span class="o">.</span><span class="n">_constructor</span><span class="p">(</span><span class="n">new_data</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="n">left</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="c1"># Pin columns instead of passing to constructor for compat with</span>
    <span class="c1"># non-unique columns case</span>
    <span class="n">result</span><span class="o">.</span><span class="n">columns</span> <span class="o">=</span> <span class="n">left</span><span class="o">.</span><span class="n">columns</span>
    <span class="k">return</span> <span class="n">result</span>


<span class="k">def</span> <span class="nf">dispatch_to_index_op</span><span class="p">(</span><span class="n">op</span><span class="p">,</span> <span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">,</span> <span class="n">index_class</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Wrap Series left in the given index_class to delegate the operation op</span>
<span class="sd">    to the index implementation.  DatetimeIndex and TimedeltaIndex perform</span>
<span class="sd">    type checking, timezone handling, overflow checks, etc.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    op : binary operator (operator.add, operator.sub, ...)</span>
<span class="sd">    left : Series</span>
<span class="sd">    right : object</span>
<span class="sd">    index_class : DatetimeIndex or TimedeltaIndex</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    result : object, usually DatetimeIndex, TimedeltaIndex, or Series</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">left_idx</span> <span class="o">=</span> <span class="n">index_class</span><span class="p">(</span><span class="n">left</span><span class="p">)</span>

    <span class="c1"># avoid accidentally allowing integer add/sub.  For datetime64[tz] dtypes,</span>
    <span class="c1"># left_idx may inherit a freq from a cached DatetimeIndex.</span>
    <span class="c1"># See discussion in GH#19147.</span>
    <span class="k">if</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">left_idx</span><span class="p">,</span> <span class="s2">&quot;freq&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">left_idx</span> <span class="o">=</span> <span class="n">left_idx</span><span class="o">.</span><span class="n">_shallow_copy</span><span class="p">(</span><span class="n">freq</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">op</span><span class="p">(</span><span class="n">left_idx</span><span class="p">,</span> <span class="n">right</span><span class="p">)</span>
    <span class="k">except</span> <span class="n">NullFrequencyError</span><span class="p">:</span>
        <span class="c1"># DatetimeIndex and TimedeltaIndex with freq == None raise ValueError</span>
        <span class="c1"># on add/sub of integers (or int-like).  We re-raise as a TypeError.</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
            <span class="s2">&quot;incompatible type for a datetime/timedelta &quot;</span>
            <span class="s2">&quot;operation [</span><span class="si">{name}</span><span class="s2">]&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="n">op</span><span class="o">.</span><span class="vm">__name__</span><span class="p">)</span>
        <span class="p">)</span>
    <span class="k">return</span> <span class="n">result</span>


<span class="k">def</span> <span class="nf">dispatch_to_extension_op</span><span class="p">(</span><span class="n">op</span><span class="p">,</span> <span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Assume that left or right is a Series backed by an ExtensionArray,</span>
<span class="sd">    apply the operator defined by op.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># The op calls will raise TypeError if the op is not defined</span>
    <span class="c1"># on the ExtensionArray</span>

    <span class="c1"># unbox Series and Index to arrays</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="p">(</span><span class="n">ABCSeries</span><span class="p">,</span> <span class="n">ABCIndexClass</span><span class="p">)):</span>
        <span class="n">new_left</span> <span class="o">=</span> <span class="n">left</span><span class="o">.</span><span class="n">_values</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">new_left</span> <span class="o">=</span> <span class="n">left</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">right</span><span class="p">,</span> <span class="p">(</span><span class="n">ABCSeries</span><span class="p">,</span> <span class="n">ABCIndexClass</span><span class="p">)):</span>
        <span class="n">new_right</span> <span class="o">=</span> <span class="n">right</span><span class="o">.</span><span class="n">_values</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">new_right</span> <span class="o">=</span> <span class="n">right</span>

    <span class="n">res_values</span> <span class="o">=</span> <span class="n">op</span><span class="p">(</span><span class="n">new_left</span><span class="p">,</span> <span class="n">new_right</span><span class="p">)</span>
    <span class="n">res_name</span> <span class="o">=</span> <span class="n">get_op_result_name</span><span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">op</span><span class="o">.</span><span class="vm">__name__</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;divmod&quot;</span><span class="p">,</span> <span class="s2">&quot;rdivmod&quot;</span><span class="p">]:</span>
        <span class="k">return</span> <span class="n">_construct_divmod_result</span><span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="n">res_values</span><span class="p">,</span> <span class="n">left</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="n">res_name</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">_construct_result</span><span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="n">res_values</span><span class="p">,</span> <span class="n">left</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="n">res_name</span><span class="p">)</span>


<span class="c1"># -----------------------------------------------------------------------------</span>
<span class="c1"># Functions that add arithmetic methods to objects, given arithmetic factory</span>
<span class="c1"># methods</span>


<span class="k">def</span> <span class="nf">_get_method_wrappers</span><span class="p">(</span><span class="bp">cls</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Find the appropriate operation-wrappers to use when defining flex/special</span>
<span class="sd">    arithmetic, boolean, and comparison operations with the given class.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    cls : class</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    arith_flex : function or None</span>
<span class="sd">    comp_flex : function or None</span>
<span class="sd">    arith_special : function</span>
<span class="sd">    comp_special : function</span>
<span class="sd">    bool_special : function</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    None is only returned for SparseArray</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">issubclass</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">ABCSparseSeries</span><span class="p">):</span>
        <span class="c1"># Be sure to catch this before ABCSeries and ABCSparseArray,</span>
        <span class="c1"># as they will both come see SparseSeries as a subclass</span>
        <span class="n">arith_flex</span> <span class="o">=</span> <span class="n">_flex_method_SERIES</span>
        <span class="n">comp_flex</span> <span class="o">=</span> <span class="n">_flex_method_SERIES</span>
        <span class="n">arith_special</span> <span class="o">=</span> <span class="n">_arith_method_SPARSE_SERIES</span>
        <span class="n">comp_special</span> <span class="o">=</span> <span class="n">_arith_method_SPARSE_SERIES</span>
        <span class="n">bool_special</span> <span class="o">=</span> <span class="n">_bool_method_SERIES</span>
        <span class="c1"># TODO: I don&#39;t think the functions defined by bool_method are tested</span>
    <span class="k">elif</span> <span class="nb">issubclass</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">ABCSeries</span><span class="p">):</span>
        <span class="c1"># Just Series; SparseSeries is caught above</span>
        <span class="n">arith_flex</span> <span class="o">=</span> <span class="n">_flex_method_SERIES</span>
        <span class="n">comp_flex</span> <span class="o">=</span> <span class="n">_flex_method_SERIES</span>
        <span class="n">arith_special</span> <span class="o">=</span> <span class="n">_arith_method_SERIES</span>
        <span class="n">comp_special</span> <span class="o">=</span> <span class="n">_comp_method_SERIES</span>
        <span class="n">bool_special</span> <span class="o">=</span> <span class="n">_bool_method_SERIES</span>
    <span class="k">elif</span> <span class="nb">issubclass</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">ABCDataFrame</span><span class="p">):</span>
        <span class="c1"># Same for DataFrame and SparseDataFrame</span>
        <span class="n">arith_flex</span> <span class="o">=</span> <span class="n">_arith_method_FRAME</span>
        <span class="n">comp_flex</span> <span class="o">=</span> <span class="n">_flex_comp_method_FRAME</span>
        <span class="n">arith_special</span> <span class="o">=</span> <span class="n">_arith_method_FRAME</span>
        <span class="n">comp_special</span> <span class="o">=</span> <span class="n">_comp_method_FRAME</span>
        <span class="n">bool_special</span> <span class="o">=</span> <span class="n">_arith_method_FRAME</span>
    <span class="k">return</span> <span class="n">arith_flex</span><span class="p">,</span> <span class="n">comp_flex</span><span class="p">,</span> <span class="n">arith_special</span><span class="p">,</span> <span class="n">comp_special</span><span class="p">,</span> <span class="n">bool_special</span>


<span class="k">def</span> <span class="nf">_create_methods</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">arith_method</span><span class="p">,</span> <span class="n">comp_method</span><span class="p">,</span> <span class="n">bool_method</span><span class="p">,</span> <span class="n">special</span><span class="p">):</span>
    <span class="c1"># creates actual methods based upon arithmetic, comp and bool method</span>
    <span class="c1"># constructors.</span>

    <span class="n">have_divmod</span> <span class="o">=</span> <span class="nb">issubclass</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">ABCSeries</span><span class="p">)</span>
    <span class="c1"># divmod is available for Series and SparseSeries</span>

    <span class="c1"># yapf: disable</span>
    <span class="n">new_methods</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span>
        <span class="n">add</span><span class="o">=</span><span class="n">arith_method</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">operator</span><span class="o">.</span><span class="n">add</span><span class="p">,</span> <span class="n">special</span><span class="p">),</span>
        <span class="n">radd</span><span class="o">=</span><span class="n">arith_method</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">radd</span><span class="p">,</span> <span class="n">special</span><span class="p">),</span>
        <span class="n">sub</span><span class="o">=</span><span class="n">arith_method</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">operator</span><span class="o">.</span><span class="n">sub</span><span class="p">,</span> <span class="n">special</span><span class="p">),</span>
        <span class="n">mul</span><span class="o">=</span><span class="n">arith_method</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">operator</span><span class="o">.</span><span class="n">mul</span><span class="p">,</span> <span class="n">special</span><span class="p">),</span>
        <span class="n">truediv</span><span class="o">=</span><span class="n">arith_method</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">operator</span><span class="o">.</span><span class="n">truediv</span><span class="p">,</span> <span class="n">special</span><span class="p">),</span>
        <span class="n">floordiv</span><span class="o">=</span><span class="n">arith_method</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">operator</span><span class="o">.</span><span class="n">floordiv</span><span class="p">,</span> <span class="n">special</span><span class="p">),</span>
        <span class="c1"># Causes a floating point exception in the tests when numexpr enabled,</span>
        <span class="c1"># so for now no speedup</span>
        <span class="n">mod</span><span class="o">=</span><span class="n">arith_method</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">operator</span><span class="o">.</span><span class="n">mod</span><span class="p">,</span> <span class="n">special</span><span class="p">),</span>
        <span class="nb">pow</span><span class="o">=</span><span class="n">arith_method</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">operator</span><span class="o">.</span><span class="n">pow</span><span class="p">,</span> <span class="n">special</span><span class="p">),</span>
        <span class="c1"># not entirely sure why this is necessary, but previously was included</span>
        <span class="c1"># so it&#39;s here to maintain compatibility</span>
        <span class="n">rmul</span><span class="o">=</span><span class="n">arith_method</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">rmul</span><span class="p">,</span> <span class="n">special</span><span class="p">),</span>
        <span class="n">rsub</span><span class="o">=</span><span class="n">arith_method</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">rsub</span><span class="p">,</span> <span class="n">special</span><span class="p">),</span>
        <span class="n">rtruediv</span><span class="o">=</span><span class="n">arith_method</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">rtruediv</span><span class="p">,</span> <span class="n">special</span><span class="p">),</span>
        <span class="n">rfloordiv</span><span class="o">=</span><span class="n">arith_method</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">rfloordiv</span><span class="p">,</span> <span class="n">special</span><span class="p">),</span>
        <span class="n">rpow</span><span class="o">=</span><span class="n">arith_method</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">rpow</span><span class="p">,</span> <span class="n">special</span><span class="p">),</span>
        <span class="n">rmod</span><span class="o">=</span><span class="n">arith_method</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">rmod</span><span class="p">,</span> <span class="n">special</span><span class="p">))</span>
    <span class="c1"># yapf: enable</span>
    <span class="n">new_methods</span><span class="p">[</span><span class="s2">&quot;div&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_methods</span><span class="p">[</span><span class="s2">&quot;truediv&quot;</span><span class="p">]</span>
    <span class="n">new_methods</span><span class="p">[</span><span class="s2">&quot;rdiv&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_methods</span><span class="p">[</span><span class="s2">&quot;rtruediv&quot;</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">have_divmod</span><span class="p">:</span>
        <span class="c1"># divmod doesn&#39;t have an op that is supported by numexpr</span>
        <span class="n">new_methods</span><span class="p">[</span><span class="s2">&quot;divmod&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">arith_method</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="nb">divmod</span><span class="p">,</span> <span class="n">special</span><span class="p">)</span>
        <span class="n">new_methods</span><span class="p">[</span><span class="s2">&quot;rdivmod&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">arith_method</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">rdivmod</span><span class="p">,</span> <span class="n">special</span><span class="p">)</span>

    <span class="n">new_methods</span><span class="o">.</span><span class="n">update</span><span class="p">(</span>
        <span class="nb">dict</span><span class="p">(</span>
            <span class="n">eq</span><span class="o">=</span><span class="n">comp_method</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">operator</span><span class="o">.</span><span class="n">eq</span><span class="p">,</span> <span class="n">special</span><span class="p">),</span>
            <span class="n">ne</span><span class="o">=</span><span class="n">comp_method</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">operator</span><span class="o">.</span><span class="n">ne</span><span class="p">,</span> <span class="n">special</span><span class="p">),</span>
            <span class="n">lt</span><span class="o">=</span><span class="n">comp_method</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">operator</span><span class="o">.</span><span class="n">lt</span><span class="p">,</span> <span class="n">special</span><span class="p">),</span>
            <span class="n">gt</span><span class="o">=</span><span class="n">comp_method</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">operator</span><span class="o">.</span><span class="n">gt</span><span class="p">,</span> <span class="n">special</span><span class="p">),</span>
            <span class="n">le</span><span class="o">=</span><span class="n">comp_method</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">operator</span><span class="o">.</span><span class="n">le</span><span class="p">,</span> <span class="n">special</span><span class="p">),</span>
            <span class="n">ge</span><span class="o">=</span><span class="n">comp_method</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">operator</span><span class="o">.</span><span class="n">ge</span><span class="p">,</span> <span class="n">special</span><span class="p">),</span>
        <span class="p">)</span>
    <span class="p">)</span>

    <span class="k">if</span> <span class="n">bool_method</span><span class="p">:</span>
        <span class="n">new_methods</span><span class="o">.</span><span class="n">update</span><span class="p">(</span>
            <span class="nb">dict</span><span class="p">(</span>
                <span class="n">and_</span><span class="o">=</span><span class="n">bool_method</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">operator</span><span class="o">.</span><span class="n">and_</span><span class="p">,</span> <span class="n">special</span><span class="p">),</span>
                <span class="n">or_</span><span class="o">=</span><span class="n">bool_method</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">operator</span><span class="o">.</span><span class="n">or_</span><span class="p">,</span> <span class="n">special</span><span class="p">),</span>
                <span class="c1"># For some reason ``^`` wasn&#39;t used in original.</span>
                <span class="n">xor</span><span class="o">=</span><span class="n">bool_method</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">operator</span><span class="o">.</span><span class="n">xor</span><span class="p">,</span> <span class="n">special</span><span class="p">),</span>
                <span class="n">rand_</span><span class="o">=</span><span class="n">bool_method</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">rand_</span><span class="p">,</span> <span class="n">special</span><span class="p">),</span>
                <span class="n">ror_</span><span class="o">=</span><span class="n">bool_method</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">ror_</span><span class="p">,</span> <span class="n">special</span><span class="p">),</span>
                <span class="n">rxor</span><span class="o">=</span><span class="n">bool_method</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">rxor</span><span class="p">,</span> <span class="n">special</span><span class="p">),</span>
            <span class="p">)</span>
        <span class="p">)</span>

    <span class="k">if</span> <span class="n">special</span><span class="p">:</span>
        <span class="n">dunderize</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="s2">&quot;__</span><span class="si">{name}</span><span class="s2">__&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="n">x</span><span class="o">.</span><span class="n">strip</span><span class="p">(</span><span class="s2">&quot;_&quot;</span><span class="p">))</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">dunderize</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span>
    <span class="n">new_methods</span> <span class="o">=</span> <span class="p">{</span><span class="n">dunderize</span><span class="p">(</span><span class="n">k</span><span class="p">):</span> <span class="n">v</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">new_methods</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>
    <span class="k">return</span> <span class="n">new_methods</span>


<span class="k">def</span> <span class="nf">add_methods</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">new_methods</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">method</span> <span class="ow">in</span> <span class="n">new_methods</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="c1"># For most methods, if we find that the class already has a method</span>
        <span class="c1"># of the same name, it is OK to over-write it.  The exception is</span>
        <span class="c1"># inplace methods (__iadd__, __isub__, ...) for SparseArray, which</span>
        <span class="c1"># retain the np.ndarray versions.</span>
        <span class="n">force</span> <span class="o">=</span> <span class="ow">not</span> <span class="p">(</span><span class="nb">issubclass</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">ABCSparseArray</span><span class="p">)</span> <span class="ow">and</span> <span class="n">name</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;__i&quot;</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">force</span> <span class="ow">or</span> <span class="n">name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">cls</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">:</span>
            <span class="nb">setattr</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">method</span><span class="p">)</span>


<span class="c1"># ----------------------------------------------------------------------</span>
<span class="c1"># Arithmetic</span>
<span class="k">def</span> <span class="nf">add_special_arithmetic_methods</span><span class="p">(</span><span class="bp">cls</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Adds the full suite of special arithmetic methods (``__add__``,</span>
<span class="sd">    ``__sub__``, etc.) to the class.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    cls : class</span>
<span class="sd">        special methods will be defined and pinned to this class</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">arith_method</span><span class="p">,</span> <span class="n">comp_method</span><span class="p">,</span> <span class="n">bool_method</span> <span class="o">=</span> <span class="n">_get_method_wrappers</span><span class="p">(</span><span class="bp">cls</span><span class="p">)</span>
    <span class="n">new_methods</span> <span class="o">=</span> <span class="n">_create_methods</span><span class="p">(</span>
        <span class="bp">cls</span><span class="p">,</span> <span class="n">arith_method</span><span class="p">,</span> <span class="n">comp_method</span><span class="p">,</span> <span class="n">bool_method</span><span class="p">,</span> <span class="n">special</span><span class="o">=</span><span class="kc">True</span>
    <span class="p">)</span>
    <span class="c1"># inplace operators (I feel like these should get passed an `inplace=True`</span>
    <span class="c1"># or just be removed</span>

    <span class="k">def</span> <span class="nf">_wrap_inplace_method</span><span class="p">(</span><span class="n">method</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        return an inplace wrapper for this method</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>

            <span class="c1"># this makes sure that we are aligned like the input</span>
            <span class="c1"># we are updating inplace so we want to ignore is_copy</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_update_inplace</span><span class="p">(</span>
                <span class="n">result</span><span class="o">.</span><span class="n">reindex_like</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span><span class="o">.</span><span class="n">_data</span><span class="p">,</span> <span class="n">verify_is_copy</span><span class="o">=</span><span class="kc">False</span>
            <span class="p">)</span>

            <span class="k">return</span> <span class="bp">self</span>

        <span class="n">f</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">=</span> <span class="s2">&quot;__i</span><span class="si">{name}</span><span class="s2">__&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="n">method</span><span class="o">.</span><span class="vm">__name__</span><span class="o">.</span><span class="n">strip</span><span class="p">(</span><span class="s2">&quot;__&quot;</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">f</span>

    <span class="n">new_methods</span><span class="o">.</span><span class="n">update</span><span class="p">(</span>
        <span class="nb">dict</span><span class="p">(</span>
            <span class="fm">__iadd__</span><span class="o">=</span><span class="n">_wrap_inplace_method</span><span class="p">(</span><span class="n">new_methods</span><span class="p">[</span><span class="s2">&quot;__add__&quot;</span><span class="p">]),</span>
            <span class="fm">__isub__</span><span class="o">=</span><span class="n">_wrap_inplace_method</span><span class="p">(</span><span class="n">new_methods</span><span class="p">[</span><span class="s2">&quot;__sub__&quot;</span><span class="p">]),</span>
            <span class="fm">__imul__</span><span class="o">=</span><span class="n">_wrap_inplace_method</span><span class="p">(</span><span class="n">new_methods</span><span class="p">[</span><span class="s2">&quot;__mul__&quot;</span><span class="p">]),</span>
            <span class="fm">__itruediv__</span><span class="o">=</span><span class="n">_wrap_inplace_method</span><span class="p">(</span><span class="n">new_methods</span><span class="p">[</span><span class="s2">&quot;__truediv__&quot;</span><span class="p">]),</span>
            <span class="fm">__ifloordiv__</span><span class="o">=</span><span class="n">_wrap_inplace_method</span><span class="p">(</span><span class="n">new_methods</span><span class="p">[</span><span class="s2">&quot;__floordiv__&quot;</span><span class="p">]),</span>
            <span class="fm">__imod__</span><span class="o">=</span><span class="n">_wrap_inplace_method</span><span class="p">(</span><span class="n">new_methods</span><span class="p">[</span><span class="s2">&quot;__mod__&quot;</span><span class="p">]),</span>
            <span class="fm">__ipow__</span><span class="o">=</span><span class="n">_wrap_inplace_method</span><span class="p">(</span><span class="n">new_methods</span><span class="p">[</span><span class="s2">&quot;__pow__&quot;</span><span class="p">]),</span>
        <span class="p">)</span>
    <span class="p">)</span>

    <span class="n">new_methods</span><span class="o">.</span><span class="n">update</span><span class="p">(</span>
        <span class="nb">dict</span><span class="p">(</span>
            <span class="fm">__iand__</span><span class="o">=</span><span class="n">_wrap_inplace_method</span><span class="p">(</span><span class="n">new_methods</span><span class="p">[</span><span class="s2">&quot;__and__&quot;</span><span class="p">]),</span>
            <span class="fm">__ior__</span><span class="o">=</span><span class="n">_wrap_inplace_method</span><span class="p">(</span><span class="n">new_methods</span><span class="p">[</span><span class="s2">&quot;__or__&quot;</span><span class="p">]),</span>
            <span class="fm">__ixor__</span><span class="o">=</span><span class="n">_wrap_inplace_method</span><span class="p">(</span><span class="n">new_methods</span><span class="p">[</span><span class="s2">&quot;__xor__&quot;</span><span class="p">]),</span>
        <span class="p">)</span>
    <span class="p">)</span>

    <span class="n">add_methods</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">new_methods</span><span class="o">=</span><span class="n">new_methods</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">add_flex_arithmetic_methods</span><span class="p">(</span><span class="bp">cls</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Adds the full suite of flex arithmetic methods (``pow``, ``mul``, ``add``)</span>
<span class="sd">    to the class.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    cls : class</span>
<span class="sd">        flex methods will be defined and pinned to this class</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">flex_arith_method</span><span class="p">,</span> <span class="n">flex_comp_method</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">_get_method_wrappers</span><span class="p">(</span><span class="bp">cls</span><span class="p">)</span>
    <span class="n">new_methods</span> <span class="o">=</span> <span class="n">_create_methods</span><span class="p">(</span>
        <span class="bp">cls</span><span class="p">,</span> <span class="n">flex_arith_method</span><span class="p">,</span> <span class="n">flex_comp_method</span><span class="p">,</span> <span class="n">bool_method</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">special</span><span class="o">=</span><span class="kc">False</span>
    <span class="p">)</span>
    <span class="n">new_methods</span><span class="o">.</span><span class="n">update</span><span class="p">(</span>
        <span class="nb">dict</span><span class="p">(</span>
            <span class="n">multiply</span><span class="o">=</span><span class="n">new_methods</span><span class="p">[</span><span class="s2">&quot;mul&quot;</span><span class="p">],</span>
            <span class="n">subtract</span><span class="o">=</span><span class="n">new_methods</span><span class="p">[</span><span class="s2">&quot;sub&quot;</span><span class="p">],</span>
            <span class="n">divide</span><span class="o">=</span><span class="n">new_methods</span><span class="p">[</span><span class="s2">&quot;div&quot;</span><span class="p">],</span>
        <span class="p">)</span>
    <span class="p">)</span>
    <span class="c1"># opt out of bool flex methods for now</span>
    <span class="k">assert</span> <span class="ow">not</span> <span class="nb">any</span><span class="p">(</span><span class="n">kname</span> <span class="ow">in</span> <span class="n">new_methods</span> <span class="k">for</span> <span class="n">kname</span> <span class="ow">in</span> <span class="p">(</span><span class="s2">&quot;ror_&quot;</span><span class="p">,</span> <span class="s2">&quot;rxor&quot;</span><span class="p">,</span> <span class="s2">&quot;rand_&quot;</span><span class="p">))</span>

    <span class="n">add_methods</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">new_methods</span><span class="o">=</span><span class="n">new_methods</span><span class="p">)</span>


<span class="c1"># -----------------------------------------------------------------------------</span>
<span class="c1"># Series</span>


<span class="k">def</span> <span class="nf">_align_method_SERIES</span><span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">,</span> <span class="n">align_asobject</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; align lhs and rhs Series &quot;&quot;&quot;</span>

    <span class="c1"># ToDo: Different from _align_method_FRAME, list, tuple and ndarray</span>
    <span class="c1"># are not coerced here</span>
    <span class="c1"># because Series has inconsistencies described in #13637</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">right</span><span class="p">,</span> <span class="n">ABCSeries</span><span class="p">):</span>
        <span class="c1"># avoid repeated alignment</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">left</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">equals</span><span class="p">(</span><span class="n">right</span><span class="o">.</span><span class="n">index</span><span class="p">):</span>

            <span class="k">if</span> <span class="n">align_asobject</span><span class="p">:</span>
                <span class="c1"># to keep original value&#39;s dtype for bool ops</span>
                <span class="n">left</span> <span class="o">=</span> <span class="n">left</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">object</span><span class="p">)</span>
                <span class="n">right</span> <span class="o">=</span> <span class="n">right</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">object</span><span class="p">)</span>

            <span class="n">left</span><span class="p">,</span> <span class="n">right</span> <span class="o">=</span> <span class="n">left</span><span class="o">.</span><span class="n">align</span><span class="p">(</span><span class="n">right</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">left</span><span class="p">,</span> <span class="n">right</span>


<span class="k">def</span> <span class="nf">_construct_result</span><span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="n">result</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    If the raw op result has a non-None name (e.g. it is an Index object) and</span>
<span class="sd">    the name argument is None, then passing name to the constructor will</span>
<span class="sd">    not be enough; we still need to override the name attribute.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">out</span> <span class="o">=</span> <span class="n">left</span><span class="o">.</span><span class="n">_constructor</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="n">index</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>
    <span class="n">out</span> <span class="o">=</span> <span class="n">out</span><span class="o">.</span><span class="n">__finalize__</span><span class="p">(</span><span class="n">left</span><span class="p">)</span>
    <span class="n">out</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>
    <span class="k">return</span> <span class="n">out</span>


<span class="k">def</span> <span class="nf">_construct_divmod_result</span><span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="n">result</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;divmod returns a tuple of like indexed series instead of a single series.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="p">(</span>
        <span class="n">_construct_result</span><span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="n">result</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">index</span><span class="o">=</span><span class="n">index</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">),</span>
        <span class="n">_construct_result</span><span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="n">result</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">index</span><span class="o">=</span><span class="n">index</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">),</span>
    <span class="p">)</span>


<span class="k">def</span> <span class="nf">_arith_method_SERIES</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">op</span><span class="p">,</span> <span class="n">special</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Wrapper function for Series arithmetic operations, to avoid</span>
<span class="sd">    code duplication.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">str_rep</span> <span class="o">=</span> <span class="n">_get_opstr</span><span class="p">(</span><span class="n">op</span><span class="p">,</span> <span class="bp">cls</span><span class="p">)</span>
    <span class="n">op_name</span> <span class="o">=</span> <span class="n">_get_op_name</span><span class="p">(</span><span class="n">op</span><span class="p">,</span> <span class="n">special</span><span class="p">)</span>
    <span class="n">eval_kwargs</span> <span class="o">=</span> <span class="n">_gen_eval_kwargs</span><span class="p">(</span><span class="n">op_name</span><span class="p">)</span>
    <span class="n">construct_result</span> <span class="o">=</span> <span class="p">(</span>
        <span class="n">_construct_divmod_result</span> <span class="k">if</span> <span class="n">op</span> <span class="ow">in</span> <span class="p">[</span><span class="nb">divmod</span><span class="p">,</span> <span class="n">rdivmod</span><span class="p">]</span> <span class="k">else</span> <span class="n">_construct_result</span>
    <span class="p">)</span>

    <span class="k">def</span> <span class="nf">na_op</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the result of evaluating op on the passed in values.</span>

<span class="sd">        If native types are not compatible, try coersion to object dtype.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        x : array-like</span>
<span class="sd">        y : array-like or scalar</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        array-like</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        TypeError : invalid operation</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">import</span> <span class="nn">pandas.core.computation.expressions</span> <span class="k">as</span> <span class="nn">expressions</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">expressions</span><span class="o">.</span><span class="n">evaluate</span><span class="p">(</span><span class="n">op</span><span class="p">,</span> <span class="n">str_rep</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="o">**</span><span class="n">eval_kwargs</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">masked_arith_op</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">op</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">missing</span><span class="o">.</span><span class="n">dispatch_fill_zeros</span><span class="p">(</span><span class="n">op</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">result</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">wrapper</span><span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">right</span><span class="p">,</span> <span class="n">ABCDataFrame</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">NotImplemented</span>

        <span class="n">left</span><span class="p">,</span> <span class="n">right</span> <span class="o">=</span> <span class="n">_align_method_SERIES</span><span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">)</span>
        <span class="n">res_name</span> <span class="o">=</span> <span class="n">get_op_result_name</span><span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">)</span>
        <span class="n">right</span> <span class="o">=</span> <span class="n">maybe_upcast_for_op</span><span class="p">(</span><span class="n">right</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">is_categorical_dtype</span><span class="p">(</span><span class="n">left</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                <span class="s2">&quot;</span><span class="si">{typ}</span><span class="s2"> cannot perform the operation &quot;</span>
                <span class="s2">&quot;</span><span class="si">{op}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">typ</span><span class="o">=</span><span class="nb">type</span><span class="p">(</span><span class="n">left</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="n">op</span><span class="o">=</span><span class="n">str_rep</span><span class="p">)</span>
            <span class="p">)</span>

        <span class="k">elif</span> <span class="n">is_datetime64_dtype</span><span class="p">(</span><span class="n">left</span><span class="p">)</span> <span class="ow">or</span> <span class="n">is_datetime64tz_dtype</span><span class="p">(</span><span class="n">left</span><span class="p">):</span>
            <span class="c1"># Give dispatch_to_index_op a chance for tests like</span>
            <span class="c1"># test_dt64_series_add_intlike, which the index dispatching handles</span>
            <span class="c1"># specifically.</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">dispatch_to_index_op</span><span class="p">(</span><span class="n">op</span><span class="p">,</span> <span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">DatetimeIndex</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">construct_result</span><span class="p">(</span>
                <span class="n">left</span><span class="p">,</span> <span class="n">result</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="n">left</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">res_name</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">result</span><span class="o">.</span><span class="n">dtype</span>
            <span class="p">)</span>

        <span class="k">elif</span> <span class="n">is_extension_array_dtype</span><span class="p">(</span><span class="n">left</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span>
            <span class="n">is_extension_array_dtype</span><span class="p">(</span><span class="n">right</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">is_scalar</span><span class="p">(</span><span class="n">right</span><span class="p">)</span>
        <span class="p">):</span>
            <span class="c1"># GH#22378 disallow scalar to exclude e.g. &quot;category&quot;, &quot;Int64&quot;</span>
            <span class="k">return</span> <span class="n">dispatch_to_extension_op</span><span class="p">(</span><span class="n">op</span><span class="p">,</span> <span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">)</span>

        <span class="k">elif</span> <span class="n">is_timedelta64_dtype</span><span class="p">(</span><span class="n">left</span><span class="p">):</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">dispatch_to_index_op</span><span class="p">(</span><span class="n">op</span><span class="p">,</span> <span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">TimedeltaIndex</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">construct_result</span><span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="n">result</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="n">left</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">res_name</span><span class="p">)</span>

        <span class="k">elif</span> <span class="n">is_timedelta64_dtype</span><span class="p">(</span><span class="n">right</span><span class="p">):</span>
            <span class="c1"># We should only get here with non-scalar or timedelta64(&#39;NaT&#39;)</span>
            <span class="c1">#  values for right</span>
            <span class="c1"># Note: we cannot use dispatch_to_index_op because</span>
            <span class="c1">#  that may incorrectly raise TypeError when we</span>
            <span class="c1">#  should get NullFrequencyError</span>
            <span class="n">orig_right</span> <span class="o">=</span> <span class="n">right</span>
            <span class="k">if</span> <span class="n">is_scalar</span><span class="p">(</span><span class="n">right</span><span class="p">):</span>
                <span class="c1"># broadcast and wrap in a TimedeltaIndex</span>
                <span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">isnat</span><span class="p">(</span><span class="n">right</span><span class="p">)</span>
                <span class="n">right</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">broadcast_to</span><span class="p">(</span><span class="n">right</span><span class="p">,</span> <span class="n">left</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
                <span class="n">right</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">TimedeltaIndex</span><span class="p">(</span><span class="n">right</span><span class="p">)</span>

            <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">right</span><span class="p">,</span> <span class="p">(</span><span class="n">pd</span><span class="o">.</span><span class="n">TimedeltaIndex</span><span class="p">,</span> <span class="n">ABCTimedeltaArray</span><span class="p">,</span> <span class="n">ABCSeries</span><span class="p">))</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">result</span> <span class="o">=</span> <span class="n">op</span><span class="p">(</span><span class="n">left</span><span class="o">.</span><span class="n">_values</span><span class="p">,</span> <span class="n">right</span><span class="p">)</span>
            <span class="k">except</span> <span class="n">NullFrequencyError</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">orig_right</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">right</span><span class="p">:</span>
                    <span class="c1"># i.e. scalar timedelta64(&#39;NaT&#39;)</span>
                    <span class="c1">#  We get a NullFrequencyError because we broadcast to</span>
                    <span class="c1">#  TimedeltaIndex, but this should be TypeError.</span>
                    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                        <span class="s2">&quot;incompatible type for a datetime/timedelta &quot;</span>
                        <span class="s2">&quot;operation [</span><span class="si">{name}</span><span class="s2">]&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="n">op</span><span class="o">.</span><span class="vm">__name__</span><span class="p">)</span>
                    <span class="p">)</span>
                <span class="k">raise</span>

            <span class="c1"># We do not pass dtype to ensure that the Series constructor</span>
            <span class="c1">#  does inference in the case where `result` has object-dtype.</span>
            <span class="k">return</span> <span class="n">construct_result</span><span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="n">result</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="n">left</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">res_name</span><span class="p">)</span>

        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">right</span><span class="p">,</span> <span class="p">(</span><span class="n">ABCDatetimeArray</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">DatetimeIndex</span><span class="p">)):</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">op</span><span class="p">(</span><span class="n">left</span><span class="o">.</span><span class="n">_values</span><span class="p">,</span> <span class="n">right</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">construct_result</span><span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="n">result</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="n">left</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">res_name</span><span class="p">)</span>

        <span class="n">lvalues</span> <span class="o">=</span> <span class="n">left</span><span class="o">.</span><span class="n">values</span>
        <span class="n">rvalues</span> <span class="o">=</span> <span class="n">right</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">rvalues</span><span class="p">,</span> <span class="p">(</span><span class="n">ABCSeries</span><span class="p">,</span> <span class="n">ABCIndexClass</span><span class="p">)):</span>
            <span class="n">rvalues</span> <span class="o">=</span> <span class="n">rvalues</span><span class="o">.</span><span class="n">_values</span>

        <span class="k">with</span> <span class="n">np</span><span class="o">.</span><span class="n">errstate</span><span class="p">(</span><span class="nb">all</span><span class="o">=</span><span class="s2">&quot;ignore&quot;</span><span class="p">):</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">na_op</span><span class="p">(</span><span class="n">lvalues</span><span class="p">,</span> <span class="n">rvalues</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">construct_result</span><span class="p">(</span>
            <span class="n">left</span><span class="p">,</span> <span class="n">result</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="n">left</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">res_name</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="kc">None</span>
        <span class="p">)</span>

    <span class="n">wrapper</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">=</span> <span class="n">op_name</span>
    <span class="k">return</span> <span class="n">wrapper</span>


<span class="k">def</span> <span class="nf">_comp_method_OBJECT_ARRAY</span><span class="p">(</span><span class="n">op</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
        <span class="n">y</span> <span class="o">=</span> <span class="n">construct_1d_object_array_from_listlike</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">ABCSeries</span><span class="p">,</span> <span class="n">ABCIndex</span><span class="p">)):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">is_object_dtype</span><span class="p">(</span><span class="n">y</span><span class="o">.</span><span class="n">dtype</span><span class="p">):</span>
            <span class="n">y</span> <span class="o">=</span> <span class="n">y</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">object_</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="p">(</span><span class="n">ABCSeries</span><span class="p">,</span> <span class="n">ABCIndex</span><span class="p">)):</span>
            <span class="n">y</span> <span class="o">=</span> <span class="n">y</span><span class="o">.</span><span class="n">values</span>

        <span class="n">result</span> <span class="o">=</span> <span class="n">libops</span><span class="o">.</span><span class="n">vec_compare</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">op</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">libops</span><span class="o">.</span><span class="n">scalar_compare</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">op</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">result</span>


<span class="k">def</span> <span class="nf">_comp_method_SERIES</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">op</span><span class="p">,</span> <span class="n">special</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Wrapper function for Series arithmetic operations, to avoid</span>
<span class="sd">    code duplication.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">op_name</span> <span class="o">=</span> <span class="n">_get_op_name</span><span class="p">(</span><span class="n">op</span><span class="p">,</span> <span class="n">special</span><span class="p">)</span>
    <span class="n">masker</span> <span class="o">=</span> <span class="n">_gen_eval_kwargs</span><span class="p">(</span><span class="n">op_name</span><span class="p">)</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;masker&quot;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">na_op</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
        <span class="c1"># TODO:</span>
        <span class="c1"># should have guarantess on what x, y can be type-wise</span>
        <span class="c1"># Extension Dtypes are not called here</span>

        <span class="c1"># Checking that cases that were once handled here are no longer</span>
        <span class="c1"># reachable.</span>
        <span class="k">assert</span> <span class="ow">not</span> <span class="p">(</span><span class="n">is_categorical_dtype</span><span class="p">(</span><span class="n">y</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">is_scalar</span><span class="p">(</span><span class="n">y</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">is_object_dtype</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">dtype</span><span class="p">):</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">_comp_method_OBJECT_ARRAY</span><span class="p">(</span><span class="n">op</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>

        <span class="k">elif</span> <span class="n">is_datetimelike_v_numeric</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">invalid_comparison</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">op</span><span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>

            <span class="c1"># we want to compare like types</span>
            <span class="c1"># we only want to convert to integer like if</span>
            <span class="c1"># we are not NotImplemented, otherwise</span>
            <span class="c1"># we would allow datetime64 (but viewed as i8) against</span>
            <span class="c1"># integer comparisons</span>

            <span class="c1"># we have a datetime/timedelta and may need to convert</span>
            <span class="k">assert</span> <span class="ow">not</span> <span class="n">needs_i8_conversion</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
            <span class="n">mask</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">is_scalar</span><span class="p">(</span><span class="n">y</span><span class="p">)</span> <span class="ow">and</span> <span class="n">needs_i8_conversion</span><span class="p">(</span><span class="n">y</span><span class="p">):</span>
                <span class="n">mask</span> <span class="o">=</span> <span class="n">isna</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">|</span> <span class="n">isna</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
                <span class="n">y</span> <span class="o">=</span> <span class="n">y</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="s2">&quot;i8&quot;</span><span class="p">)</span>
                <span class="n">x</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="s2">&quot;i8&quot;</span><span class="p">)</span>

            <span class="n">method</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">op_name</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">method</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">with</span> <span class="n">np</span><span class="o">.</span><span class="n">errstate</span><span class="p">(</span><span class="nb">all</span><span class="o">=</span><span class="s2">&quot;ignore&quot;</span><span class="p">):</span>
                    <span class="n">result</span> <span class="o">=</span> <span class="n">method</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">result</span> <span class="ow">is</span> <span class="bp">NotImplemented</span><span class="p">:</span>
                    <span class="k">return</span> <span class="n">invalid_comparison</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">op</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">result</span> <span class="o">=</span> <span class="n">op</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">mask</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">mask</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
                <span class="n">result</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span> <span class="o">=</span> <span class="n">masker</span>

        <span class="k">return</span> <span class="n">result</span>

    <span class="k">def</span> <span class="nf">wrapper</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="c1"># Validate the axis parameter</span>
        <span class="k">if</span> <span class="n">axis</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_get_axis_number</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span>

        <span class="n">res_name</span> <span class="o">=</span> <span class="n">get_op_result_name</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="c1"># TODO: same for tuples?</span>
            <span class="n">other</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">ABCDataFrame</span><span class="p">):</span>  <span class="c1"># pragma: no cover</span>
            <span class="c1"># Defer to DataFrame implementation; fail early</span>
            <span class="k">return</span> <span class="bp">NotImplemented</span>

        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">ABCSeries</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_indexed_same</span><span class="p">(</span><span class="n">other</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Can only compare identically-labeled &quot;</span> <span class="s2">&quot;Series objects&quot;</span><span class="p">)</span>

        <span class="k">elif</span> <span class="n">is_categorical_dtype</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="c1"># Dispatch to Categorical implementation; pd.CategoricalIndex</span>
            <span class="c1"># behavior is non-canonical GH#19513</span>
            <span class="n">res_values</span> <span class="o">=</span> <span class="n">dispatch_to_index_op</span><span class="p">(</span><span class="n">op</span><span class="p">,</span> <span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">Categorical</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_constructor</span><span class="p">(</span><span class="n">res_values</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">res_name</span><span class="p">)</span>

        <span class="k">elif</span> <span class="n">is_datetime64_dtype</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="ow">or</span> <span class="n">is_datetime64tz_dtype</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="c1"># Dispatch to DatetimeIndex to ensure identical</span>
            <span class="c1"># Series/Index behavior</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">datetime</span><span class="o">.</span><span class="n">date</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span>
                <span class="n">other</span><span class="p">,</span> <span class="n">datetime</span><span class="o">.</span><span class="n">datetime</span>
            <span class="p">):</span>
                <span class="c1"># https://github.com/pandas-dev/pandas/issues/21152</span>
                <span class="c1"># Compatibility for difference between Series comparison w/</span>
                <span class="c1"># datetime and date</span>
                <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="s2">&quot;Comparing Series of datetimes with &#39;datetime.date&#39;.  &quot;</span>
                    <span class="s2">&quot;Currently, the &#39;datetime.date&#39; is coerced to a &quot;</span>
                    <span class="s2">&quot;datetime. In the future pandas will not coerce, &quot;</span>
                    <span class="s2">&quot;and </span><span class="si">{future}</span><span class="s2">. &quot;</span>
                    <span class="s2">&quot;To retain the current behavior, &quot;</span>
                    <span class="s2">&quot;convert the &#39;datetime.date&#39; to a datetime with &quot;</span>
                    <span class="s2">&quot;&#39;pd.Timestamp&#39;.&quot;</span>
                <span class="p">)</span>

                <span class="k">if</span> <span class="n">op</span> <span class="ow">in</span> <span class="p">{</span><span class="n">operator</span><span class="o">.</span><span class="n">lt</span><span class="p">,</span> <span class="n">operator</span><span class="o">.</span><span class="n">le</span><span class="p">,</span> <span class="n">operator</span><span class="o">.</span><span class="n">gt</span><span class="p">,</span> <span class="n">operator</span><span class="o">.</span><span class="n">ge</span><span class="p">}:</span>
                    <span class="n">future</span> <span class="o">=</span> <span class="s2">&quot;a TypeError will be raised&quot;</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">future</span> <span class="o">=</span> <span class="p">(</span>
                        <span class="s2">&quot;&#39;the values will not compare equal to the &quot;</span> <span class="s2">&quot;&#39;datetime.date&#39;&quot;</span>
                    <span class="p">)</span>
                <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">textwrap</span><span class="o">.</span><span class="n">wrap</span><span class="p">(</span><span class="n">msg</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">future</span><span class="o">=</span><span class="n">future</span><span class="p">)))</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="n">msg</span><span class="p">,</span> <span class="ne">FutureWarning</span><span class="p">,</span> <span class="n">stacklevel</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
                <span class="n">other</span> <span class="o">=</span> <span class="n">Timestamp</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>

            <span class="n">res_values</span> <span class="o">=</span> <span class="n">dispatch_to_index_op</span><span class="p">(</span><span class="n">op</span><span class="p">,</span> <span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">DatetimeIndex</span><span class="p">)</span>

            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_constructor</span><span class="p">(</span><span class="n">res_values</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">res_name</span><span class="p">)</span>

        <span class="k">elif</span> <span class="n">is_timedelta64_dtype</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="n">res_values</span> <span class="o">=</span> <span class="n">dispatch_to_index_op</span><span class="p">(</span><span class="n">op</span><span class="p">,</span> <span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">TimedeltaIndex</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_constructor</span><span class="p">(</span><span class="n">res_values</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">res_name</span><span class="p">)</span>

        <span class="k">elif</span> <span class="n">is_extension_array_dtype</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span>
            <span class="n">is_extension_array_dtype</span><span class="p">(</span><span class="n">other</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">is_scalar</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
        <span class="p">):</span>
            <span class="c1"># Note: the `not is_scalar(other)` condition rules out</span>
            <span class="c1"># e.g. other == &quot;category&quot;</span>
            <span class="k">return</span> <span class="n">dispatch_to_extension_op</span><span class="p">(</span><span class="n">op</span><span class="p">,</span> <span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>

        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">ABCSeries</span><span class="p">):</span>
            <span class="c1"># By this point we have checked that self._indexed_same(other)</span>
            <span class="n">res_values</span> <span class="o">=</span> <span class="n">na_op</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="n">values</span><span class="p">)</span>
            <span class="c1"># rename is needed in case res_name is None and res_values.name</span>
            <span class="c1"># is not.</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_constructor</span><span class="p">(</span>
                <span class="n">res_values</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">res_name</span>
            <span class="p">)</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">res_name</span><span class="p">)</span>

        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">ABCIndexClass</span><span class="p">)):</span>
            <span class="c1"># do not check length of zerodim array</span>
            <span class="c1"># as it will broadcast</span>
            <span class="k">if</span> <span class="n">other</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="mi">0</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">other</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Lengths must match to compare&quot;</span><span class="p">)</span>

            <span class="n">res_values</span> <span class="o">=</span> <span class="n">na_op</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">other</span><span class="p">))</span>
            <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_constructor</span><span class="p">(</span><span class="n">res_values</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="p">)</span>
            <span class="c1"># rename is needed in case res_name is None and self.name</span>
            <span class="c1"># is not.</span>
            <span class="k">return</span> <span class="n">result</span><span class="o">.</span><span class="n">__finalize__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">res_name</span><span class="p">)</span>

        <span class="k">elif</span> <span class="n">is_scalar</span><span class="p">(</span><span class="n">other</span><span class="p">)</span> <span class="ow">and</span> <span class="n">isna</span><span class="p">(</span><span class="n">other</span><span class="p">):</span>
            <span class="c1"># numpy does not like comparisons vs None</span>
            <span class="k">if</span> <span class="n">op</span> <span class="ow">is</span> <span class="n">operator</span><span class="o">.</span><span class="n">ne</span><span class="p">:</span>
                <span class="n">res_values</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">res_values</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_constructor</span><span class="p">(</span>
                <span class="n">res_values</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">res_name</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;bool&quot;</span>
            <span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="n">values</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">()</span>

            <span class="k">with</span> <span class="n">np</span><span class="o">.</span><span class="n">errstate</span><span class="p">(</span><span class="nb">all</span><span class="o">=</span><span class="s2">&quot;ignore&quot;</span><span class="p">):</span>
                <span class="n">res</span> <span class="o">=</span> <span class="n">na_op</span><span class="p">(</span><span class="n">values</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">is_scalar</span><span class="p">(</span><span class="n">res</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                    <span class="s2">&quot;Could not compare </span><span class="si">{typ}</span><span class="s2"> type with Series&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">typ</span><span class="o">=</span><span class="nb">type</span><span class="p">(</span><span class="n">other</span><span class="p">))</span>
                <span class="p">)</span>

            <span class="c1"># always return a full value series here</span>
            <span class="n">res_values</span> <span class="o">=</span> <span class="n">com</span><span class="o">.</span><span class="n">values_from_object</span><span class="p">(</span><span class="n">res</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_constructor</span><span class="p">(</span>
                <span class="n">res_values</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">res_name</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;bool&quot;</span>
            <span class="p">)</span>

    <span class="n">wrapper</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">=</span> <span class="n">op_name</span>
    <span class="k">return</span> <span class="n">wrapper</span>


<span class="k">def</span> <span class="nf">_bool_method_SERIES</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">op</span><span class="p">,</span> <span class="n">special</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Wrapper function for Series arithmetic operations, to avoid</span>
<span class="sd">    code duplication.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">op_name</span> <span class="o">=</span> <span class="n">_get_op_name</span><span class="p">(</span><span class="n">op</span><span class="p">,</span> <span class="n">special</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">na_op</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">op</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
            <span class="k">assert</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="n">ABCSeries</span><span class="p">,</span> <span class="n">ABCIndexClass</span><span class="p">))</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
                <span class="c1"># bool-bool dtype operations should be OK, should not get here</span>
                <span class="k">assert</span> <span class="ow">not</span> <span class="p">(</span><span class="n">is_bool_dtype</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="ow">and</span> <span class="n">is_bool_dtype</span><span class="p">(</span><span class="n">y</span><span class="p">))</span>
                <span class="n">x</span> <span class="o">=</span> <span class="n">ensure_object</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
                <span class="n">y</span> <span class="o">=</span> <span class="n">ensure_object</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
                <span class="n">result</span> <span class="o">=</span> <span class="n">libops</span><span class="o">.</span><span class="n">vec_binop</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">op</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># let null fall thru</span>
                <span class="k">assert</span> <span class="n">lib</span><span class="o">.</span><span class="n">is_scalar</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">isna</span><span class="p">(</span><span class="n">y</span><span class="p">):</span>
                    <span class="n">y</span> <span class="o">=</span> <span class="nb">bool</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">result</span> <span class="o">=</span> <span class="n">libops</span><span class="o">.</span><span class="n">scalar_binop</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">op</span><span class="p">)</span>
                <span class="k">except</span> <span class="p">(</span>
                    <span class="ne">TypeError</span><span class="p">,</span>
                    <span class="ne">ValueError</span><span class="p">,</span>
                    <span class="ne">AttributeError</span><span class="p">,</span>
                    <span class="ne">OverflowError</span><span class="p">,</span>
                    <span class="ne">NotImplementedError</span><span class="p">,</span>
                <span class="p">):</span>
                    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                        <span class="s2">&quot;cannot compare a dtyped [</span><span class="si">{dtype}</span><span class="s2">] array &quot;</span>
                        <span class="s2">&quot;with a scalar of type [</span><span class="si">{typ}</span><span class="s2">]&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                            <span class="n">dtype</span><span class="o">=</span><span class="n">x</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">typ</span><span class="o">=</span><span class="nb">type</span><span class="p">(</span><span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span>
                        <span class="p">)</span>
                    <span class="p">)</span>

        <span class="k">return</span> <span class="n">result</span>

    <span class="n">fill_int</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">fillna</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">fill_bool</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">fillna</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">bool</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">wrapper</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="n">is_self_int_dtype</span> <span class="o">=</span> <span class="n">is_integer_dtype</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>

        <span class="bp">self</span><span class="p">,</span> <span class="n">other</span> <span class="o">=</span> <span class="n">_align_method_SERIES</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">align_asobject</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">res_name</span> <span class="o">=</span> <span class="n">get_op_result_name</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">ABCDataFrame</span><span class="p">):</span>
            <span class="c1"># Defer to DataFrame implementation; fail early</span>
            <span class="k">return</span> <span class="bp">NotImplemented</span>

        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="p">(</span><span class="n">ABCSeries</span><span class="p">,</span> <span class="n">ABCIndexClass</span><span class="p">)):</span>
            <span class="n">is_other_int_dtype</span> <span class="o">=</span> <span class="n">is_integer_dtype</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
            <span class="n">other</span> <span class="o">=</span> <span class="n">fill_int</span><span class="p">(</span><span class="n">other</span><span class="p">)</span> <span class="k">if</span> <span class="n">is_other_int_dtype</span> <span class="k">else</span> <span class="n">fill_bool</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>

            <span class="n">ovalues</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">values</span>
            <span class="n">finalizer</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># scalars, list, tuple, np.array</span>
            <span class="n">is_other_int_dtype</span> <span class="o">=</span> <span class="n">is_integer_dtype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">other</span><span class="p">))</span>
            <span class="k">if</span> <span class="n">is_list_like</span><span class="p">(</span><span class="n">other</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
                <span class="c1"># TODO: Can we do this before the is_integer_dtype check?</span>
                <span class="c1"># could the is_integer_dtype check be checking the wrong</span>
                <span class="c1"># thing?  e.g. other = [[0, 1], [2, 3], [4, 5]]?</span>
                <span class="n">other</span> <span class="o">=</span> <span class="n">construct_1d_object_array_from_listlike</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>

            <span class="n">ovalues</span> <span class="o">=</span> <span class="n">other</span>
            <span class="n">finalizer</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">__finalize__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

        <span class="c1"># For int vs int `^`, `|`, `&amp;` are bitwise operators and return</span>
        <span class="c1">#   integer dtypes.  Otherwise these are boolean ops</span>
        <span class="n">filler</span> <span class="o">=</span> <span class="n">fill_int</span> <span class="k">if</span> <span class="n">is_self_int_dtype</span> <span class="ow">and</span> <span class="n">is_other_int_dtype</span> <span class="k">else</span> <span class="n">fill_bool</span>
        <span class="n">res_values</span> <span class="o">=</span> <span class="n">na_op</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="p">,</span> <span class="n">ovalues</span><span class="p">)</span>
        <span class="n">unfilled</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_constructor</span><span class="p">(</span><span class="n">res_values</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">res_name</span><span class="p">)</span>
        <span class="n">filled</span> <span class="o">=</span> <span class="n">filler</span><span class="p">(</span><span class="n">unfilled</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">finalizer</span><span class="p">(</span><span class="n">filled</span><span class="p">)</span>

    <span class="n">wrapper</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">=</span> <span class="n">op_name</span>
    <span class="k">return</span> <span class="n">wrapper</span>


<span class="k">def</span> <span class="nf">_flex_method_SERIES</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">op</span><span class="p">,</span> <span class="n">special</span><span class="p">):</span>
    <span class="n">name</span> <span class="o">=</span> <span class="n">_get_op_name</span><span class="p">(</span><span class="n">op</span><span class="p">,</span> <span class="n">special</span><span class="p">)</span>
    <span class="n">doc</span> <span class="o">=</span> <span class="n">_make_flex_doc</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="s2">&quot;series&quot;</span><span class="p">)</span>

    <span class="nd">@Appender</span><span class="p">(</span><span class="n">doc</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">flex_wrapper</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">level</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="c1"># validate axis</span>
        <span class="k">if</span> <span class="n">axis</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_get_axis_number</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">ABCSeries</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_binop</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">op</span><span class="p">,</span> <span class="n">level</span><span class="o">=</span><span class="n">level</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=</span><span class="n">fill_value</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)):</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">other</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Lengths must be equal&quot;</span><span class="p">)</span>
            <span class="n">other</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_constructor</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_binop</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">op</span><span class="p">,</span> <span class="n">level</span><span class="o">=</span><span class="n">level</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=</span><span class="n">fill_value</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">fill_value</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="bp">self</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fillna</span><span class="p">(</span><span class="n">fill_value</span><span class="p">)</span>

            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_constructor</span><span class="p">(</span><span class="n">op</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="p">)</span><span class="o">.</span><span class="n">__finalize__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="n">flex_wrapper</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">=</span> <span class="n">name</span>
    <span class="k">return</span> <span class="n">flex_wrapper</span>


<span class="c1"># -----------------------------------------------------------------------------</span>
<span class="c1"># DataFrame</span>


<span class="k">def</span> <span class="nf">_combine_series_frame</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">func</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">level</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Apply binary operator `func` to self, other using alignment and fill</span>
<span class="sd">    conventions determined by the fill_value, axis, and level kwargs.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self : DataFrame</span>
<span class="sd">    other : Series</span>
<span class="sd">    func : binary operator</span>
<span class="sd">    fill_value : object, default None</span>
<span class="sd">    axis : {0, 1, &#39;columns&#39;, &#39;index&#39;, None}, default None</span>
<span class="sd">    level : int or None, default None</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    result : DataFrame</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">fill_value</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span>
            <span class="s2">&quot;fill_value </span><span class="si">{fill}</span><span class="s2"> not supported.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">fill</span><span class="o">=</span><span class="n">fill_value</span><span class="p">)</span>
        <span class="p">)</span>

    <span class="k">if</span> <span class="n">axis</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">axis</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_axis_number</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">axis</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_combine_match_index</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">func</span><span class="p">,</span> <span class="n">level</span><span class="o">=</span><span class="n">level</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_combine_match_columns</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">func</span><span class="p">,</span> <span class="n">level</span><span class="o">=</span><span class="n">level</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">len</span><span class="p">(</span><span class="n">other</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="c1"># Ambiguous case, use _series so works with DataFrame</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_constructor</span><span class="p">(</span>
                <span class="n">data</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_series</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="n">columns</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">columns</span>
            <span class="p">)</span>

        <span class="c1"># default axis is columns</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_combine_match_columns</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">func</span><span class="p">,</span> <span class="n">level</span><span class="o">=</span><span class="n">level</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_align_method_FRAME</span><span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">,</span> <span class="n">axis</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; convert rhs to meet lhs dims if input is list, tuple or np.ndarray &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">to_series</span><span class="p">(</span><span class="n">right</span><span class="p">):</span>
        <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span>
            <span class="s2">&quot;Unable to coerce to Series, length must be </span><span class="si">{req_len}</span><span class="s2">: &quot;</span> <span class="s2">&quot;given </span><span class="si">{given_len}</span><span class="s2">&quot;</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="n">axis</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">left</span><span class="o">.</span><span class="n">_get_axis_name</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span> <span class="o">==</span> <span class="s2">&quot;index&quot;</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">left</span><span class="o">.</span><span class="n">index</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">right</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="n">msg</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">req_len</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">left</span><span class="o">.</span><span class="n">index</span><span class="p">),</span> <span class="n">given_len</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">right</span><span class="p">))</span>
                <span class="p">)</span>
            <span class="n">right</span> <span class="o">=</span> <span class="n">left</span><span class="o">.</span><span class="n">_constructor_sliced</span><span class="p">(</span><span class="n">right</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="n">left</span><span class="o">.</span><span class="n">index</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">left</span><span class="o">.</span><span class="n">columns</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">right</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="n">msg</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">req_len</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">left</span><span class="o">.</span><span class="n">columns</span><span class="p">),</span> <span class="n">given_len</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">right</span><span class="p">))</span>
                <span class="p">)</span>
            <span class="n">right</span> <span class="o">=</span> <span class="n">left</span><span class="o">.</span><span class="n">_constructor_sliced</span><span class="p">(</span><span class="n">right</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="n">left</span><span class="o">.</span><span class="n">columns</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">right</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">right</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>

        <span class="k">if</span> <span class="n">right</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">right</span> <span class="o">=</span> <span class="n">to_series</span><span class="p">(</span><span class="n">right</span><span class="p">)</span>

        <span class="k">elif</span> <span class="n">right</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">right</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="n">left</span><span class="o">.</span><span class="n">shape</span><span class="p">:</span>
                <span class="n">right</span> <span class="o">=</span> <span class="n">left</span><span class="o">.</span><span class="n">_constructor</span><span class="p">(</span><span class="n">right</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="n">left</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="n">columns</span><span class="o">=</span><span class="n">left</span><span class="o">.</span><span class="n">columns</span><span class="p">)</span>

            <span class="k">elif</span> <span class="n">right</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">left</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">and</span> <span class="n">right</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="c1"># Broadcast across columns</span>
                <span class="n">right</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">broadcast_to</span><span class="p">(</span><span class="n">right</span><span class="p">,</span> <span class="n">left</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
                <span class="n">right</span> <span class="o">=</span> <span class="n">left</span><span class="o">.</span><span class="n">_constructor</span><span class="p">(</span><span class="n">right</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="n">left</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="n">columns</span><span class="o">=</span><span class="n">left</span><span class="o">.</span><span class="n">columns</span><span class="p">)</span>

            <span class="k">elif</span> <span class="n">right</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">left</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="ow">and</span> <span class="n">right</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="c1"># Broadcast along rows</span>
                <span class="n">right</span> <span class="o">=</span> <span class="n">to_series</span><span class="p">(</span><span class="n">right</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:])</span>

            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;Unable to coerce to DataFrame, shape &quot;</span>
                    <span class="s2">&quot;must be </span><span class="si">{req_shape}</span><span class="s2">: given </span><span class="si">{given_shape}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                        <span class="n">req_shape</span><span class="o">=</span><span class="n">left</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">given_shape</span><span class="o">=</span><span class="n">right</span><span class="o">.</span><span class="n">shape</span>
                    <span class="p">)</span>
                <span class="p">)</span>

        <span class="k">elif</span> <span class="n">right</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Unable to coerce to Series/DataFrame, dim &quot;</span>
                <span class="s2">&quot;must be &lt;= 2: </span><span class="si">{dim}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">dim</span><span class="o">=</span><span class="n">right</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
            <span class="p">)</span>

    <span class="k">elif</span> <span class="n">is_list_like</span><span class="p">(</span><span class="n">right</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">right</span><span class="p">,</span> <span class="p">(</span><span class="n">ABCSeries</span><span class="p">,</span> <span class="n">ABCDataFrame</span><span class="p">)):</span>
        <span class="c1"># GH17901</span>
        <span class="n">right</span> <span class="o">=</span> <span class="n">to_series</span><span class="p">(</span><span class="n">right</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">right</span>


<span class="k">def</span> <span class="nf">_arith_method_FRAME</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">op</span><span class="p">,</span> <span class="n">special</span><span class="p">):</span>
    <span class="n">str_rep</span> <span class="o">=</span> <span class="n">_get_opstr</span><span class="p">(</span><span class="n">op</span><span class="p">,</span> <span class="bp">cls</span><span class="p">)</span>
    <span class="n">op_name</span> <span class="o">=</span> <span class="n">_get_op_name</span><span class="p">(</span><span class="n">op</span><span class="p">,</span> <span class="n">special</span><span class="p">)</span>
    <span class="n">eval_kwargs</span> <span class="o">=</span> <span class="n">_gen_eval_kwargs</span><span class="p">(</span><span class="n">op_name</span><span class="p">)</span>
    <span class="n">default_axis</span> <span class="o">=</span> <span class="n">_get_frame_op_default_axis</span><span class="p">(</span><span class="n">op_name</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">na_op</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
        <span class="kn">import</span> <span class="nn">pandas.core.computation.expressions</span> <span class="k">as</span> <span class="nn">expressions</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">expressions</span><span class="o">.</span><span class="n">evaluate</span><span class="p">(</span><span class="n">op</span><span class="p">,</span> <span class="n">str_rep</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="o">**</span><span class="n">eval_kwargs</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">masked_arith_op</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">op</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">missing</span><span class="o">.</span><span class="n">dispatch_fill_zeros</span><span class="p">(</span><span class="n">op</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">result</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">op_name</span> <span class="ow">in</span> <span class="n">_op_descriptions</span><span class="p">:</span>
        <span class="c1"># i.e. include &quot;add&quot; but not &quot;__add__&quot;</span>
        <span class="n">doc</span> <span class="o">=</span> <span class="n">_make_flex_doc</span><span class="p">(</span><span class="n">op_name</span><span class="p">,</span> <span class="s2">&quot;dataframe&quot;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">doc</span> <span class="o">=</span> <span class="n">_arith_doc_FRAME</span> <span class="o">%</span> <span class="n">op_name</span>

    <span class="nd">@Appender</span><span class="p">(</span><span class="n">doc</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">default_axis</span><span class="p">,</span> <span class="n">level</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>

        <span class="n">other</span> <span class="o">=</span> <span class="n">_align_method_FRAME</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">axis</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">ABCDataFrame</span><span class="p">):</span>
            <span class="c1"># Another DataFrame</span>
            <span class="n">pass_op</span> <span class="o">=</span> <span class="n">op</span> <span class="k">if</span> <span class="n">should_series_dispatch</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">op</span><span class="p">)</span> <span class="k">else</span> <span class="n">na_op</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_combine_frame</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">pass_op</span><span class="p">,</span> <span class="n">fill_value</span><span class="p">,</span> <span class="n">level</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">ABCSeries</span><span class="p">):</span>
            <span class="c1"># For these values of `axis`, we end up dispatching to Series op,</span>
            <span class="c1"># so do not want the masked op.</span>
            <span class="n">pass_op</span> <span class="o">=</span> <span class="n">op</span> <span class="k">if</span> <span class="n">axis</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="s2">&quot;columns&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span> <span class="k">else</span> <span class="n">na_op</span>
            <span class="k">return</span> <span class="n">_combine_series_frame</span><span class="p">(</span>
                <span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">pass_op</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=</span><span class="n">fill_value</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">level</span><span class="o">=</span><span class="n">level</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">fill_value</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="bp">self</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fillna</span><span class="p">(</span><span class="n">fill_value</span><span class="p">)</span>

            <span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">ndim</span><span class="p">(</span><span class="n">other</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_combine_const</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">op</span><span class="p">)</span>

    <span class="n">f</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">=</span> <span class="n">op_name</span>

    <span class="k">return</span> <span class="n">f</span>


<span class="k">def</span> <span class="nf">_flex_comp_method_FRAME</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">op</span><span class="p">,</span> <span class="n">special</span><span class="p">):</span>
    <span class="n">str_rep</span> <span class="o">=</span> <span class="n">_get_opstr</span><span class="p">(</span><span class="n">op</span><span class="p">,</span> <span class="bp">cls</span><span class="p">)</span>
    <span class="n">op_name</span> <span class="o">=</span> <span class="n">_get_op_name</span><span class="p">(</span><span class="n">op</span><span class="p">,</span> <span class="n">special</span><span class="p">)</span>
    <span class="n">default_axis</span> <span class="o">=</span> <span class="n">_get_frame_op_default_axis</span><span class="p">(</span><span class="n">op_name</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">na_op</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">with</span> <span class="n">np</span><span class="o">.</span><span class="n">errstate</span><span class="p">(</span><span class="n">invalid</span><span class="o">=</span><span class="s2">&quot;ignore&quot;</span><span class="p">):</span>
                <span class="n">result</span> <span class="o">=</span> <span class="n">op</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">mask_cmp_op</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">op</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">result</span>

    <span class="n">doc</span> <span class="o">=</span> <span class="n">_flex_comp_doc_FRAME</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
        <span class="n">op_name</span><span class="o">=</span><span class="n">op_name</span><span class="p">,</span> <span class="n">desc</span><span class="o">=</span><span class="n">_op_descriptions</span><span class="p">[</span><span class="n">op_name</span><span class="p">][</span><span class="s2">&quot;desc&quot;</span><span class="p">]</span>
    <span class="p">)</span>

    <span class="nd">@Appender</span><span class="p">(</span><span class="n">doc</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">default_axis</span><span class="p">,</span> <span class="n">level</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>

        <span class="n">other</span> <span class="o">=</span> <span class="n">_align_method_FRAME</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">axis</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">ABCDataFrame</span><span class="p">):</span>
            <span class="c1"># Another DataFrame</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_indexed_same</span><span class="p">(</span><span class="n">other</span><span class="p">):</span>
                <span class="bp">self</span><span class="p">,</span> <span class="n">other</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">align</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="s2">&quot;outer&quot;</span><span class="p">,</span> <span class="n">level</span><span class="o">=</span><span class="n">level</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">dispatch_to_series</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">na_op</span><span class="p">,</span> <span class="n">str_rep</span><span class="p">)</span>

        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">ABCSeries</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">_combine_series_frame</span><span class="p">(</span>
                <span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">na_op</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">level</span><span class="o">=</span><span class="n">level</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">ndim</span><span class="p">(</span><span class="n">other</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">,</span> <span class="n">other</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_combine_const</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">na_op</span><span class="p">)</span>

    <span class="n">f</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">=</span> <span class="n">op_name</span>

    <span class="k">return</span> <span class="n">f</span>


<span class="k">def</span> <span class="nf">_comp_method_FRAME</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">func</span><span class="p">,</span> <span class="n">special</span><span class="p">):</span>
    <span class="n">str_rep</span> <span class="o">=</span> <span class="n">_get_opstr</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="bp">cls</span><span class="p">)</span>
    <span class="n">op_name</span> <span class="o">=</span> <span class="n">_get_op_name</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">special</span><span class="p">)</span>

    <span class="nd">@Appender</span><span class="p">(</span><span class="s2">&quot;Wrapper for comparison method </span><span class="si">{name}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="n">op_name</span><span class="p">))</span>
    <span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>

        <span class="n">other</span> <span class="o">=</span> <span class="n">_align_method_FRAME</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">ABCDataFrame</span><span class="p">):</span>
            <span class="c1"># Another DataFrame</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_indexed_same</span><span class="p">(</span><span class="n">other</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;Can only compare identically-labeled &quot;</span> <span class="s2">&quot;DataFrame objects&quot;</span>
                <span class="p">)</span>
            <span class="k">return</span> <span class="n">dispatch_to_series</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">func</span><span class="p">,</span> <span class="n">str_rep</span><span class="p">)</span>

        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">ABCSeries</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">_combine_series_frame</span><span class="p">(</span>
                <span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">func</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">level</span><span class="o">=</span><span class="kc">None</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>

            <span class="c1"># straight boolean comparisons we want to allow all columns</span>
            <span class="c1"># (regardless of dtype to pass thru) See #4537 for discussion.</span>
            <span class="n">res</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_combine_const</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">func</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">res</span><span class="o">.</span><span class="n">fillna</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">bool</span><span class="p">)</span>

    <span class="n">f</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">=</span> <span class="n">op_name</span>

    <span class="k">return</span> <span class="n">f</span>


<span class="c1"># -----------------------------------------------------------------------------</span>
<span class="c1"># Sparse</span>


<span class="k">def</span> <span class="nf">_cast_sparse_series_op</span><span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">,</span> <span class="n">opname</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    For SparseSeries operation, coerce to float64 if the result is expected</span>
<span class="sd">    to have NaN or inf values</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    left : SparseArray</span>
<span class="sd">    right : SparseArray</span>
<span class="sd">    opname : str</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    left : SparseArray</span>
<span class="sd">    right : SparseArray</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">from</span> <span class="nn">pandas.core.sparse.api</span> <span class="k">import</span> <span class="n">SparseDtype</span>

    <span class="n">opname</span> <span class="o">=</span> <span class="n">opname</span><span class="o">.</span><span class="n">strip</span><span class="p">(</span><span class="s2">&quot;_&quot;</span><span class="p">)</span>

    <span class="c1"># TODO: This should be moved to the array?</span>
    <span class="k">if</span> <span class="n">is_integer_dtype</span><span class="p">(</span><span class="n">left</span><span class="p">)</span> <span class="ow">and</span> <span class="n">is_integer_dtype</span><span class="p">(</span><span class="n">right</span><span class="p">):</span>
        <span class="c1"># series coerces to float64 if result should have NaN/inf</span>
        <span class="k">if</span> <span class="n">opname</span> <span class="ow">in</span> <span class="p">(</span><span class="s2">&quot;floordiv&quot;</span><span class="p">,</span> <span class="s2">&quot;mod&quot;</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">right</span><span class="o">.</span><span class="n">to_dense</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
            <span class="n">left</span> <span class="o">=</span> <span class="n">left</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">SparseDtype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">,</span> <span class="n">left</span><span class="o">.</span><span class="n">fill_value</span><span class="p">))</span>
            <span class="n">right</span> <span class="o">=</span> <span class="n">right</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">SparseDtype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">,</span> <span class="n">right</span><span class="o">.</span><span class="n">fill_value</span><span class="p">))</span>
        <span class="k">elif</span> <span class="n">opname</span> <span class="ow">in</span> <span class="p">(</span><span class="s2">&quot;rfloordiv&quot;</span><span class="p">,</span> <span class="s2">&quot;rmod&quot;</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">left</span><span class="o">.</span><span class="n">to_dense</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
            <span class="n">left</span> <span class="o">=</span> <span class="n">left</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">SparseDtype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">,</span> <span class="n">left</span><span class="o">.</span><span class="n">fill_value</span><span class="p">))</span>
            <span class="n">right</span> <span class="o">=</span> <span class="n">right</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">SparseDtype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">,</span> <span class="n">right</span><span class="o">.</span><span class="n">fill_value</span><span class="p">))</span>

    <span class="k">return</span> <span class="n">left</span><span class="p">,</span> <span class="n">right</span>


<span class="k">def</span> <span class="nf">_arith_method_SPARSE_SERIES</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">op</span><span class="p">,</span> <span class="n">special</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Wrapper function for Series arithmetic operations, to avoid</span>
<span class="sd">    code duplication.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">op_name</span> <span class="o">=</span> <span class="n">_get_op_name</span><span class="p">(</span><span class="n">op</span><span class="p">,</span> <span class="n">special</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">wrapper</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">ABCDataFrame</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">NotImplemented</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">ABCSeries</span><span class="p">):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">ABCSparseSeries</span><span class="p">):</span>
                <span class="n">other</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">to_sparse</span><span class="p">(</span><span class="n">fill_value</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">fill_value</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">_sparse_series_op</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">op</span><span class="p">,</span> <span class="n">op_name</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">is_scalar</span><span class="p">(</span><span class="n">other</span><span class="p">):</span>
            <span class="k">with</span> <span class="n">np</span><span class="o">.</span><span class="n">errstate</span><span class="p">(</span><span class="nb">all</span><span class="o">=</span><span class="s2">&quot;ignore&quot;</span><span class="p">):</span>
                <span class="n">new_values</span> <span class="o">=</span> <span class="n">op</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_constructor</span><span class="p">(</span><span class="n">new_values</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>  <span class="c1"># pragma: no cover</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                <span class="s2">&quot;operation with </span><span class="si">{other}</span><span class="s2"> not supported&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">other</span><span class="o">=</span><span class="nb">type</span><span class="p">(</span><span class="n">other</span><span class="p">))</span>
            <span class="p">)</span>

    <span class="n">wrapper</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">=</span> <span class="n">op_name</span>
    <span class="k">return</span> <span class="n">wrapper</span>


<span class="k">def</span> <span class="nf">_sparse_series_op</span><span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">,</span> <span class="n">op</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
    <span class="n">left</span><span class="p">,</span> <span class="n">right</span> <span class="o">=</span> <span class="n">left</span><span class="o">.</span><span class="n">align</span><span class="p">(</span><span class="n">right</span><span class="p">,</span> <span class="n">join</span><span class="o">=</span><span class="s2">&quot;outer&quot;</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="n">new_index</span> <span class="o">=</span> <span class="n">left</span><span class="o">.</span><span class="n">index</span>
    <span class="n">new_name</span> <span class="o">=</span> <span class="n">get_op_result_name</span><span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">)</span>

    <span class="kn">from</span> <span class="nn">pandas.core.arrays.sparse</span> <span class="k">import</span> <span class="n">_sparse_array_op</span>

    <span class="n">lvalues</span><span class="p">,</span> <span class="n">rvalues</span> <span class="o">=</span> <span class="n">_cast_sparse_series_op</span><span class="p">(</span><span class="n">left</span><span class="o">.</span><span class="n">values</span><span class="p">,</span> <span class="n">right</span><span class="o">.</span><span class="n">values</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">_sparse_array_op</span><span class="p">(</span><span class="n">lvalues</span><span class="p">,</span> <span class="n">rvalues</span><span class="p">,</span> <span class="n">op</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">left</span><span class="o">.</span><span class="n">_constructor</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="n">new_index</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">new_name</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">maybe_dispatch_ufunc_to_dunder_op</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ArrayLike</span><span class="p">,</span> <span class="n">ufunc</span><span class="p">:</span> <span class="n">Callable</span><span class="p">,</span> <span class="n">method</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="o">*</span><span class="n">inputs</span><span class="p">:</span> <span class="n">ArrayLike</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">:</span> <span class="n">Any</span>
<span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Dispatch a ufunc to the equivalent dunder method.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self : ArrayLike</span>
<span class="sd">        The array whose dunder method we dispatch to</span>
<span class="sd">    ufunc : Callable</span>
<span class="sd">        A NumPy ufunc</span>
<span class="sd">    method : {&#39;reduce&#39;, &#39;accumulate&#39;, &#39;reduceat&#39;, &#39;outer&#39;, &#39;at&#39;, &#39;__call__&#39;}</span>
<span class="sd">    inputs : ArrayLike</span>
<span class="sd">        The input arrays.</span>
<span class="sd">    kwargs : Any</span>
<span class="sd">        The additional keyword arguments, e.g. ``out``.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    result : Any</span>
<span class="sd">        The result of applying the ufunc</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># special has the ufuncs we dispatch to the dunder op on</span>
    <span class="n">special</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s2">&quot;add&quot;</span><span class="p">,</span>
        <span class="s2">&quot;sub&quot;</span><span class="p">,</span>
        <span class="s2">&quot;mul&quot;</span><span class="p">,</span>
        <span class="s2">&quot;pow&quot;</span><span class="p">,</span>
        <span class="s2">&quot;mod&quot;</span><span class="p">,</span>
        <span class="s2">&quot;floordiv&quot;</span><span class="p">,</span>
        <span class="s2">&quot;truediv&quot;</span><span class="p">,</span>
        <span class="s2">&quot;divmod&quot;</span><span class="p">,</span>
        <span class="s2">&quot;eq&quot;</span><span class="p">,</span>
        <span class="s2">&quot;ne&quot;</span><span class="p">,</span>
        <span class="s2">&quot;lt&quot;</span><span class="p">,</span>
        <span class="s2">&quot;gt&quot;</span><span class="p">,</span>
        <span class="s2">&quot;le&quot;</span><span class="p">,</span>
        <span class="s2">&quot;ge&quot;</span><span class="p">,</span>
        <span class="s2">&quot;remainder&quot;</span><span class="p">,</span>
        <span class="s2">&quot;matmul&quot;</span><span class="p">,</span>
    <span class="p">}</span>
    <span class="n">aliases</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s2">&quot;subtract&quot;</span><span class="p">:</span> <span class="s2">&quot;sub&quot;</span><span class="p">,</span>
        <span class="s2">&quot;multiply&quot;</span><span class="p">:</span> <span class="s2">&quot;mul&quot;</span><span class="p">,</span>
        <span class="s2">&quot;floor_divide&quot;</span><span class="p">:</span> <span class="s2">&quot;floordiv&quot;</span><span class="p">,</span>
        <span class="s2">&quot;true_divide&quot;</span><span class="p">:</span> <span class="s2">&quot;truediv&quot;</span><span class="p">,</span>
        <span class="s2">&quot;power&quot;</span><span class="p">:</span> <span class="s2">&quot;pow&quot;</span><span class="p">,</span>
        <span class="s2">&quot;remainder&quot;</span><span class="p">:</span> <span class="s2">&quot;mod&quot;</span><span class="p">,</span>
        <span class="s2">&quot;divide&quot;</span><span class="p">:</span> <span class="s2">&quot;div&quot;</span><span class="p">,</span>
        <span class="s2">&quot;equal&quot;</span><span class="p">:</span> <span class="s2">&quot;eq&quot;</span><span class="p">,</span>
        <span class="s2">&quot;not_equal&quot;</span><span class="p">:</span> <span class="s2">&quot;ne&quot;</span><span class="p">,</span>
        <span class="s2">&quot;less&quot;</span><span class="p">:</span> <span class="s2">&quot;lt&quot;</span><span class="p">,</span>
        <span class="s2">&quot;less_equal&quot;</span><span class="p">:</span> <span class="s2">&quot;le&quot;</span><span class="p">,</span>
        <span class="s2">&quot;greater&quot;</span><span class="p">:</span> <span class="s2">&quot;gt&quot;</span><span class="p">,</span>
        <span class="s2">&quot;greater_equal&quot;</span><span class="p">:</span> <span class="s2">&quot;ge&quot;</span><span class="p">,</span>
    <span class="p">}</span>

    <span class="c1"># For op(., Array) -&gt; Array.__r{op}__</span>
    <span class="n">flipped</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s2">&quot;lt&quot;</span><span class="p">:</span> <span class="s2">&quot;__gt__&quot;</span><span class="p">,</span>
        <span class="s2">&quot;le&quot;</span><span class="p">:</span> <span class="s2">&quot;__ge__&quot;</span><span class="p">,</span>
        <span class="s2">&quot;gt&quot;</span><span class="p">:</span> <span class="s2">&quot;__lt__&quot;</span><span class="p">,</span>
        <span class="s2">&quot;ge&quot;</span><span class="p">:</span> <span class="s2">&quot;__le__&quot;</span><span class="p">,</span>
        <span class="s2">&quot;eq&quot;</span><span class="p">:</span> <span class="s2">&quot;__eq__&quot;</span><span class="p">,</span>
        <span class="s2">&quot;ne&quot;</span><span class="p">:</span> <span class="s2">&quot;__ne__&quot;</span><span class="p">,</span>
    <span class="p">}</span>

    <span class="n">op_name</span> <span class="o">=</span> <span class="n">ufunc</span><span class="o">.</span><span class="vm">__name__</span>
    <span class="n">op_name</span> <span class="o">=</span> <span class="n">aliases</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">op_name</span><span class="p">,</span> <span class="n">op_name</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">not_implemented</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">NotImplemented</span>

    <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="s2">&quot;__call__&quot;</span> <span class="ow">and</span> <span class="n">op_name</span> <span class="ow">in</span> <span class="n">special</span> <span class="ow">and</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;out&quot;</span><span class="p">)</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">inputs</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)):</span>
            <span class="n">name</span> <span class="o">=</span> <span class="s2">&quot;__</span><span class="si">{}</span><span class="s2">__&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">op_name</span><span class="p">)</span>
            <span class="k">return</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">not_implemented</span><span class="p">)(</span><span class="n">inputs</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">name</span> <span class="o">=</span> <span class="n">flipped</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">op_name</span><span class="p">,</span> <span class="s2">&quot;__r</span><span class="si">{}</span><span class="s2">__&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">op_name</span><span class="p">))</span>
            <span class="k">return</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">not_implemented</span><span class="p">)(</span><span class="n">inputs</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">NotImplemented</span>
</pre></div>

           </div>
           
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2020, observethesun

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>